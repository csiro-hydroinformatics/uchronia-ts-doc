{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Uchronia - Draft API documentation(s) \u00b6 Under Construction! This site will host the technical documentation of csiro-hydroinformatics/uchronia-time-series for its C++ core and its Python package wrapper","title":"Home"},{"location":"#uchronia-draft-api-documentations","text":"Under Construction! This site will host the technical documentation of csiro-hydroinformatics/uchronia-time-series for its C++ core and its Python package wrapper","title":"Uchronia - Draft API documentation(s)"},{"location":"cpp/","text":"Uchronia \u00b6 Placeholder home page. - C++ doc.","title":"Home"},{"location":"cpp/#uchronia","text":"Placeholder home page. - C++ doc.","title":"Uchronia"},{"location":"cpp/Classes/","text":"Classes \u00b6 namespace boost::gregorian namespace boost::posix_time namespace cinterop namespace statistics namespace timeseries namespace cinterop::utils namespace datatypes namespace exceptions class ExceptionUtilities struct RangeCheck struct RangeCheck< size_t > class TimeSeriesChecks namespace interop class MissingValueHandling namespace io class IoHelper namespace tests class DataTestHelper class FileSystemHelper class TempFileCleaner class TestDataLocationHelper class TestEnsembleTimeSeriesStore class TestSingleTimeSeriesStore class TestTimeSeriesEnsembleTimeSeriesStore A time series store for unit tests. class TestTimeSeriesStoreFactory namespace timeseries struct CommonTypes Typical ensemble and time series data types derived from a fundamental data type for each data item. class DataDescriptor class DataDimensionDescriptor class DataGeometryProvider class DefaultMissingFloatingPointPolicy struct DefaultMissingValuePolicyTypeFactory class DimensionsDefinitions class EagerWriter class EnsembleStoragePolicy class EnsembleTimeSeriesStore Interface definition for storages of ensembles of univariate time series. class GlobalAttributes A class to hold the global attributes of a file stored in the SWIFT netCDF format. class IdentifiersProvider An interface definition for objects that can provide hierarchical identification. class IrregularTimeStepImplementation class MemoryCachingStorageWriter class MissingValuePolicy An interface for classes that define missing values in time series. class MonthlyQppTimeStepImplementation class MultiFileTimeSeriesEnsembleTimeSeriesStore An implementation of TimeSeriesEnsembleTimeSeriesStore such that the content of a time series is spread amongst several files. class MultiFileTsStorage An implementation of StoragePolicy such that the content of a time series is spread amongst several files. class MultiTimeSeries Template for time series with multiple values at time point; e.g. to hold multiple realizations of time series in an ensemble. class NegativeIsMissingFloadingPointPolicy class NetCdfEnsembleTimeSeriesStore class NetCdfSingleSeriesStore class NetCdfSourceInfo class NetCdfTimeSeriesEnsembleTimeSeriesStore class NullPointerIsMissingPolicy class RegularTimeStepImplementation class SharedVectorStorage A storage strategy for time serie such that data is a shared state amongst several time series. class SharedData class SingleNetCdfFileStore class SingleTimeSeriesStore Interface definition for storages of single, univariate time series. class StdVectorEnsembleStoragePolicy class StlVectorStorage class StoragePolicy An interface for classes that can handle the storage of data for time series. class SwiftNetcdfStoreFactory class TTimeSeries A template for univariate, single realisasion time series. class TTimeSeriesLibrary class TimeSeriesEnsembleTimeSeriesStoragePolicy class TimeSeriesEnsembleTimeSeriesStore Interface definition for storages of time series of ensembles of time series. class TimeSeriesIOHelper Representation of an univariate, ensemble time series with a SWIFT netCDF back end. class TimeSeriesInfoProvider An interface definition for classes that can provide essential time series temporal characteristics. class TimeSeriesLibrary Library of time series, for high level access to sources of time series that nmay have varying on-disk representations. class TimeSeriesLibraryDescription class TimeSeriesLibraryFactory class TimeSeriesOperations class TimeSeriesProvider Library of time series, for high level access to sources of univariate, single instance time series that may have varying on-disk representations. class TimeSeriesSourceInfo class TimeSeriesSourceInfoBuilder An abstract class to allow callers to inject custom time series data sources into a time series library. class TimeSeriesSourceInfoImpl class TimeSeriesStoreFactory class TimeStep Time step handling for time series. class TimeStepImplementation class TimeWindow An object that represents a time window, defining subset/trim operations on time series. class VariableAttributes A class to hold the attributes of a netCDF variable stored in the SWIFT netCDF format. class VariableDefinition class WritableTimeSeriesEnsembleTimeSeriesStore struct ensemble_of namespace io class ConfigFileHelper class SwiftNetCDFAccess Class responsible for the low-level read/write operations from/to a SWIFT netCDF file. class SwiftNetCDFVariablePersister class SwiftNetCDFVariablePersister< double > class SwiftNetCDFVariablePersister< float > class SwiftNetCDFVariablePersister< int > class SwiftNetCDFVariablePersister< long > struct item_type_of struct time_series_of namespace utils struct DisposeVectorTypeFactory class IfThenElse class IfThenElse< false, Ta, Tb > class IfThenElse< true, Ta, Tb > class PointerTypeVectorDispose class STLHelper class Comparer class StringProcessing class ValueTypeVectorDispose class bad_lexical_cast A bad_lexical_cast that inherits from std::exception, unlike Boost's. Needed for graceful C API interop. namespace moirai struct known_conversions< TimeSeriesProvider< double > > namespace std Updated on 2022-08-20 at 19:28:22 +1000","title":"Classes"},{"location":"cpp/Classes/#classes","text":"namespace boost::gregorian namespace boost::posix_time namespace cinterop namespace statistics namespace timeseries namespace cinterop::utils namespace datatypes namespace exceptions class ExceptionUtilities struct RangeCheck struct RangeCheck< size_t > class TimeSeriesChecks namespace interop class MissingValueHandling namespace io class IoHelper namespace tests class DataTestHelper class FileSystemHelper class TempFileCleaner class TestDataLocationHelper class TestEnsembleTimeSeriesStore class TestSingleTimeSeriesStore class TestTimeSeriesEnsembleTimeSeriesStore A time series store for unit tests. class TestTimeSeriesStoreFactory namespace timeseries struct CommonTypes Typical ensemble and time series data types derived from a fundamental data type for each data item. class DataDescriptor class DataDimensionDescriptor class DataGeometryProvider class DefaultMissingFloatingPointPolicy struct DefaultMissingValuePolicyTypeFactory class DimensionsDefinitions class EagerWriter class EnsembleStoragePolicy class EnsembleTimeSeriesStore Interface definition for storages of ensembles of univariate time series. class GlobalAttributes A class to hold the global attributes of a file stored in the SWIFT netCDF format. class IdentifiersProvider An interface definition for objects that can provide hierarchical identification. class IrregularTimeStepImplementation class MemoryCachingStorageWriter class MissingValuePolicy An interface for classes that define missing values in time series. class MonthlyQppTimeStepImplementation class MultiFileTimeSeriesEnsembleTimeSeriesStore An implementation of TimeSeriesEnsembleTimeSeriesStore such that the content of a time series is spread amongst several files. class MultiFileTsStorage An implementation of StoragePolicy such that the content of a time series is spread amongst several files. class MultiTimeSeries Template for time series with multiple values at time point; e.g. to hold multiple realizations of time series in an ensemble. class NegativeIsMissingFloadingPointPolicy class NetCdfEnsembleTimeSeriesStore class NetCdfSingleSeriesStore class NetCdfSourceInfo class NetCdfTimeSeriesEnsembleTimeSeriesStore class NullPointerIsMissingPolicy class RegularTimeStepImplementation class SharedVectorStorage A storage strategy for time serie such that data is a shared state amongst several time series. class SharedData class SingleNetCdfFileStore class SingleTimeSeriesStore Interface definition for storages of single, univariate time series. class StdVectorEnsembleStoragePolicy class StlVectorStorage class StoragePolicy An interface for classes that can handle the storage of data for time series. class SwiftNetcdfStoreFactory class TTimeSeries A template for univariate, single realisasion time series. class TTimeSeriesLibrary class TimeSeriesEnsembleTimeSeriesStoragePolicy class TimeSeriesEnsembleTimeSeriesStore Interface definition for storages of time series of ensembles of time series. class TimeSeriesIOHelper Representation of an univariate, ensemble time series with a SWIFT netCDF back end. class TimeSeriesInfoProvider An interface definition for classes that can provide essential time series temporal characteristics. class TimeSeriesLibrary Library of time series, for high level access to sources of time series that nmay have varying on-disk representations. class TimeSeriesLibraryDescription class TimeSeriesLibraryFactory class TimeSeriesOperations class TimeSeriesProvider Library of time series, for high level access to sources of univariate, single instance time series that may have varying on-disk representations. class TimeSeriesSourceInfo class TimeSeriesSourceInfoBuilder An abstract class to allow callers to inject custom time series data sources into a time series library. class TimeSeriesSourceInfoImpl class TimeSeriesStoreFactory class TimeStep Time step handling for time series. class TimeStepImplementation class TimeWindow An object that represents a time window, defining subset/trim operations on time series. class VariableAttributes A class to hold the attributes of a netCDF variable stored in the SWIFT netCDF format. class VariableDefinition class WritableTimeSeriesEnsembleTimeSeriesStore struct ensemble_of namespace io class ConfigFileHelper class SwiftNetCDFAccess Class responsible for the low-level read/write operations from/to a SWIFT netCDF file. class SwiftNetCDFVariablePersister class SwiftNetCDFVariablePersister< double > class SwiftNetCDFVariablePersister< float > class SwiftNetCDFVariablePersister< int > class SwiftNetCDFVariablePersister< long > struct item_type_of struct time_series_of namespace utils struct DisposeVectorTypeFactory class IfThenElse class IfThenElse< false, Ta, Tb > class IfThenElse< true, Ta, Tb > class PointerTypeVectorDispose class STLHelper class Comparer class StringProcessing class ValueTypeVectorDispose class bad_lexical_cast A bad_lexical_cast that inherits from std::exception, unlike Boost's. Needed for graceful C API interop. namespace moirai struct known_conversions< TimeSeriesProvider< double > > namespace std Updated on 2022-08-20 at 19:28:22 +1000","title":"Classes"},{"location":"cpp/Classes/classdatatypes_1_1exceptions_1_1ExceptionUtilities/","text":"datatypes::exceptions::ExceptionUtilities \u00b6 #include <exception_utilities.h> Public Functions \u00b6 Name void ThrowInvalidArgument (const string & msg =\"Invalid argument\") void ThrowInvalidOperation (const string & msg =\"Invalid operation\") void ThrowInvalidArgumentModelVariableId (const string & variableId) void ThrowNotImplemented (const string & msg =\"Not implemented\") void ThrowNotSupported (const string & typeName, const string & methodName) void ThrowNotSupported (const string & msg) void ThrowOutOfRange (const string & msg =\"Operation led to a state out of range\") template <typename T > void CheckInRange (T value, T min, T max, const string & variableName) void CheckFileExists (const boost::filesystem::path & p) void CheckFileDoesNotExist (const boost::filesystem::path & p) void CheckExists (const boost::filesystem::path & p) Public Functions Documentation \u00b6 function ThrowInvalidArgument \u00b6 static inline void ThrowInvalidArgument ( const string & msg = \"Invalid argument\" ) function ThrowInvalidOperation \u00b6 static inline void ThrowInvalidOperation ( const string & msg = \"Invalid operation\" ) function ThrowInvalidArgumentModelVariableId \u00b6 static inline void ThrowInvalidArgumentModelVariableId ( const string & variableId ) function ThrowNotImplemented \u00b6 static inline void ThrowNotImplemented ( const string & msg = \"Not implemented\" ) function ThrowNotSupported \u00b6 static inline void ThrowNotSupported ( const string & typeName , const string & methodName ) function ThrowNotSupported \u00b6 static inline void ThrowNotSupported ( const string & msg ) function ThrowOutOfRange \u00b6 static inline void ThrowOutOfRange ( const string & msg = \"Operation led to a state out of range\" ) function CheckInRange \u00b6 template < typename T > static inline void CheckInRange ( T value , T min , T max , const string & variableName ) function CheckFileExists \u00b6 static inline void CheckFileExists ( const boost :: filesystem :: path & p ) function CheckFileDoesNotExist \u00b6 static inline void CheckFileDoesNotExist ( const boost :: filesystem :: path & p ) function CheckExists \u00b6 static inline void CheckExists ( const boost :: filesystem :: path & p ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::exceptions::ExceptionUtilities"},{"location":"cpp/Classes/classdatatypes_1_1exceptions_1_1ExceptionUtilities/#datatypesexceptionsexceptionutilities","text":"#include <exception_utilities.h>","title":"datatypes::exceptions::ExceptionUtilities"},{"location":"cpp/Classes/classdatatypes_1_1exceptions_1_1ExceptionUtilities/#public-functions","text":"Name void ThrowInvalidArgument (const string & msg =\"Invalid argument\") void ThrowInvalidOperation (const string & msg =\"Invalid operation\") void ThrowInvalidArgumentModelVariableId (const string & variableId) void ThrowNotImplemented (const string & msg =\"Not implemented\") void ThrowNotSupported (const string & typeName, const string & methodName) void ThrowNotSupported (const string & msg) void ThrowOutOfRange (const string & msg =\"Operation led to a state out of range\") template <typename T > void CheckInRange (T value, T min, T max, const string & variableName) void CheckFileExists (const boost::filesystem::path & p) void CheckFileDoesNotExist (const boost::filesystem::path & p) void CheckExists (const boost::filesystem::path & p)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1exceptions_1_1ExceptionUtilities/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1exceptions_1_1ExceptionUtilities/#function-throwinvalidargument","text":"static inline void ThrowInvalidArgument ( const string & msg = \"Invalid argument\" )","title":"function ThrowInvalidArgument"},{"location":"cpp/Classes/classdatatypes_1_1exceptions_1_1ExceptionUtilities/#function-throwinvalidoperation","text":"static inline void ThrowInvalidOperation ( const string & msg = \"Invalid operation\" )","title":"function ThrowInvalidOperation"},{"location":"cpp/Classes/classdatatypes_1_1exceptions_1_1ExceptionUtilities/#function-throwinvalidargumentmodelvariableid","text":"static inline void ThrowInvalidArgumentModelVariableId ( const string & variableId )","title":"function ThrowInvalidArgumentModelVariableId"},{"location":"cpp/Classes/classdatatypes_1_1exceptions_1_1ExceptionUtilities/#function-thrownotimplemented","text":"static inline void ThrowNotImplemented ( const string & msg = \"Not implemented\" )","title":"function ThrowNotImplemented"},{"location":"cpp/Classes/classdatatypes_1_1exceptions_1_1ExceptionUtilities/#function-thrownotsupported","text":"static inline void ThrowNotSupported ( const string & typeName , const string & methodName )","title":"function ThrowNotSupported"},{"location":"cpp/Classes/classdatatypes_1_1exceptions_1_1ExceptionUtilities/#function-thrownotsupported_1","text":"static inline void ThrowNotSupported ( const string & msg )","title":"function ThrowNotSupported"},{"location":"cpp/Classes/classdatatypes_1_1exceptions_1_1ExceptionUtilities/#function-throwoutofrange","text":"static inline void ThrowOutOfRange ( const string & msg = \"Operation led to a state out of range\" )","title":"function ThrowOutOfRange"},{"location":"cpp/Classes/classdatatypes_1_1exceptions_1_1ExceptionUtilities/#function-checkinrange","text":"template < typename T > static inline void CheckInRange ( T value , T min , T max , const string & variableName )","title":"function CheckInRange"},{"location":"cpp/Classes/classdatatypes_1_1exceptions_1_1ExceptionUtilities/#function-checkfileexists","text":"static inline void CheckFileExists ( const boost :: filesystem :: path & p )","title":"function CheckFileExists"},{"location":"cpp/Classes/classdatatypes_1_1exceptions_1_1ExceptionUtilities/#function-checkfiledoesnotexist","text":"static inline void CheckFileDoesNotExist ( const boost :: filesystem :: path & p )","title":"function CheckFileDoesNotExist"},{"location":"cpp/Classes/classdatatypes_1_1exceptions_1_1ExceptionUtilities/#function-checkexists","text":"static inline void CheckExists ( const boost :: filesystem :: path & p ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function CheckExists"},{"location":"cpp/Classes/classdatatypes_1_1exceptions_1_1TimeSeriesChecks/","text":"datatypes::exceptions::TimeSeriesChecks \u00b6 #include <time_series.hpp> Public Functions \u00b6 Name void CheckOutOfRange (const string & msg, const datatypes::timeseries::TimeSeries & ts, const ptime & d) Public Functions Documentation \u00b6 function CheckOutOfRange \u00b6 static void CheckOutOfRange ( const string & msg , const datatypes :: timeseries :: TimeSeries & ts , const ptime & d ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::exceptions::TimeSeriesChecks"},{"location":"cpp/Classes/classdatatypes_1_1exceptions_1_1TimeSeriesChecks/#datatypesexceptionstimeserieschecks","text":"#include <time_series.hpp>","title":"datatypes::exceptions::TimeSeriesChecks"},{"location":"cpp/Classes/classdatatypes_1_1exceptions_1_1TimeSeriesChecks/#public-functions","text":"Name void CheckOutOfRange (const string & msg, const datatypes::timeseries::TimeSeries & ts, const ptime & d)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1exceptions_1_1TimeSeriesChecks/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1exceptions_1_1TimeSeriesChecks/#function-checkoutofrange","text":"static void CheckOutOfRange ( const string & msg , const datatypes :: timeseries :: TimeSeries & ts , const ptime & d ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function CheckOutOfRange"},{"location":"cpp/Classes/classdatatypes_1_1interop_1_1MissingValueHandling/","text":"datatypes::interop::MissingValueHandling \u00b6 #include <common.h> Public Attributes \u00b6 Name std::atomic< double > TimeSeriesMissingValueValue The time series missing value. Public Attributes Documentation \u00b6 variable TimeSeriesMissingValueValue \u00b6 static std :: atomic < double > TimeSeriesMissingValueValue ; The time series missing value. Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::interop::MissingValueHandling"},{"location":"cpp/Classes/classdatatypes_1_1interop_1_1MissingValueHandling/#datatypesinteropmissingvaluehandling","text":"#include <common.h>","title":"datatypes::interop::MissingValueHandling"},{"location":"cpp/Classes/classdatatypes_1_1interop_1_1MissingValueHandling/#public-attributes","text":"Name std::atomic< double > TimeSeriesMissingValueValue The time series missing value.","title":"Public Attributes"},{"location":"cpp/Classes/classdatatypes_1_1interop_1_1MissingValueHandling/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"cpp/Classes/classdatatypes_1_1interop_1_1MissingValueHandling/#variable-timeseriesmissingvaluevalue","text":"static std :: atomic < double > TimeSeriesMissingValueValue ; The time series missing value. Updated on 2022-08-20 at 19:28:22 +1000","title":"variable TimeSeriesMissingValueValue"},{"location":"cpp/Classes/classdatatypes_1_1io_1_1IoHelper/","text":"datatypes::io::IoHelper \u00b6 #include <io_helper.h> Public Functions \u00b6 Name bool FileExists (const boost::filesystem::path & p) bool PathExists (const boost::filesystem::path & p) bool DirExists (const boost::filesystem::path & p) string MakeFileName (const string & fileNamePattern, const string & id, const string & pattern =\"{0}\") bool IsFileNamePattern (const string & s) Public Attributes \u00b6 Name const string DefaultFilePattern Public Functions Documentation \u00b6 function FileExists \u00b6 static bool FileExists ( const boost :: filesystem :: path & p ) function PathExists \u00b6 static bool PathExists ( const boost :: filesystem :: path & p ) function DirExists \u00b6 static bool DirExists ( const boost :: filesystem :: path & p ) function MakeFileName \u00b6 static string MakeFileName ( const string & fileNamePattern , const string & id , const string & pattern = \"{0}\" ) function IsFileNamePattern \u00b6 static bool IsFileNamePattern ( const string & s ) Public Attributes Documentation \u00b6 variable DefaultFilePattern \u00b6 static const string DefaultFilePattern ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::io::IoHelper"},{"location":"cpp/Classes/classdatatypes_1_1io_1_1IoHelper/#datatypesioiohelper","text":"#include <io_helper.h>","title":"datatypes::io::IoHelper"},{"location":"cpp/Classes/classdatatypes_1_1io_1_1IoHelper/#public-functions","text":"Name bool FileExists (const boost::filesystem::path & p) bool PathExists (const boost::filesystem::path & p) bool DirExists (const boost::filesystem::path & p) string MakeFileName (const string & fileNamePattern, const string & id, const string & pattern =\"{0}\") bool IsFileNamePattern (const string & s)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1io_1_1IoHelper/#public-attributes","text":"Name const string DefaultFilePattern","title":"Public Attributes"},{"location":"cpp/Classes/classdatatypes_1_1io_1_1IoHelper/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1io_1_1IoHelper/#function-fileexists","text":"static bool FileExists ( const boost :: filesystem :: path & p )","title":"function FileExists"},{"location":"cpp/Classes/classdatatypes_1_1io_1_1IoHelper/#function-pathexists","text":"static bool PathExists ( const boost :: filesystem :: path & p )","title":"function PathExists"},{"location":"cpp/Classes/classdatatypes_1_1io_1_1IoHelper/#function-direxists","text":"static bool DirExists ( const boost :: filesystem :: path & p )","title":"function DirExists"},{"location":"cpp/Classes/classdatatypes_1_1io_1_1IoHelper/#function-makefilename","text":"static string MakeFileName ( const string & fileNamePattern , const string & id , const string & pattern = \"{0}\" )","title":"function MakeFileName"},{"location":"cpp/Classes/classdatatypes_1_1io_1_1IoHelper/#function-isfilenamepattern","text":"static bool IsFileNamePattern ( const string & s )","title":"function IsFileNamePattern"},{"location":"cpp/Classes/classdatatypes_1_1io_1_1IoHelper/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"cpp/Classes/classdatatypes_1_1io_1_1IoHelper/#variable-defaultfilepattern","text":"static const string DefaultFilePattern ; Updated on 2022-08-20 at 19:28:22 +1000","title":"variable DefaultFilePattern"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/","text":"datatypes::tests::DataTestHelper \u00b6 More... #include <datatypes_test_helpers.hpp> Public Types \u00b6 Name using typename CommonTypes < T >:: SeriesType SeriesType using typename CommonTypes < T >:: PtrSeriesType PtrSeriesType using typename CommonTypes < T >:: EnsembleType EnsembleType using typename CommonTypes < T >:: EnsemblePtrType EnsemblePtrType using typename CommonTypes < T >:: PtrEnsemblePtrType PtrEnsemblePtrType using typename CommonTypes < T >:: TSeriesEnsemblePtrType TSeriesEnsemblePtrType using typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType PtrTSeriesEnsemblePtrType typedef std::function< T(size_t, size_t, size_t)> FullElementValueFunc typedef std::function< T(size_t)> ElementValueFunc typedef std::function< SeriesType (size_t)> EnsembleValueFunc typedef std::function< EnsemblePtrType (size_t)> TsEnsembleValueFunc Public Functions \u00b6 Name TTimeSeries < T > Create (T * data, int num, const ptime & start =ptime(date(2000, 1, 1)), const TimeStep & timeStep =TimeStep::GetHourly()) TTimeSeries < T > Ramp (int num, const ptime & start =ptime(date(2000, 1, 1)), double from =0.0, double increment =1.0) TTimeSeries < T > Pulse (int length, T value =1, int firstPulse =0, int period =2, const ptime & start =ptime(date(2000, 1, 1)), const TimeStep & timeStep =TimeStep::GetHourly()) TTimeSeries < T > GetExpectedTestSingleTimeSeries (size_t indexInEnsemble, size_t length = kTimeSeriesLength , double constOffset =1, const ptime & startDate = TEST_START_TIME , const TimeStep & timeStep =TimeStep::GetHourly()) T * Seq (T from, T by, size_t num) vector< T > SeqVec (T from, T by, size_t num) vector< T > Rep (T value, size_t num) vector< T > Add (const vector< T > & a, const vector< T > & b) vector< T > Add (const vector< T > & a, const T & b) vector< T > Add (const T & a, const vector< T > & b) vector< T > Mult (const vector< T > & a, const vector< T > & b) vector< T > Mult (const vector< T > & a, const T & b) vector< T > Mult (const T & a, const vector< T > & b) vector< T > Neg (const vector< T > & a) vector< T * > * Seq (T from, T by, size_t num, size_t vecSize) void DeleteElements (vector< T * > & vec) bool AreEqual ( PtrSeriesType expected, PtrSeriesType actual) bool AreEqual ( PtrSeriesType actual, T expected) T DecimalRamp (size_t fcastIndex, size_t ensIndex, size_t seriesIndex) ElementValueFunc CreateValueGen (size_t fcastIndex, size_t ensIndex, FullElementValueFunc ffun =& DecimalRamp ) T Identity (size_t i) EnsembleValueFunc CreateTsGen (const ptime & start, size_t tsLength, size_t fcastIndex, const TimeStep & timeStep =TimeStep::GetHourly(), FullElementValueFunc ffun =& DecimalRamp ) TsEnsembleValueFunc CreateMtsGen (size_t ensSize, size_t tsLength, const ptime & start =ptime(date(2000, 1, 1)), const TimeStep & timeStep =TimeStep::GetDaily(), const TimeStep & timeStepFcasts =TimeStep::GetHourly(), FullElementValueFunc ffun =& DecimalRamp , int forecastStartOffset =1) EnsembleValueFunc DefaultTsGen () EnsemblePtrType CreateEnsembleTs (size_t ensSize, size_t length, const ptime & start, const TimeStep & timeStep, size_t fcastIndex =0, FullElementValueFunc ffun =& DecimalRamp ) EnsemblePtrType CreateEnsembleTs (size_t ensSize, size_t length, const ptime & start =ptime(date(2000, 1, 1)), const TimeStep & timeStep =TimeStep::GetDaily(), EnsembleValueFunc tsGen = DefaultTsGen ()) TsEnsembleValueFunc DefaultMtsGen () TSeriesEnsemblePtrType CreateTsEnsembleTs (size_t length, const ptime & start =ptime(date(2000, 1, 1)), const TimeStep & timeStep =TimeStep::GetDaily(), TsEnsembleValueFunc mtsGen = DefaultMtsGen ()) TSeriesEnsemblePtrType CreateTsEnsembleTs (size_t length, size_t ensSize, size_t tsLength, const ptime & start =ptime(date(2000, 1, 1)), const TimeStep & timeStep =TimeStep::GetDaily(), const TimeStep & timeStepFcasts =TimeStep::GetHourly(), FullElementValueFunc ffun =& DecimalRamp , int forecastStartOffset =1) Public Attributes \u00b6 Name const size_t kTimeSeriesLength Detailed Description \u00b6 template < typename T > class datatypes :: tests :: DataTestHelper ; Public Types Documentation \u00b6 using SeriesType \u00b6 using datatypes :: tests :: DataTestHelper < T >:: SeriesType = typename CommonTypes < T >:: SeriesType ; using PtrSeriesType \u00b6 using datatypes :: tests :: DataTestHelper < T >:: PtrSeriesType = typename CommonTypes < T >:: PtrSeriesType ; using EnsembleType \u00b6 using datatypes :: tests :: DataTestHelper < T >:: EnsembleType = typename CommonTypes < T >:: EnsembleType ; using EnsemblePtrType \u00b6 using datatypes :: tests :: DataTestHelper < T >:: EnsemblePtrType = typename CommonTypes < T >:: EnsemblePtrType ; using PtrEnsemblePtrType \u00b6 using datatypes :: tests :: DataTestHelper < T >:: PtrEnsemblePtrType = typename CommonTypes < T >:: PtrEnsemblePtrType ; using TSeriesEnsemblePtrType \u00b6 using datatypes :: tests :: DataTestHelper < T >:: TSeriesEnsemblePtrType = typename CommonTypes < T >:: TSeriesEnsemblePtrType ; using PtrTSeriesEnsemblePtrType \u00b6 using datatypes :: tests :: DataTestHelper < T >:: PtrTSeriesEnsemblePtrType = typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType ; typedef FullElementValueFunc \u00b6 typedef std :: function < T ( size_t , size_t , size_t ) > datatypes :: tests :: DataTestHelper < T >:: FullElementValueFunc ; typedef ElementValueFunc \u00b6 typedef std :: function < T ( size_t ) > datatypes :: tests :: DataTestHelper < T >:: ElementValueFunc ; typedef EnsembleValueFunc \u00b6 typedef std :: function < SeriesType ( size_t ) > datatypes :: tests :: DataTestHelper < T >:: EnsembleValueFunc ; typedef TsEnsembleValueFunc \u00b6 typedef std :: function < EnsemblePtrType ( size_t ) > datatypes :: tests :: DataTestHelper < T >:: TsEnsembleValueFunc ; Public Functions Documentation \u00b6 function Create \u00b6 static TTimeSeries < T > Create ( T * data , int num , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetHourly () ) function Ramp \u00b6 static TTimeSeries < T > Ramp ( int num , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), double from = 0.0 , double increment = 1.0 ) function Pulse \u00b6 static TTimeSeries < T > Pulse ( int length , T value = 1 , int firstPulse = 0 , int period = 2 , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetHourly () ) function GetExpectedTestSingleTimeSeries \u00b6 static TTimeSeries < T > GetExpectedTestSingleTimeSeries ( size_t indexInEnsemble , size_t length = kTimeSeriesLength , double constOffset = 1 , const ptime & startDate = TEST_START_TIME , const TimeStep & timeStep = TimeStep :: GetHourly () ) function Seq \u00b6 static T * Seq ( T from , T by , size_t num ) function SeqVec \u00b6 static vector < T > SeqVec ( T from , T by , size_t num ) function Rep \u00b6 static vector < T > Rep ( T value , size_t num ) function Add \u00b6 static vector < T > Add ( const vector < T > & a , const vector < T > & b ) function Add \u00b6 static vector < T > Add ( const vector < T > & a , const T & b ) function Add \u00b6 static vector < T > Add ( const T & a , const vector < T > & b ) function Mult \u00b6 static vector < T > Mult ( const vector < T > & a , const vector < T > & b ) function Mult \u00b6 static vector < T > Mult ( const vector < T > & a , const T & b ) function Mult \u00b6 static vector < T > Mult ( const T & a , const vector < T > & b ) function Neg \u00b6 static vector < T > Neg ( const vector < T > & a ) function Seq \u00b6 static vector < T * > * Seq ( T from , T by , size_t num , size_t vecSize ) function DeleteElements \u00b6 static void DeleteElements ( vector < T * > & vec ) function AreEqual \u00b6 static bool AreEqual ( PtrSeriesType expected , PtrSeriesType actual ) function AreEqual \u00b6 static bool AreEqual ( PtrSeriesType actual , T expected ) function DecimalRamp \u00b6 static inline T DecimalRamp ( size_t fcastIndex , size_t ensIndex , size_t seriesIndex ) function CreateValueGen \u00b6 static inline ElementValueFunc CreateValueGen ( size_t fcastIndex , size_t ensIndex , FullElementValueFunc ffun =& DecimalRamp ) function Identity \u00b6 static inline T Identity ( size_t i ) function CreateTsGen \u00b6 static inline EnsembleValueFunc CreateTsGen ( const ptime & start , size_t tsLength , size_t fcastIndex , const TimeStep & timeStep = TimeStep :: GetHourly (), FullElementValueFunc ffun =& DecimalRamp ) function CreateMtsGen \u00b6 static inline TsEnsembleValueFunc CreateMtsGen ( size_t ensSize , size_t tsLength , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetDaily (), const TimeStep & timeStepFcasts = TimeStep :: GetHourly (), FullElementValueFunc ffun =& DecimalRamp , int forecastStartOffset = 1 ) function DefaultTsGen \u00b6 static inline EnsembleValueFunc DefaultTsGen () function CreateEnsembleTs \u00b6 static inline EnsemblePtrType CreateEnsembleTs ( size_t ensSize , size_t length , const ptime & start , const TimeStep & timeStep , size_t fcastIndex = 0 , FullElementValueFunc ffun =& DecimalRamp ) function CreateEnsembleTs \u00b6 static inline EnsemblePtrType CreateEnsembleTs ( size_t ensSize , size_t length , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetDaily (), EnsembleValueFunc tsGen = DefaultTsGen () ) function DefaultMtsGen \u00b6 static inline TsEnsembleValueFunc DefaultMtsGen () function CreateTsEnsembleTs \u00b6 static inline TSeriesEnsemblePtrType CreateTsEnsembleTs ( size_t length , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetDaily (), TsEnsembleValueFunc mtsGen = DefaultMtsGen () ) function CreateTsEnsembleTs \u00b6 static inline TSeriesEnsemblePtrType CreateTsEnsembleTs ( size_t length , size_t ensSize , size_t tsLength , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetDaily (), const TimeStep & timeStepFcasts = TimeStep :: GetHourly (), FullElementValueFunc ffun =& DecimalRamp , int forecastStartOffset = 1 ) Public Attributes Documentation \u00b6 variable kTimeSeriesLength \u00b6 static const size_t kTimeSeriesLength = 48 ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::tests::DataTestHelper"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#datatypestestsdatatesthelper","text":"More... #include <datatypes_test_helpers.hpp>","title":"datatypes::tests::DataTestHelper"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#public-types","text":"Name using typename CommonTypes < T >:: SeriesType SeriesType using typename CommonTypes < T >:: PtrSeriesType PtrSeriesType using typename CommonTypes < T >:: EnsembleType EnsembleType using typename CommonTypes < T >:: EnsemblePtrType EnsemblePtrType using typename CommonTypes < T >:: PtrEnsemblePtrType PtrEnsemblePtrType using typename CommonTypes < T >:: TSeriesEnsemblePtrType TSeriesEnsemblePtrType using typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType PtrTSeriesEnsemblePtrType typedef std::function< T(size_t, size_t, size_t)> FullElementValueFunc typedef std::function< T(size_t)> ElementValueFunc typedef std::function< SeriesType (size_t)> EnsembleValueFunc typedef std::function< EnsemblePtrType (size_t)> TsEnsembleValueFunc","title":"Public Types"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#public-functions","text":"Name TTimeSeries < T > Create (T * data, int num, const ptime & start =ptime(date(2000, 1, 1)), const TimeStep & timeStep =TimeStep::GetHourly()) TTimeSeries < T > Ramp (int num, const ptime & start =ptime(date(2000, 1, 1)), double from =0.0, double increment =1.0) TTimeSeries < T > Pulse (int length, T value =1, int firstPulse =0, int period =2, const ptime & start =ptime(date(2000, 1, 1)), const TimeStep & timeStep =TimeStep::GetHourly()) TTimeSeries < T > GetExpectedTestSingleTimeSeries (size_t indexInEnsemble, size_t length = kTimeSeriesLength , double constOffset =1, const ptime & startDate = TEST_START_TIME , const TimeStep & timeStep =TimeStep::GetHourly()) T * Seq (T from, T by, size_t num) vector< T > SeqVec (T from, T by, size_t num) vector< T > Rep (T value, size_t num) vector< T > Add (const vector< T > & a, const vector< T > & b) vector< T > Add (const vector< T > & a, const T & b) vector< T > Add (const T & a, const vector< T > & b) vector< T > Mult (const vector< T > & a, const vector< T > & b) vector< T > Mult (const vector< T > & a, const T & b) vector< T > Mult (const T & a, const vector< T > & b) vector< T > Neg (const vector< T > & a) vector< T * > * Seq (T from, T by, size_t num, size_t vecSize) void DeleteElements (vector< T * > & vec) bool AreEqual ( PtrSeriesType expected, PtrSeriesType actual) bool AreEqual ( PtrSeriesType actual, T expected) T DecimalRamp (size_t fcastIndex, size_t ensIndex, size_t seriesIndex) ElementValueFunc CreateValueGen (size_t fcastIndex, size_t ensIndex, FullElementValueFunc ffun =& DecimalRamp ) T Identity (size_t i) EnsembleValueFunc CreateTsGen (const ptime & start, size_t tsLength, size_t fcastIndex, const TimeStep & timeStep =TimeStep::GetHourly(), FullElementValueFunc ffun =& DecimalRamp ) TsEnsembleValueFunc CreateMtsGen (size_t ensSize, size_t tsLength, const ptime & start =ptime(date(2000, 1, 1)), const TimeStep & timeStep =TimeStep::GetDaily(), const TimeStep & timeStepFcasts =TimeStep::GetHourly(), FullElementValueFunc ffun =& DecimalRamp , int forecastStartOffset =1) EnsembleValueFunc DefaultTsGen () EnsemblePtrType CreateEnsembleTs (size_t ensSize, size_t length, const ptime & start, const TimeStep & timeStep, size_t fcastIndex =0, FullElementValueFunc ffun =& DecimalRamp ) EnsemblePtrType CreateEnsembleTs (size_t ensSize, size_t length, const ptime & start =ptime(date(2000, 1, 1)), const TimeStep & timeStep =TimeStep::GetDaily(), EnsembleValueFunc tsGen = DefaultTsGen ()) TsEnsembleValueFunc DefaultMtsGen () TSeriesEnsemblePtrType CreateTsEnsembleTs (size_t length, const ptime & start =ptime(date(2000, 1, 1)), const TimeStep & timeStep =TimeStep::GetDaily(), TsEnsembleValueFunc mtsGen = DefaultMtsGen ()) TSeriesEnsemblePtrType CreateTsEnsembleTs (size_t length, size_t ensSize, size_t tsLength, const ptime & start =ptime(date(2000, 1, 1)), const TimeStep & timeStep =TimeStep::GetDaily(), const TimeStep & timeStepFcasts =TimeStep::GetHourly(), FullElementValueFunc ffun =& DecimalRamp , int forecastStartOffset =1)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#public-attributes","text":"Name const size_t kTimeSeriesLength","title":"Public Attributes"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#detailed-description","text":"template < typename T > class datatypes :: tests :: DataTestHelper ;","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#using-seriestype","text":"using datatypes :: tests :: DataTestHelper < T >:: SeriesType = typename CommonTypes < T >:: SeriesType ;","title":"using SeriesType"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#using-ptrseriestype","text":"using datatypes :: tests :: DataTestHelper < T >:: PtrSeriesType = typename CommonTypes < T >:: PtrSeriesType ;","title":"using PtrSeriesType"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#using-ensembletype","text":"using datatypes :: tests :: DataTestHelper < T >:: EnsembleType = typename CommonTypes < T >:: EnsembleType ;","title":"using EnsembleType"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#using-ensembleptrtype","text":"using datatypes :: tests :: DataTestHelper < T >:: EnsemblePtrType = typename CommonTypes < T >:: EnsemblePtrType ;","title":"using EnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#using-ptrensembleptrtype","text":"using datatypes :: tests :: DataTestHelper < T >:: PtrEnsemblePtrType = typename CommonTypes < T >:: PtrEnsemblePtrType ;","title":"using PtrEnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#using-tseriesensembleptrtype","text":"using datatypes :: tests :: DataTestHelper < T >:: TSeriesEnsemblePtrType = typename CommonTypes < T >:: TSeriesEnsemblePtrType ;","title":"using TSeriesEnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#using-ptrtseriesensembleptrtype","text":"using datatypes :: tests :: DataTestHelper < T >:: PtrTSeriesEnsemblePtrType = typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType ;","title":"using PtrTSeriesEnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#typedef-fullelementvaluefunc","text":"typedef std :: function < T ( size_t , size_t , size_t ) > datatypes :: tests :: DataTestHelper < T >:: FullElementValueFunc ;","title":"typedef FullElementValueFunc"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#typedef-elementvaluefunc","text":"typedef std :: function < T ( size_t ) > datatypes :: tests :: DataTestHelper < T >:: ElementValueFunc ;","title":"typedef ElementValueFunc"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#typedef-ensemblevaluefunc","text":"typedef std :: function < SeriesType ( size_t ) > datatypes :: tests :: DataTestHelper < T >:: EnsembleValueFunc ;","title":"typedef EnsembleValueFunc"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#typedef-tsensemblevaluefunc","text":"typedef std :: function < EnsemblePtrType ( size_t ) > datatypes :: tests :: DataTestHelper < T >:: TsEnsembleValueFunc ;","title":"typedef TsEnsembleValueFunc"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-create","text":"static TTimeSeries < T > Create ( T * data , int num , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetHourly () )","title":"function Create"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-ramp","text":"static TTimeSeries < T > Ramp ( int num , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), double from = 0.0 , double increment = 1.0 )","title":"function Ramp"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-pulse","text":"static TTimeSeries < T > Pulse ( int length , T value = 1 , int firstPulse = 0 , int period = 2 , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetHourly () )","title":"function Pulse"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-getexpectedtestsingletimeseries","text":"static TTimeSeries < T > GetExpectedTestSingleTimeSeries ( size_t indexInEnsemble , size_t length = kTimeSeriesLength , double constOffset = 1 , const ptime & startDate = TEST_START_TIME , const TimeStep & timeStep = TimeStep :: GetHourly () )","title":"function GetExpectedTestSingleTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-seq","text":"static T * Seq ( T from , T by , size_t num )","title":"function Seq"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-seqvec","text":"static vector < T > SeqVec ( T from , T by , size_t num )","title":"function SeqVec"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-rep","text":"static vector < T > Rep ( T value , size_t num )","title":"function Rep"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-add","text":"static vector < T > Add ( const vector < T > & a , const vector < T > & b )","title":"function Add"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-add_1","text":"static vector < T > Add ( const vector < T > & a , const T & b )","title":"function Add"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-add_2","text":"static vector < T > Add ( const T & a , const vector < T > & b )","title":"function Add"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-mult","text":"static vector < T > Mult ( const vector < T > & a , const vector < T > & b )","title":"function Mult"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-mult_1","text":"static vector < T > Mult ( const vector < T > & a , const T & b )","title":"function Mult"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-mult_2","text":"static vector < T > Mult ( const T & a , const vector < T > & b )","title":"function Mult"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-neg","text":"static vector < T > Neg ( const vector < T > & a )","title":"function Neg"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-seq_1","text":"static vector < T * > * Seq ( T from , T by , size_t num , size_t vecSize )","title":"function Seq"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-deleteelements","text":"static void DeleteElements ( vector < T * > & vec )","title":"function DeleteElements"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-areequal","text":"static bool AreEqual ( PtrSeriesType expected , PtrSeriesType actual )","title":"function AreEqual"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-areequal_1","text":"static bool AreEqual ( PtrSeriesType actual , T expected )","title":"function AreEqual"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-decimalramp","text":"static inline T DecimalRamp ( size_t fcastIndex , size_t ensIndex , size_t seriesIndex )","title":"function DecimalRamp"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-createvaluegen","text":"static inline ElementValueFunc CreateValueGen ( size_t fcastIndex , size_t ensIndex , FullElementValueFunc ffun =& DecimalRamp )","title":"function CreateValueGen"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-identity","text":"static inline T Identity ( size_t i )","title":"function Identity"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-createtsgen","text":"static inline EnsembleValueFunc CreateTsGen ( const ptime & start , size_t tsLength , size_t fcastIndex , const TimeStep & timeStep = TimeStep :: GetHourly (), FullElementValueFunc ffun =& DecimalRamp )","title":"function CreateTsGen"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-createmtsgen","text":"static inline TsEnsembleValueFunc CreateMtsGen ( size_t ensSize , size_t tsLength , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetDaily (), const TimeStep & timeStepFcasts = TimeStep :: GetHourly (), FullElementValueFunc ffun =& DecimalRamp , int forecastStartOffset = 1 )","title":"function CreateMtsGen"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-defaulttsgen","text":"static inline EnsembleValueFunc DefaultTsGen ()","title":"function DefaultTsGen"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-createensemblets","text":"static inline EnsemblePtrType CreateEnsembleTs ( size_t ensSize , size_t length , const ptime & start , const TimeStep & timeStep , size_t fcastIndex = 0 , FullElementValueFunc ffun =& DecimalRamp )","title":"function CreateEnsembleTs"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-createensemblets_1","text":"static inline EnsemblePtrType CreateEnsembleTs ( size_t ensSize , size_t length , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetDaily (), EnsembleValueFunc tsGen = DefaultTsGen () )","title":"function CreateEnsembleTs"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-defaultmtsgen","text":"static inline TsEnsembleValueFunc DefaultMtsGen ()","title":"function DefaultMtsGen"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-createtsensemblets","text":"static inline TSeriesEnsemblePtrType CreateTsEnsembleTs ( size_t length , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetDaily (), TsEnsembleValueFunc mtsGen = DefaultMtsGen () )","title":"function CreateTsEnsembleTs"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#function-createtsensemblets_1","text":"static inline TSeriesEnsemblePtrType CreateTsEnsembleTs ( size_t length , size_t ensSize , size_t tsLength , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetDaily (), const TimeStep & timeStepFcasts = TimeStep :: GetHourly (), FullElementValueFunc ffun =& DecimalRamp , int forecastStartOffset = 1 )","title":"function CreateTsEnsembleTs"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1DataTestHelper/#variable-ktimeserieslength","text":"static const size_t kTimeSeriesLength = 48 ; Updated on 2022-08-20 at 19:28:22 +1000","title":"variable kTimeSeriesLength"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1FileSystemHelper/","text":"datatypes::tests::FileSystemHelper \u00b6 #include <datatypes_test_helpers.h> Public Functions \u00b6 Name boost::filesystem::path GetTempFile (const string & format =\"%%%%%%%%%%%%.tmp\") boost::filesystem::path GetTempDir (const string & format =\"%%%%%%%%%%%%\") void Remove (const boost::filesystem::path & p) void Remove (const string & p) bool Exists (const string & p) bool Exists (const boost::filesystem::path & p) Public Functions Documentation \u00b6 function GetTempFile \u00b6 static boost :: filesystem :: path GetTempFile ( const string & format = \"%%%%%%%%%%%%.tmp\" ) function GetTempDir \u00b6 static boost :: filesystem :: path GetTempDir ( const string & format = \"%%%%%%%%%%%%\" ) function Remove \u00b6 static void Remove ( const boost :: filesystem :: path & p ) function Remove \u00b6 static void Remove ( const string & p ) function Exists \u00b6 static bool Exists ( const string & p ) function Exists \u00b6 static bool Exists ( const boost :: filesystem :: path & p ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::tests::FileSystemHelper"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1FileSystemHelper/#datatypestestsfilesystemhelper","text":"#include <datatypes_test_helpers.h>","title":"datatypes::tests::FileSystemHelper"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1FileSystemHelper/#public-functions","text":"Name boost::filesystem::path GetTempFile (const string & format =\"%%%%%%%%%%%%.tmp\") boost::filesystem::path GetTempDir (const string & format =\"%%%%%%%%%%%%\") void Remove (const boost::filesystem::path & p) void Remove (const string & p) bool Exists (const string & p) bool Exists (const boost::filesystem::path & p)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1FileSystemHelper/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1FileSystemHelper/#function-gettempfile","text":"static boost :: filesystem :: path GetTempFile ( const string & format = \"%%%%%%%%%%%%.tmp\" )","title":"function GetTempFile"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1FileSystemHelper/#function-gettempdir","text":"static boost :: filesystem :: path GetTempDir ( const string & format = \"%%%%%%%%%%%%\" )","title":"function GetTempDir"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1FileSystemHelper/#function-remove","text":"static void Remove ( const boost :: filesystem :: path & p )","title":"function Remove"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1FileSystemHelper/#function-remove_1","text":"static void Remove ( const string & p )","title":"function Remove"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1FileSystemHelper/#function-exists","text":"static bool Exists ( const string & p )","title":"function Exists"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1FileSystemHelper/#function-exists_1","text":"static bool Exists ( const boost :: filesystem :: path & p ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function Exists"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TempFileCleaner/","text":"datatypes::tests::TempFileCleaner \u00b6 #include <datatypes_test_helpers.h> Public Functions \u00b6 Name TempFileCleaner (const string uri) ~TempFileCleaner () Public Attributes \u00b6 Name string uri Public Functions Documentation \u00b6 function TempFileCleaner \u00b6 TempFileCleaner ( const string uri ) function ~TempFileCleaner \u00b6 ~ TempFileCleaner () Public Attributes Documentation \u00b6 variable uri \u00b6 string uri ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::tests::TempFileCleaner"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TempFileCleaner/#datatypesteststempfilecleaner","text":"#include <datatypes_test_helpers.h>","title":"datatypes::tests::TempFileCleaner"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TempFileCleaner/#public-functions","text":"Name TempFileCleaner (const string uri) ~TempFileCleaner ()","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TempFileCleaner/#public-attributes","text":"Name string uri","title":"Public Attributes"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TempFileCleaner/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TempFileCleaner/#function-tempfilecleaner","text":"TempFileCleaner ( const string uri )","title":"function TempFileCleaner"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TempFileCleaner/#function-tempfilecleaner_1","text":"~ TempFileCleaner ()","title":"function ~TempFileCleaner"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TempFileCleaner/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TempFileCleaner/#variable-uri","text":"string uri ; Updated on 2022-08-20 at 19:28:22 +1000","title":"variable uri"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/","text":"datatypes::tests::TestDataLocationHelper \u00b6 #include <datatypes_test_helpers.h> Public Functions \u00b6 Name string ReadEnvironmentVariable (const string & envVar) string BuildPath (const vector< string > & folders) TimeSeriesLibrary CreateEnsembleTimeSeriesLibrary (string & rainObsId, string & petObsId, string & rainFcastId, string & petFcastId) TimeSeriesLibrary GetTestTimeSeriesLibrary () vector< string > TestTsLibraryIdentifiers () TimeSeriesLibrary * CreateTestTimeSeriesLibrary () void MakeTestTimeSeriesLibrary ( TimeSeriesLibrary & dataLibrary) vector< string > TestStationIds () Public Attributes \u00b6 Name const string kVarSingleStation const string kVarMultiStations const string kFileSingleStation const string kFileMultiStations const string kFileAllDataCases const string kVar1FcastEns const string kVar2FcastEns const string kVar1Obs const string kVar2Obs const string kVar1Ens const string kVar2Ens const string kIdentifier1FcastEns const string kIdentifier2FcastEns const string kIdentifier1Obs const string kIdentifier2Obs const string kIdentifier1Ens const string kIdentifier2Ens const string kSingleStationId const string kStationIdOne const string kStationIdTwo const size_t kTimeSeriesLength Public Functions Documentation \u00b6 function ReadEnvironmentVariable \u00b6 static string ReadEnvironmentVariable ( const string & envVar ) function BuildPath \u00b6 static string BuildPath ( const vector < string > & folders ) function CreateEnsembleTimeSeriesLibrary \u00b6 static TimeSeriesLibrary CreateEnsembleTimeSeriesLibrary ( string & rainObsId , string & petObsId , string & rainFcastId , string & petFcastId ) function GetTestTimeSeriesLibrary \u00b6 static TimeSeriesLibrary GetTestTimeSeriesLibrary () function TestTsLibraryIdentifiers \u00b6 static vector < string > TestTsLibraryIdentifiers () function CreateTestTimeSeriesLibrary \u00b6 static TimeSeriesLibrary * CreateTestTimeSeriesLibrary () function MakeTestTimeSeriesLibrary \u00b6 static void MakeTestTimeSeriesLibrary ( TimeSeriesLibrary & dataLibrary ) function TestStationIds \u00b6 static vector < string > TestStationIds () Public Attributes Documentation \u00b6 variable kVarSingleStation \u00b6 static const string kVarSingleStation ; variable kVarMultiStations \u00b6 static const string kVarMultiStations ; variable kFileSingleStation \u00b6 static const string kFileSingleStation ; variable kFileMultiStations \u00b6 static const string kFileMultiStations ; variable kFileAllDataCases \u00b6 static const string kFileAllDataCases ; variable kVar1FcastEns \u00b6 static const string kVar1FcastEns ; variable kVar2FcastEns \u00b6 static const string kVar2FcastEns ; variable kVar1Obs \u00b6 static const string kVar1Obs ; variable kVar2Obs \u00b6 static const string kVar2Obs ; variable kVar1Ens \u00b6 static const string kVar1Ens ; variable kVar2Ens \u00b6 static const string kVar2Ens ; variable kIdentifier1FcastEns \u00b6 static const string kIdentifier1FcastEns ; variable kIdentifier2FcastEns \u00b6 static const string kIdentifier2FcastEns ; variable kIdentifier1Obs \u00b6 static const string kIdentifier1Obs ; variable kIdentifier2Obs \u00b6 static const string kIdentifier2Obs ; variable kIdentifier1Ens \u00b6 static const string kIdentifier1Ens ; variable kIdentifier2Ens \u00b6 static const string kIdentifier2Ens ; variable kSingleStationId \u00b6 static const string kSingleStationId ; variable kStationIdOne \u00b6 static const string kStationIdOne ; variable kStationIdTwo \u00b6 static const string kStationIdTwo ; variable kTimeSeriesLength \u00b6 static const size_t kTimeSeriesLength ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::tests::TestDataLocationHelper"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#datatypesteststestdatalocationhelper","text":"#include <datatypes_test_helpers.h>","title":"datatypes::tests::TestDataLocationHelper"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#public-functions","text":"Name string ReadEnvironmentVariable (const string & envVar) string BuildPath (const vector< string > & folders) TimeSeriesLibrary CreateEnsembleTimeSeriesLibrary (string & rainObsId, string & petObsId, string & rainFcastId, string & petFcastId) TimeSeriesLibrary GetTestTimeSeriesLibrary () vector< string > TestTsLibraryIdentifiers () TimeSeriesLibrary * CreateTestTimeSeriesLibrary () void MakeTestTimeSeriesLibrary ( TimeSeriesLibrary & dataLibrary) vector< string > TestStationIds ()","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#public-attributes","text":"Name const string kVarSingleStation const string kVarMultiStations const string kFileSingleStation const string kFileMultiStations const string kFileAllDataCases const string kVar1FcastEns const string kVar2FcastEns const string kVar1Obs const string kVar2Obs const string kVar1Ens const string kVar2Ens const string kIdentifier1FcastEns const string kIdentifier2FcastEns const string kIdentifier1Obs const string kIdentifier2Obs const string kIdentifier1Ens const string kIdentifier2Ens const string kSingleStationId const string kStationIdOne const string kStationIdTwo const size_t kTimeSeriesLength","title":"Public Attributes"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#function-readenvironmentvariable","text":"static string ReadEnvironmentVariable ( const string & envVar )","title":"function ReadEnvironmentVariable"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#function-buildpath","text":"static string BuildPath ( const vector < string > & folders )","title":"function BuildPath"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#function-createensembletimeserieslibrary","text":"static TimeSeriesLibrary CreateEnsembleTimeSeriesLibrary ( string & rainObsId , string & petObsId , string & rainFcastId , string & petFcastId )","title":"function CreateEnsembleTimeSeriesLibrary"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#function-gettesttimeserieslibrary","text":"static TimeSeriesLibrary GetTestTimeSeriesLibrary ()","title":"function GetTestTimeSeriesLibrary"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#function-testtslibraryidentifiers","text":"static vector < string > TestTsLibraryIdentifiers ()","title":"function TestTsLibraryIdentifiers"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#function-createtesttimeserieslibrary","text":"static TimeSeriesLibrary * CreateTestTimeSeriesLibrary ()","title":"function CreateTestTimeSeriesLibrary"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#function-maketesttimeserieslibrary","text":"static void MakeTestTimeSeriesLibrary ( TimeSeriesLibrary & dataLibrary )","title":"function MakeTestTimeSeriesLibrary"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#function-teststationids","text":"static vector < string > TestStationIds ()","title":"function TestStationIds"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#variable-kvarsinglestation","text":"static const string kVarSingleStation ;","title":"variable kVarSingleStation"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#variable-kvarmultistations","text":"static const string kVarMultiStations ;","title":"variable kVarMultiStations"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#variable-kfilesinglestation","text":"static const string kFileSingleStation ;","title":"variable kFileSingleStation"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#variable-kfilemultistations","text":"static const string kFileMultiStations ;","title":"variable kFileMultiStations"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#variable-kfilealldatacases","text":"static const string kFileAllDataCases ;","title":"variable kFileAllDataCases"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#variable-kvar1fcastens","text":"static const string kVar1FcastEns ;","title":"variable kVar1FcastEns"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#variable-kvar2fcastens","text":"static const string kVar2FcastEns ;","title":"variable kVar2FcastEns"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#variable-kvar1obs","text":"static const string kVar1Obs ;","title":"variable kVar1Obs"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#variable-kvar2obs","text":"static const string kVar2Obs ;","title":"variable kVar2Obs"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#variable-kvar1ens","text":"static const string kVar1Ens ;","title":"variable kVar1Ens"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#variable-kvar2ens","text":"static const string kVar2Ens ;","title":"variable kVar2Ens"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#variable-kidentifier1fcastens","text":"static const string kIdentifier1FcastEns ;","title":"variable kIdentifier1FcastEns"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#variable-kidentifier2fcastens","text":"static const string kIdentifier2FcastEns ;","title":"variable kIdentifier2FcastEns"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#variable-kidentifier1obs","text":"static const string kIdentifier1Obs ;","title":"variable kIdentifier1Obs"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#variable-kidentifier2obs","text":"static const string kIdentifier2Obs ;","title":"variable kIdentifier2Obs"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#variable-kidentifier1ens","text":"static const string kIdentifier1Ens ;","title":"variable kIdentifier1Ens"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#variable-kidentifier2ens","text":"static const string kIdentifier2Ens ;","title":"variable kIdentifier2Ens"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#variable-ksinglestationid","text":"static const string kSingleStationId ;","title":"variable kSingleStationId"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#variable-kstationidone","text":"static const string kStationIdOne ;","title":"variable kStationIdOne"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#variable-kstationidtwo","text":"static const string kStationIdTwo ;","title":"variable kStationIdTwo"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestDataLocationHelper/#variable-ktimeserieslength","text":"static const size_t kTimeSeriesLength ; Updated on 2022-08-20 at 19:28:22 +1000","title":"variable kTimeSeriesLength"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestEnsembleTimeSeriesStore/","text":"datatypes::tests::TestEnsembleTimeSeriesStore \u00b6 #include <datatypes_test_helpers.h> Inherits from datatypes::timeseries::EnsembleTimeSeriesStore< double > , datatypes::timeseries::IdentifiersProvider , datatypes::timeseries::DataDescriptor Public Functions \u00b6 Name TestEnsembleTimeSeriesStore (const MultiTimeSeries <> & data) virtual MultiTimeSeries < TTimeSeries < double > * > * Read () virtual string GetDataSummary () const virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::EnsembleTimeSeriesStore< double > Name virtual ~EnsembleTimeSeriesStore () virtual vector< string > GetIdentifiers () const Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () virtual vector< string > GetIdentifiers () const =0 vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId) Public Functions Documentation \u00b6 function TestEnsembleTimeSeriesStore \u00b6 TestEnsembleTimeSeriesStore ( const MultiTimeSeries <> & data ) function Read \u00b6 virtual MultiTimeSeries < TTimeSeries < double > * > * Read () Reimplements : datatypes::timeseries::EnsembleTimeSeriesStore::Read function GetDataSummary \u00b6 virtual string GetDataSummary () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataSummary function GetDataDimensionsDescription \u00b6 virtual vector < DataDimensionDescriptor > GetDataDimensionsDescription () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataDimensionsDescription Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::tests::TestEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestEnsembleTimeSeriesStore/#datatypesteststestensembletimeseriesstore","text":"#include <datatypes_test_helpers.h> Inherits from datatypes::timeseries::EnsembleTimeSeriesStore< double > , datatypes::timeseries::IdentifiersProvider , datatypes::timeseries::DataDescriptor","title":"datatypes::tests::TestEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestEnsembleTimeSeriesStore/#public-functions","text":"Name TestEnsembleTimeSeriesStore (const MultiTimeSeries <> & data) virtual MultiTimeSeries < TTimeSeries < double > * > * Read () virtual string GetDataSummary () const virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestEnsembleTimeSeriesStore/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::EnsembleTimeSeriesStore< double > Name virtual ~EnsembleTimeSeriesStore () virtual vector< string > GetIdentifiers () const Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () virtual vector< string > GetIdentifiers () const =0 vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId)","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestEnsembleTimeSeriesStore/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestEnsembleTimeSeriesStore/#function-testensembletimeseriesstore","text":"TestEnsembleTimeSeriesStore ( const MultiTimeSeries <> & data )","title":"function TestEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestEnsembleTimeSeriesStore/#function-read","text":"virtual MultiTimeSeries < TTimeSeries < double > * > * Read () Reimplements : datatypes::timeseries::EnsembleTimeSeriesStore::Read","title":"function Read"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestEnsembleTimeSeriesStore/#function-getdatasummary","text":"virtual string GetDataSummary () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataSummary","title":"function GetDataSummary"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestEnsembleTimeSeriesStore/#function-getdatadimensionsdescription","text":"virtual vector < DataDimensionDescriptor > GetDataDimensionsDescription () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataDimensionsDescription Updated on 2022-08-20 at 19:28:22 +1000","title":"function GetDataDimensionsDescription"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestSingleTimeSeriesStore/","text":"datatypes::tests::TestSingleTimeSeriesStore \u00b6 #include <datatypes_test_helpers.h> Inherits from datatypes::timeseries::SingleTimeSeriesStore< double > , datatypes::timeseries::IdentifiersProvider , datatypes::timeseries::DataDescriptor Public Functions \u00b6 Name TestSingleTimeSeriesStore (const vector< double > & values, const ptime & startDate, const TimeStep & timeStep =TimeStep::GetHourly()) TestSingleTimeSeriesStore (const TimeSeries & series) virtual string GetDataSummary () const virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const virtual TTimeSeries < double > * Read () virtual TTimeSeries < double > * Read (const string & blah) virtual MultiTimeSeries < TTimeSeries < double > * > * ReadAllCollection () virtual std::vector< std::string > GetIdentifiers () const Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::SingleTimeSeriesStore< double > Name virtual ~SingleTimeSeriesStore () Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId) Public Functions Documentation \u00b6 function TestSingleTimeSeriesStore \u00b6 TestSingleTimeSeriesStore ( const vector < double > & values , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly () ) function TestSingleTimeSeriesStore \u00b6 TestSingleTimeSeriesStore ( const TimeSeries & series ) function GetDataSummary \u00b6 virtual string GetDataSummary () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataSummary function GetDataDimensionsDescription \u00b6 virtual vector < DataDimensionDescriptor > GetDataDimensionsDescription () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataDimensionsDescription function Read \u00b6 virtual TTimeSeries < double > * Read () Reimplements : datatypes::timeseries::SingleTimeSeriesStore::Read function Read \u00b6 virtual TTimeSeries < double > * Read ( const string & blah ) Reimplements : datatypes::timeseries::SingleTimeSeriesStore::Read function ReadAllCollection \u00b6 virtual MultiTimeSeries < TTimeSeries < double > * > * ReadAllCollection () Reimplements : datatypes::timeseries::SingleTimeSeriesStore::ReadAllCollection function GetIdentifiers \u00b6 virtual std :: vector < std :: string > GetIdentifiers () const Reimplements : datatypes::timeseries::IdentifiersProvider::GetIdentifiers Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::tests::TestSingleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestSingleTimeSeriesStore/#datatypesteststestsingletimeseriesstore","text":"#include <datatypes_test_helpers.h> Inherits from datatypes::timeseries::SingleTimeSeriesStore< double > , datatypes::timeseries::IdentifiersProvider , datatypes::timeseries::DataDescriptor","title":"datatypes::tests::TestSingleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestSingleTimeSeriesStore/#public-functions","text":"Name TestSingleTimeSeriesStore (const vector< double > & values, const ptime & startDate, const TimeStep & timeStep =TimeStep::GetHourly()) TestSingleTimeSeriesStore (const TimeSeries & series) virtual string GetDataSummary () const virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const virtual TTimeSeries < double > * Read () virtual TTimeSeries < double > * Read (const string & blah) virtual MultiTimeSeries < TTimeSeries < double > * > * ReadAllCollection () virtual std::vector< std::string > GetIdentifiers () const","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestSingleTimeSeriesStore/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::SingleTimeSeriesStore< double > Name virtual ~SingleTimeSeriesStore () Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId)","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestSingleTimeSeriesStore/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestSingleTimeSeriesStore/#function-testsingletimeseriesstore","text":"TestSingleTimeSeriesStore ( const vector < double > & values , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly () )","title":"function TestSingleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestSingleTimeSeriesStore/#function-testsingletimeseriesstore_1","text":"TestSingleTimeSeriesStore ( const TimeSeries & series )","title":"function TestSingleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestSingleTimeSeriesStore/#function-getdatasummary","text":"virtual string GetDataSummary () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataSummary","title":"function GetDataSummary"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestSingleTimeSeriesStore/#function-getdatadimensionsdescription","text":"virtual vector < DataDimensionDescriptor > GetDataDimensionsDescription () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataDimensionsDescription","title":"function GetDataDimensionsDescription"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestSingleTimeSeriesStore/#function-read","text":"virtual TTimeSeries < double > * Read () Reimplements : datatypes::timeseries::SingleTimeSeriesStore::Read","title":"function Read"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestSingleTimeSeriesStore/#function-read_1","text":"virtual TTimeSeries < double > * Read ( const string & blah ) Reimplements : datatypes::timeseries::SingleTimeSeriesStore::Read","title":"function Read"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestSingleTimeSeriesStore/#function-readallcollection","text":"virtual MultiTimeSeries < TTimeSeries < double > * > * ReadAllCollection () Reimplements : datatypes::timeseries::SingleTimeSeriesStore::ReadAllCollection","title":"function ReadAllCollection"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestSingleTimeSeriesStore/#function-getidentifiers","text":"virtual std :: vector < std :: string > GetIdentifiers () const Reimplements : datatypes::timeseries::IdentifiersProvider::GetIdentifiers Updated on 2022-08-20 at 19:28:22 +1000","title":"function GetIdentifiers"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/","text":"datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore \u00b6 A time series store for unit tests. #include <datatypes_test_helpers.h> Inherits from datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore< double > , datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T > , datatypes::timeseries::IdentifiersProvider , datatypes::timeseries::TimeSeriesInfoProvider , datatypes::timeseries::DataDescriptor Public Types \u00b6 Name using double T using CommonTypes < T >:: SeriesType SeriesType using CommonTypes < T >:: PtrSeriesType PtrSeriesType using CommonTypes < T >:: EnsemblePtrType EnsemblePtrType using CommonTypes < T >:: PtrEnsemblePtrType PtrEnsemblePtrType using CommonTypes < T >:: TSeriesEnsemblePtrType TSeriesEnsemblePtrType using CommonTypes < T >:: PtrTSeriesEnsemblePtrType PtrTSeriesEnsemblePtrType Public Functions \u00b6 Name ~TestTimeSeriesEnsembleTimeSeriesStore () TestTimeSeriesEnsembleTimeSeriesStore (const string & id =\"\") TestTimeSeriesEnsembleTimeSeriesStore (const TSeriesEnsemblePtrType & ensFts, const string & id =\"\") virtual PtrTSeriesEnsemblePtrType GetSeries (const string & dataId) PtrTSeriesEnsemblePtrType GetSeriesTestBackend (const string & dataId) PtrEnsemblePtrType Read (const std::string & ensembleIdentifier) virtual size_t GetLength () const virtual ptime GetStart () const virtual string GetDataSummary () const virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const virtual TimeStep GetTimeStep () const virtual bool IsActive () virtual void Allocate (size_t length, PtrEnsemblePtrType value) virtual void AllocateValues (const vector< PtrEnsemblePtrType > & values) virtual void SetSeries (const string & dataId, PtrTSeriesEnsemblePtrType value) virtual void SetItem (const string & dataId, size_t index, PtrEnsemblePtrType value) virtual void SetItem (const string & dataId, size_t index, const EnsemblePtrType & value) virtual void SetLength (size_t ) virtual void SetStart (ptime ) virtual void SetTimeStep (const TimeStep & ) virtual PtrEnsemblePtrType GetItem (const string & dataId, size_t fcastIndex) override virtual PtrSeriesType GetItem (const string & dataId, size_t fcastIndex, size_t ensIndex) override virtual size_t GetEnsembleSize (const string & dataId, size_t fcastIndex) const override Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore< double > Name virtual ~WritableTimeSeriesEnsembleTimeSeriesStore () Public Functions inherited from datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T > Name virtual ~TimeSeriesEnsembleTimeSeriesStore () virtual vector< string > GetIdentifiers () const Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () virtual vector< string > GetIdentifiers () const =0 vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId) Public Functions inherited from datatypes::timeseries::TimeSeriesInfoProvider Name virtual ~TimeSeriesInfoProvider () Public Types Documentation \u00b6 using T \u00b6 using datatypes :: tests :: TestTimeSeriesEnsembleTimeSeriesStore :: T = double ; using SeriesType \u00b6 using datatypes :: tests :: TestTimeSeriesEnsembleTimeSeriesStore :: SeriesType = CommonTypes < T >:: SeriesType ; using PtrSeriesType \u00b6 using datatypes :: tests :: TestTimeSeriesEnsembleTimeSeriesStore :: PtrSeriesType = CommonTypes < T >:: PtrSeriesType ; using EnsemblePtrType \u00b6 using datatypes :: tests :: TestTimeSeriesEnsembleTimeSeriesStore :: EnsemblePtrType = CommonTypes < T >:: EnsemblePtrType ; using PtrEnsemblePtrType \u00b6 using datatypes :: tests :: TestTimeSeriesEnsembleTimeSeriesStore :: PtrEnsemblePtrType = CommonTypes < T >:: PtrEnsemblePtrType ; using TSeriesEnsemblePtrType \u00b6 using datatypes :: tests :: TestTimeSeriesEnsembleTimeSeriesStore :: TSeriesEnsemblePtrType = CommonTypes < T >:: TSeriesEnsemblePtrType ; using PtrTSeriesEnsemblePtrType \u00b6 using datatypes :: tests :: TestTimeSeriesEnsembleTimeSeriesStore :: PtrTSeriesEnsemblePtrType = CommonTypes < T >:: PtrTSeriesEnsemblePtrType ; Public Functions Documentation \u00b6 function ~TestTimeSeriesEnsembleTimeSeriesStore \u00b6 ~ TestTimeSeriesEnsembleTimeSeriesStore () function TestTimeSeriesEnsembleTimeSeriesStore \u00b6 TestTimeSeriesEnsembleTimeSeriesStore ( const string & id = \"\" ) function TestTimeSeriesEnsembleTimeSeriesStore \u00b6 TestTimeSeriesEnsembleTimeSeriesStore ( const TSeriesEnsemblePtrType & ensFts , const string & id = \"\" ) function GetSeries \u00b6 virtual PtrTSeriesEnsemblePtrType GetSeries ( const string & dataId ) Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetSeries function GetSeriesTestBackend \u00b6 PtrTSeriesEnsemblePtrType GetSeriesTestBackend ( const string & dataId ) function Read \u00b6 PtrEnsemblePtrType Read ( const std :: string & ensembleIdentifier ) function GetLength \u00b6 virtual size_t GetLength () const Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetLength function GetStart \u00b6 virtual ptime GetStart () const Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetStart function GetDataSummary \u00b6 virtual string GetDataSummary () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataSummary function GetDataDimensionsDescription \u00b6 virtual vector < DataDimensionDescriptor > GetDataDimensionsDescription () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataDimensionsDescription function GetTimeStep \u00b6 virtual TimeStep GetTimeStep () const Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetTimeStep function IsActive \u00b6 virtual bool IsActive () Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::IsActive function Allocate \u00b6 virtual void Allocate ( size_t length , PtrEnsemblePtrType value ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::Allocate function AllocateValues \u00b6 virtual void AllocateValues ( const vector < PtrEnsemblePtrType > & values ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::AllocateValues function SetSeries \u00b6 virtual void SetSeries ( const string & dataId , PtrTSeriesEnsemblePtrType value ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetSeries function SetItem \u00b6 virtual void SetItem ( const string & dataId , size_t index , PtrEnsemblePtrType value ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetItem function SetItem \u00b6 virtual void SetItem ( const string & dataId , size_t index , const EnsemblePtrType & value ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetItem function SetLength \u00b6 virtual void SetLength ( size_t ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetLength function SetStart \u00b6 virtual void SetStart ( ptime ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetStart function SetTimeStep \u00b6 virtual void SetTimeStep ( const TimeStep & ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetTimeStep function GetItem \u00b6 virtual PtrEnsemblePtrType GetItem ( const string & dataId , size_t fcastIndex ) override Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetItem function GetItem \u00b6 virtual PtrSeriesType GetItem ( const string & dataId , size_t fcastIndex , size_t ensIndex ) override Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetItem function GetEnsembleSize \u00b6 virtual size_t GetEnsembleSize ( const string & dataId , size_t fcastIndex ) const override Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetEnsembleSize Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#datatypesteststesttimeseriesensembletimeseriesstore","text":"A time series store for unit tests. #include <datatypes_test_helpers.h> Inherits from datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore< double > , datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T > , datatypes::timeseries::IdentifiersProvider , datatypes::timeseries::TimeSeriesInfoProvider , datatypes::timeseries::DataDescriptor","title":"datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#public-types","text":"Name using double T using CommonTypes < T >:: SeriesType SeriesType using CommonTypes < T >:: PtrSeriesType PtrSeriesType using CommonTypes < T >:: EnsemblePtrType EnsemblePtrType using CommonTypes < T >:: PtrEnsemblePtrType PtrEnsemblePtrType using CommonTypes < T >:: TSeriesEnsemblePtrType TSeriesEnsemblePtrType using CommonTypes < T >:: PtrTSeriesEnsemblePtrType PtrTSeriesEnsemblePtrType","title":"Public Types"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#public-functions","text":"Name ~TestTimeSeriesEnsembleTimeSeriesStore () TestTimeSeriesEnsembleTimeSeriesStore (const string & id =\"\") TestTimeSeriesEnsembleTimeSeriesStore (const TSeriesEnsemblePtrType & ensFts, const string & id =\"\") virtual PtrTSeriesEnsemblePtrType GetSeries (const string & dataId) PtrTSeriesEnsemblePtrType GetSeriesTestBackend (const string & dataId) PtrEnsemblePtrType Read (const std::string & ensembleIdentifier) virtual size_t GetLength () const virtual ptime GetStart () const virtual string GetDataSummary () const virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const virtual TimeStep GetTimeStep () const virtual bool IsActive () virtual void Allocate (size_t length, PtrEnsemblePtrType value) virtual void AllocateValues (const vector< PtrEnsemblePtrType > & values) virtual void SetSeries (const string & dataId, PtrTSeriesEnsemblePtrType value) virtual void SetItem (const string & dataId, size_t index, PtrEnsemblePtrType value) virtual void SetItem (const string & dataId, size_t index, const EnsemblePtrType & value) virtual void SetLength (size_t ) virtual void SetStart (ptime ) virtual void SetTimeStep (const TimeStep & ) virtual PtrEnsemblePtrType GetItem (const string & dataId, size_t fcastIndex) override virtual PtrSeriesType GetItem (const string & dataId, size_t fcastIndex, size_t ensIndex) override virtual size_t GetEnsembleSize (const string & dataId, size_t fcastIndex) const override","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore< double > Name virtual ~WritableTimeSeriesEnsembleTimeSeriesStore () Public Functions inherited from datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T > Name virtual ~TimeSeriesEnsembleTimeSeriesStore () virtual vector< string > GetIdentifiers () const Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () virtual vector< string > GetIdentifiers () const =0 vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId) Public Functions inherited from datatypes::timeseries::TimeSeriesInfoProvider Name virtual ~TimeSeriesInfoProvider ()","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#using-t","text":"using datatypes :: tests :: TestTimeSeriesEnsembleTimeSeriesStore :: T = double ;","title":"using T"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#using-seriestype","text":"using datatypes :: tests :: TestTimeSeriesEnsembleTimeSeriesStore :: SeriesType = CommonTypes < T >:: SeriesType ;","title":"using SeriesType"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#using-ptrseriestype","text":"using datatypes :: tests :: TestTimeSeriesEnsembleTimeSeriesStore :: PtrSeriesType = CommonTypes < T >:: PtrSeriesType ;","title":"using PtrSeriesType"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#using-ensembleptrtype","text":"using datatypes :: tests :: TestTimeSeriesEnsembleTimeSeriesStore :: EnsemblePtrType = CommonTypes < T >:: EnsemblePtrType ;","title":"using EnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#using-ptrensembleptrtype","text":"using datatypes :: tests :: TestTimeSeriesEnsembleTimeSeriesStore :: PtrEnsemblePtrType = CommonTypes < T >:: PtrEnsemblePtrType ;","title":"using PtrEnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#using-tseriesensembleptrtype","text":"using datatypes :: tests :: TestTimeSeriesEnsembleTimeSeriesStore :: TSeriesEnsemblePtrType = CommonTypes < T >:: TSeriesEnsemblePtrType ;","title":"using TSeriesEnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#using-ptrtseriesensembleptrtype","text":"using datatypes :: tests :: TestTimeSeriesEnsembleTimeSeriesStore :: PtrTSeriesEnsemblePtrType = CommonTypes < T >:: PtrTSeriesEnsemblePtrType ;","title":"using PtrTSeriesEnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#function-testtimeseriesensembletimeseriesstore","text":"~ TestTimeSeriesEnsembleTimeSeriesStore ()","title":"function ~TestTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#function-testtimeseriesensembletimeseriesstore_1","text":"TestTimeSeriesEnsembleTimeSeriesStore ( const string & id = \"\" )","title":"function TestTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#function-testtimeseriesensembletimeseriesstore_2","text":"TestTimeSeriesEnsembleTimeSeriesStore ( const TSeriesEnsemblePtrType & ensFts , const string & id = \"\" )","title":"function TestTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#function-getseries","text":"virtual PtrTSeriesEnsemblePtrType GetSeries ( const string & dataId ) Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetSeries","title":"function GetSeries"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#function-getseriestestbackend","text":"PtrTSeriesEnsemblePtrType GetSeriesTestBackend ( const string & dataId )","title":"function GetSeriesTestBackend"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#function-read","text":"PtrEnsemblePtrType Read ( const std :: string & ensembleIdentifier )","title":"function Read"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#function-getlength","text":"virtual size_t GetLength () const Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetLength","title":"function GetLength"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#function-getstart","text":"virtual ptime GetStart () const Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetStart","title":"function GetStart"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#function-getdatasummary","text":"virtual string GetDataSummary () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataSummary","title":"function GetDataSummary"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#function-getdatadimensionsdescription","text":"virtual vector < DataDimensionDescriptor > GetDataDimensionsDescription () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataDimensionsDescription","title":"function GetDataDimensionsDescription"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#function-gettimestep","text":"virtual TimeStep GetTimeStep () const Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetTimeStep","title":"function GetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#function-isactive","text":"virtual bool IsActive () Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::IsActive","title":"function IsActive"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#function-allocate","text":"virtual void Allocate ( size_t length , PtrEnsemblePtrType value ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::Allocate","title":"function Allocate"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#function-allocatevalues","text":"virtual void AllocateValues ( const vector < PtrEnsemblePtrType > & values ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::AllocateValues","title":"function AllocateValues"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#function-setseries","text":"virtual void SetSeries ( const string & dataId , PtrTSeriesEnsemblePtrType value ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetSeries","title":"function SetSeries"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#function-setitem","text":"virtual void SetItem ( const string & dataId , size_t index , PtrEnsemblePtrType value ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetItem","title":"function SetItem"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#function-setitem_1","text":"virtual void SetItem ( const string & dataId , size_t index , const EnsemblePtrType & value ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetItem","title":"function SetItem"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#function-setlength","text":"virtual void SetLength ( size_t ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetLength","title":"function SetLength"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#function-setstart","text":"virtual void SetStart ( ptime ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetStart","title":"function SetStart"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#function-settimestep","text":"virtual void SetTimeStep ( const TimeStep & ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetTimeStep","title":"function SetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#function-getitem","text":"virtual PtrEnsemblePtrType GetItem ( const string & dataId , size_t fcastIndex ) override Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetItem","title":"function GetItem"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#function-getitem_1","text":"virtual PtrSeriesType GetItem ( const string & dataId , size_t fcastIndex , size_t ensIndex ) override Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetItem","title":"function GetItem"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesEnsembleTimeSeriesStore/#function-getensemblesize","text":"virtual size_t GetEnsembleSize ( const string & dataId , size_t fcastIndex ) const override Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetEnsembleSize Updated on 2022-08-20 at 19:28:22 +1000","title":"function GetEnsembleSize"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesStoreFactory/","text":"datatypes::tests::TestTimeSeriesStoreFactory \u00b6 #include <datatypes_test_helpers.h> Inherits from datatypes::timeseries::TimeSeriesStoreFactory Public Functions \u00b6 Name TestTimeSeriesStoreFactory () ~TestTimeSeriesStoreFactory () virtual TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore (const string & dataId) virtual bool CanCreateTimeSeriesEnsembleTimeSeriesStore (const string & dataId) Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::TimeSeriesStoreFactory Name virtual ~TimeSeriesStoreFactory () Protected Functions inherited from datatypes::timeseries::TimeSeriesStoreFactory Name TimeSeriesStoreFactory () Public Functions Documentation \u00b6 function TestTimeSeriesStoreFactory \u00b6 TestTimeSeriesStoreFactory () function ~TestTimeSeriesStoreFactory \u00b6 ~ TestTimeSeriesStoreFactory () function CreateTimeSeriesEnsembleTimeSeriesStore \u00b6 virtual TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ) Reimplements : datatypes::timeseries::TimeSeriesStoreFactory::CreateTimeSeriesEnsembleTimeSeriesStore function CanCreateTimeSeriesEnsembleTimeSeriesStore \u00b6 virtual bool CanCreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ) Reimplements : datatypes::timeseries::TimeSeriesStoreFactory::CanCreateTimeSeriesEnsembleTimeSeriesStore Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::tests::TestTimeSeriesStoreFactory"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesStoreFactory/#datatypesteststesttimeseriesstorefactory","text":"#include <datatypes_test_helpers.h> Inherits from datatypes::timeseries::TimeSeriesStoreFactory","title":"datatypes::tests::TestTimeSeriesStoreFactory"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesStoreFactory/#public-functions","text":"Name TestTimeSeriesStoreFactory () ~TestTimeSeriesStoreFactory () virtual TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore (const string & dataId) virtual bool CanCreateTimeSeriesEnsembleTimeSeriesStore (const string & dataId)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesStoreFactory/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::TimeSeriesStoreFactory Name virtual ~TimeSeriesStoreFactory () Protected Functions inherited from datatypes::timeseries::TimeSeriesStoreFactory Name TimeSeriesStoreFactory ()","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesStoreFactory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesStoreFactory/#function-testtimeseriesstorefactory","text":"TestTimeSeriesStoreFactory ()","title":"function TestTimeSeriesStoreFactory"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesStoreFactory/#function-testtimeseriesstorefactory_1","text":"~ TestTimeSeriesStoreFactory ()","title":"function ~TestTimeSeriesStoreFactory"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesStoreFactory/#function-createtimeseriesensembletimeseriesstore","text":"virtual TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ) Reimplements : datatypes::timeseries::TimeSeriesStoreFactory::CreateTimeSeriesEnsembleTimeSeriesStore","title":"function CreateTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1tests_1_1TestTimeSeriesStoreFactory/#function-cancreatetimeseriesensembletimeseriesstore","text":"virtual bool CanCreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ) Reimplements : datatypes::timeseries::TimeSeriesStoreFactory::CanCreateTimeSeriesEnsembleTimeSeriesStore Updated on 2022-08-20 at 19:28:22 +1000","title":"function CanCreateTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataDescriptor/","text":"datatypes::timeseries::DataDescriptor \u00b6 #include <time_series_store.hpp> Inherited by datatypes::timeseries::EnsembleTimeSeriesStore< double > , datatypes::timeseries::SingleTimeSeriesStore< double > , datatypes::timeseries::EnsembleTimeSeriesStore< T > , datatypes::timeseries::SingleTimeSeriesStore< T > , datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T > Public Functions \u00b6 Name virtual string GetDataSummary () const =0 virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const =0 Public Functions Documentation \u00b6 function GetDataSummary \u00b6 virtual string GetDataSummary () const = 0 Reimplemented by : datatypes::tests::TestSingleTimeSeriesStore::GetDataSummary , datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetDataSummary , datatypes::tests::TestEnsembleTimeSeriesStore::GetDataSummary , datatypes::timeseries::NetCdfSingleSeriesStore::GetDataSummary , datatypes::timeseries::NetCdfEnsembleTimeSeriesStore::GetDataSummary , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetDataSummary , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetDataSummary , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetDataSummary function GetDataDimensionsDescription \u00b6 virtual vector < DataDimensionDescriptor > GetDataDimensionsDescription () const = 0 Reimplemented by : datatypes::tests::TestSingleTimeSeriesStore::GetDataDimensionsDescription , datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetDataDimensionsDescription , datatypes::tests::TestEnsembleTimeSeriesStore::GetDataDimensionsDescription , datatypes::timeseries::NetCdfSingleSeriesStore::GetDataDimensionsDescription , datatypes::timeseries::NetCdfEnsembleTimeSeriesStore::GetDataDimensionsDescription , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetDataDimensionsDescription , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetDataDimensionsDescription , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetDataDimensionsDescription Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::DataDescriptor"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataDescriptor/#datatypestimeseriesdatadescriptor","text":"#include <time_series_store.hpp> Inherited by datatypes::timeseries::EnsembleTimeSeriesStore< double > , datatypes::timeseries::SingleTimeSeriesStore< double > , datatypes::timeseries::EnsembleTimeSeriesStore< T > , datatypes::timeseries::SingleTimeSeriesStore< T > , datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T >","title":"datatypes::timeseries::DataDescriptor"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataDescriptor/#public-functions","text":"Name virtual string GetDataSummary () const =0 virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const =0","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataDescriptor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataDescriptor/#function-getdatasummary","text":"virtual string GetDataSummary () const = 0 Reimplemented by : datatypes::tests::TestSingleTimeSeriesStore::GetDataSummary , datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetDataSummary , datatypes::tests::TestEnsembleTimeSeriesStore::GetDataSummary , datatypes::timeseries::NetCdfSingleSeriesStore::GetDataSummary , datatypes::timeseries::NetCdfEnsembleTimeSeriesStore::GetDataSummary , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetDataSummary , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetDataSummary , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetDataSummary","title":"function GetDataSummary"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataDescriptor/#function-getdatadimensionsdescription","text":"virtual vector < DataDimensionDescriptor > GetDataDimensionsDescription () const = 0 Reimplemented by : datatypes::tests::TestSingleTimeSeriesStore::GetDataDimensionsDescription , datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetDataDimensionsDescription , datatypes::tests::TestEnsembleTimeSeriesStore::GetDataDimensionsDescription , datatypes::timeseries::NetCdfSingleSeriesStore::GetDataDimensionsDescription , datatypes::timeseries::NetCdfEnsembleTimeSeriesStore::GetDataDimensionsDescription , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetDataDimensionsDescription , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetDataDimensionsDescription , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetDataDimensionsDescription Updated on 2022-08-20 at 19:28:22 +1000","title":"function GetDataDimensionsDescription"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataDimensionDescriptor/","text":"datatypes::timeseries::DataDimensionDescriptor \u00b6 #include <time_series_store.hpp> Public Functions \u00b6 Name DataDimensionDescriptor (const string & type, const string & dimname =\"\", size_t size =0) DataDimensionDescriptor (const DataDimensionDescriptor & src) DataDimensionDescriptor ( DataDimensionDescriptor && src) DataDimensionDescriptor & operator= (const DataDimensionDescriptor & src) DataDimensionDescriptor & operator= ( DataDimensionDescriptor && src) Public Attributes \u00b6 Name string DimensionType string DimensionName size_t Size Public Functions Documentation \u00b6 function DataDimensionDescriptor \u00b6 DataDimensionDescriptor ( const string & type , const string & dimname = \"\" , size_t size = 0 ) function DataDimensionDescriptor \u00b6 DataDimensionDescriptor ( const DataDimensionDescriptor & src ) function DataDimensionDescriptor \u00b6 DataDimensionDescriptor ( DataDimensionDescriptor && src ) function operator= \u00b6 DataDimensionDescriptor & operator = ( const DataDimensionDescriptor & src ) function operator= \u00b6 DataDimensionDescriptor & operator = ( DataDimensionDescriptor && src ) Public Attributes Documentation \u00b6 variable DimensionType \u00b6 string DimensionType ; variable DimensionName \u00b6 string DimensionName ; variable Size \u00b6 size_t Size = 0 ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::DataDimensionDescriptor"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataDimensionDescriptor/#datatypestimeseriesdatadimensiondescriptor","text":"#include <time_series_store.hpp>","title":"datatypes::timeseries::DataDimensionDescriptor"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataDimensionDescriptor/#public-functions","text":"Name DataDimensionDescriptor (const string & type, const string & dimname =\"\", size_t size =0) DataDimensionDescriptor (const DataDimensionDescriptor & src) DataDimensionDescriptor ( DataDimensionDescriptor && src) DataDimensionDescriptor & operator= (const DataDimensionDescriptor & src) DataDimensionDescriptor & operator= ( DataDimensionDescriptor && src)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataDimensionDescriptor/#public-attributes","text":"Name string DimensionType string DimensionName size_t Size","title":"Public Attributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataDimensionDescriptor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataDimensionDescriptor/#function-datadimensiondescriptor","text":"DataDimensionDescriptor ( const string & type , const string & dimname = \"\" , size_t size = 0 )","title":"function DataDimensionDescriptor"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataDimensionDescriptor/#function-datadimensiondescriptor_1","text":"DataDimensionDescriptor ( const DataDimensionDescriptor & src )","title":"function DataDimensionDescriptor"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataDimensionDescriptor/#function-datadimensiondescriptor_2","text":"DataDimensionDescriptor ( DataDimensionDescriptor && src )","title":"function DataDimensionDescriptor"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataDimensionDescriptor/#function-operator","text":"DataDimensionDescriptor & operator = ( const DataDimensionDescriptor & src )","title":"function operator="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataDimensionDescriptor/#function-operator_1","text":"DataDimensionDescriptor & operator = ( DataDimensionDescriptor && src )","title":"function operator="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataDimensionDescriptor/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataDimensionDescriptor/#variable-dimensiontype","text":"string DimensionType ;","title":"variable DimensionType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataDimensionDescriptor/#variable-dimensionname","text":"string DimensionName ;","title":"variable DimensionName"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataDimensionDescriptor/#variable-size","text":"size_t Size = 0 ; Updated on 2022-08-20 at 19:28:22 +1000","title":"variable Size"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataGeometryProvider/","text":"datatypes::timeseries::DataGeometryProvider \u00b6 #include <time_series_io.hpp> Public Functions \u00b6 Name virtual DimensionsDefinitions GetDimensions () const =0 virtual ~DataGeometryProvider () Public Functions Documentation \u00b6 function GetDimensions \u00b6 virtual DimensionsDefinitions GetDimensions () const = 0 function ~DataGeometryProvider \u00b6 virtual ~ DataGeometryProvider () Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::DataGeometryProvider"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataGeometryProvider/#datatypestimeseriesdatageometryprovider","text":"#include <time_series_io.hpp>","title":"datatypes::timeseries::DataGeometryProvider"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataGeometryProvider/#public-functions","text":"Name virtual DimensionsDefinitions GetDimensions () const =0 virtual ~DataGeometryProvider ()","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataGeometryProvider/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataGeometryProvider/#function-getdimensions","text":"virtual DimensionsDefinitions GetDimensions () const = 0","title":"function GetDimensions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DataGeometryProvider/#function-datageometryprovider","text":"virtual ~ DataGeometryProvider () Updated on 2022-08-20 at 19:28:22 +1000","title":"function ~DataGeometryProvider"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DefaultMissingFloatingPointPolicy/","text":"datatypes::timeseries::DefaultMissingFloatingPointPolicy \u00b6 More... #include <time_series_strategies.hpp> Inherits from datatypes::timeseries::MissingValuePolicy< double > Public Functions \u00b6 Name bool IsMissingValue (const T & a) const virtual T GetMissingValue () const virtual MissingValuePolicy < T > * Clone () const Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::MissingValuePolicy< double > Name virtual ~MissingValuePolicy () Detailed Description \u00b6 template < typename T = double > class datatypes :: timeseries :: DefaultMissingFloatingPointPolicy ; Public Functions Documentation \u00b6 function IsMissingValue \u00b6 inline bool IsMissingValue ( const T & a ) const function GetMissingValue \u00b6 inline virtual T GetMissingValue () const Reimplements : datatypes::timeseries::MissingValuePolicy::GetMissingValue function Clone \u00b6 inline virtual MissingValuePolicy < T > * Clone () const Reimplements : datatypes::timeseries::MissingValuePolicy::Clone Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::DefaultMissingFloatingPointPolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DefaultMissingFloatingPointPolicy/#datatypestimeseriesdefaultmissingfloatingpointpolicy","text":"More... #include <time_series_strategies.hpp> Inherits from datatypes::timeseries::MissingValuePolicy< double >","title":"datatypes::timeseries::DefaultMissingFloatingPointPolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DefaultMissingFloatingPointPolicy/#public-functions","text":"Name bool IsMissingValue (const T & a) const virtual T GetMissingValue () const virtual MissingValuePolicy < T > * Clone () const","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DefaultMissingFloatingPointPolicy/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::MissingValuePolicy< double > Name virtual ~MissingValuePolicy ()","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DefaultMissingFloatingPointPolicy/#detailed-description","text":"template < typename T = double > class datatypes :: timeseries :: DefaultMissingFloatingPointPolicy ;","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DefaultMissingFloatingPointPolicy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DefaultMissingFloatingPointPolicy/#function-ismissingvalue","text":"inline bool IsMissingValue ( const T & a ) const","title":"function IsMissingValue"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DefaultMissingFloatingPointPolicy/#function-getmissingvalue","text":"inline virtual T GetMissingValue () const Reimplements : datatypes::timeseries::MissingValuePolicy::GetMissingValue","title":"function GetMissingValue"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DefaultMissingFloatingPointPolicy/#function-clone","text":"inline virtual MissingValuePolicy < T > * Clone () const Reimplements : datatypes::timeseries::MissingValuePolicy::Clone Updated on 2022-08-20 at 19:28:22 +1000","title":"function Clone"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DimensionsDefinitions/","text":"datatypes::timeseries::DimensionsDefinitions \u00b6 #include <time_series_io.hpp> Public Functions \u00b6 Name DimensionsDefinitions (const size_t ensembleSize, const vector< double > & leadTimeVar, const string & timeUnits, const vector< double > & timeVar, const vector< string > & stationIds = DEFAULT_STATION_IDENTIFIER , const string & leadTimeUnits =\"\") DimensionsDefinitions (const string & timeUnits, const vector< double > & timeVar, const vector< string > & stationIds = DEFAULT_STATION_IDENTIFIER , const string & leadTimeUnits =\"\") DimensionsDefinitions (ptime tsEnsStart, const TimeStep & mainTimeStep, size_t tsLength, size_t ensembleSize, const TimeStep & fcastTimeStep, size_t leadTimeSize, int fcastOffset =1, const vector< string > & stationIds = DEFAULT_STATION_IDENTIFIER , const string & leadTimeUnits =\"\") DimensionsDefinitions () DimensionsDefinitions ( DimensionsDefinitions && src) DimensionsDefinitions (const DimensionsDefinitions & src) DimensionsDefinitions & operator= ( DimensionsDefinitions && src) DimensionsDefinitions & operator= (const DimensionsDefinitions & src) Public Attributes \u00b6 Name size_t EnsembleSize vector< double > LeadTimeVar string TimeUnits vector< double > TimeVar vector< string > StationIds string LeadTimeUnits Public Functions Documentation \u00b6 function DimensionsDefinitions \u00b6 DimensionsDefinitions ( const size_t ensembleSize , const vector < double > & leadTimeVar , const string & timeUnits , const vector < double > & timeVar , const vector < string > & stationIds = DEFAULT_STATION_IDENTIFIER , const string & leadTimeUnits = \"\" ) function DimensionsDefinitions \u00b6 DimensionsDefinitions ( const string & timeUnits , const vector < double > & timeVar , const vector < string > & stationIds = DEFAULT_STATION_IDENTIFIER , const string & leadTimeUnits = \"\" ) function DimensionsDefinitions \u00b6 DimensionsDefinitions ( ptime tsEnsStart , const TimeStep & mainTimeStep , size_t tsLength , size_t ensembleSize , const TimeStep & fcastTimeStep , size_t leadTimeSize , int fcastOffset = 1 , const vector < string > & stationIds = DEFAULT_STATION_IDENTIFIER , const string & leadTimeUnits = \"\" ) function DimensionsDefinitions \u00b6 DimensionsDefinitions () function DimensionsDefinitions \u00b6 DimensionsDefinitions ( DimensionsDefinitions && src ) function DimensionsDefinitions \u00b6 DimensionsDefinitions ( const DimensionsDefinitions & src ) function operator= \u00b6 DimensionsDefinitions & operator = ( DimensionsDefinitions && src ) function operator= \u00b6 DimensionsDefinitions & operator = ( const DimensionsDefinitions & src ) Public Attributes Documentation \u00b6 variable EnsembleSize \u00b6 size_t EnsembleSize ; variable LeadTimeVar \u00b6 vector < double > LeadTimeVar ; variable TimeUnits \u00b6 string TimeUnits ; variable TimeVar \u00b6 vector < double > TimeVar ; variable StationIds \u00b6 vector < string > StationIds ; variable LeadTimeUnits \u00b6 string LeadTimeUnits ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::DimensionsDefinitions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DimensionsDefinitions/#datatypestimeseriesdimensionsdefinitions","text":"#include <time_series_io.hpp>","title":"datatypes::timeseries::DimensionsDefinitions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DimensionsDefinitions/#public-functions","text":"Name DimensionsDefinitions (const size_t ensembleSize, const vector< double > & leadTimeVar, const string & timeUnits, const vector< double > & timeVar, const vector< string > & stationIds = DEFAULT_STATION_IDENTIFIER , const string & leadTimeUnits =\"\") DimensionsDefinitions (const string & timeUnits, const vector< double > & timeVar, const vector< string > & stationIds = DEFAULT_STATION_IDENTIFIER , const string & leadTimeUnits =\"\") DimensionsDefinitions (ptime tsEnsStart, const TimeStep & mainTimeStep, size_t tsLength, size_t ensembleSize, const TimeStep & fcastTimeStep, size_t leadTimeSize, int fcastOffset =1, const vector< string > & stationIds = DEFAULT_STATION_IDENTIFIER , const string & leadTimeUnits =\"\") DimensionsDefinitions () DimensionsDefinitions ( DimensionsDefinitions && src) DimensionsDefinitions (const DimensionsDefinitions & src) DimensionsDefinitions & operator= ( DimensionsDefinitions && src) DimensionsDefinitions & operator= (const DimensionsDefinitions & src)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DimensionsDefinitions/#public-attributes","text":"Name size_t EnsembleSize vector< double > LeadTimeVar string TimeUnits vector< double > TimeVar vector< string > StationIds string LeadTimeUnits","title":"Public Attributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DimensionsDefinitions/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DimensionsDefinitions/#function-dimensionsdefinitions","text":"DimensionsDefinitions ( const size_t ensembleSize , const vector < double > & leadTimeVar , const string & timeUnits , const vector < double > & timeVar , const vector < string > & stationIds = DEFAULT_STATION_IDENTIFIER , const string & leadTimeUnits = \"\" )","title":"function DimensionsDefinitions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DimensionsDefinitions/#function-dimensionsdefinitions_1","text":"DimensionsDefinitions ( const string & timeUnits , const vector < double > & timeVar , const vector < string > & stationIds = DEFAULT_STATION_IDENTIFIER , const string & leadTimeUnits = \"\" )","title":"function DimensionsDefinitions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DimensionsDefinitions/#function-dimensionsdefinitions_2","text":"DimensionsDefinitions ( ptime tsEnsStart , const TimeStep & mainTimeStep , size_t tsLength , size_t ensembleSize , const TimeStep & fcastTimeStep , size_t leadTimeSize , int fcastOffset = 1 , const vector < string > & stationIds = DEFAULT_STATION_IDENTIFIER , const string & leadTimeUnits = \"\" )","title":"function DimensionsDefinitions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DimensionsDefinitions/#function-dimensionsdefinitions_3","text":"DimensionsDefinitions ()","title":"function DimensionsDefinitions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DimensionsDefinitions/#function-dimensionsdefinitions_4","text":"DimensionsDefinitions ( DimensionsDefinitions && src )","title":"function DimensionsDefinitions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DimensionsDefinitions/#function-dimensionsdefinitions_5","text":"DimensionsDefinitions ( const DimensionsDefinitions & src )","title":"function DimensionsDefinitions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DimensionsDefinitions/#function-operator","text":"DimensionsDefinitions & operator = ( DimensionsDefinitions && src )","title":"function operator="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DimensionsDefinitions/#function-operator_1","text":"DimensionsDefinitions & operator = ( const DimensionsDefinitions & src )","title":"function operator="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DimensionsDefinitions/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DimensionsDefinitions/#variable-ensemblesize","text":"size_t EnsembleSize ;","title":"variable EnsembleSize"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DimensionsDefinitions/#variable-leadtimevar","text":"vector < double > LeadTimeVar ;","title":"variable LeadTimeVar"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DimensionsDefinitions/#variable-timeunits","text":"string TimeUnits ;","title":"variable TimeUnits"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DimensionsDefinitions/#variable-timevar","text":"vector < double > TimeVar ;","title":"variable TimeVar"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DimensionsDefinitions/#variable-stationids","text":"vector < string > StationIds ;","title":"variable StationIds"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1DimensionsDefinitions/#variable-leadtimeunits","text":"string LeadTimeUnits ; Updated on 2022-08-20 at 19:28:22 +1000","title":"variable LeadTimeUnits"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/","text":"datatypes::timeseries::EagerWriter \u00b6 More... #include <time_series_io.hpp> Inherits from datatypes::timeseries::StoragePolicy< StorageType > , datatypes::timeseries::TimeSeriesInfoProvider Public Types \u00b6 Name using typename TimeSeriesEnsembleTimeSeriesStore < double >:: EnsemblePtrType EnsemblePtrType using StorageType PtrEnsemblePtrType using typename EnsemblePtrType::ElementType ElementType using EnsemblePtrType::ItemType TsType Public Functions \u00b6 Name EagerWriter ( WritableTimeSeriesEnsembleTimeSeriesStore < ElementType > * store) EagerWriter (const EagerWriter & src) virtual bool ReadOnly () override virtual size_t Size () const virtual void Allocate (size_t length, PtrEnsemblePtrType value) virtual void AllocateValues (size_t length, const PtrEnsemblePtrType * values) virtual void AllocateValues (const vector< PtrEnsemblePtrType > & values) virtual void CopyTo (vector< PtrEnsemblePtrType > & dest, size_t from =0, size_t to =-1) const PtrEnsemblePtrType & GetProxy (const size_t i) virtual PtrEnsemblePtrType & operator[] (const size_t i) virtual const PtrEnsemblePtrType & operator[] (const size_t i) const virtual StoragePolicy < PtrEnsemblePtrType > * Clone () const virtual size_t GetLength () const virtual TimeStep GetTimeStep () const override virtual ptime GetStart () const override virtual void SetTimeStep (const TimeStep & tStep) override virtual void SetStart (const ptime & start) override Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::StoragePolicy< StorageType > Name virtual ~StoragePolicy () Protected Functions inherited from datatypes::timeseries::StoragePolicy< StorageType > Name StoragePolicy (const StoragePolicy & src) StoragePolicy () Public Functions inherited from datatypes::timeseries::TimeSeriesInfoProvider Name virtual ~TimeSeriesInfoProvider () Detailed Description \u00b6 template < typename StorageType > class datatypes :: timeseries :: EagerWriter ; Public Types Documentation \u00b6 using EnsemblePtrType \u00b6 using datatypes :: timeseries :: EagerWriter < StorageType >:: EnsemblePtrType = typename TimeSeriesEnsembleTimeSeriesStore < double >:: EnsemblePtrType ; using PtrEnsemblePtrType \u00b6 using datatypes :: timeseries :: EagerWriter < StorageType >:: PtrEnsemblePtrType = StorageType ; using ElementType \u00b6 using datatypes :: timeseries :: EagerWriter < StorageType >:: ElementType = typename EnsemblePtrType :: ElementType ; using TsType \u00b6 using datatypes :: timeseries :: EagerWriter < StorageType >:: TsType = EnsemblePtrType :: ItemType ; Public Functions Documentation \u00b6 function EagerWriter \u00b6 inline EagerWriter ( WritableTimeSeriesEnsembleTimeSeriesStore < ElementType > * store ) function EagerWriter \u00b6 inline EagerWriter ( const EagerWriter & src ) function ReadOnly \u00b6 inline virtual bool ReadOnly () override Reimplements : datatypes::timeseries::StoragePolicy::ReadOnly function Size \u00b6 inline virtual size_t Size () const Reimplements : datatypes::timeseries::StoragePolicy::Size function Allocate \u00b6 inline virtual void Allocate ( size_t length , PtrEnsemblePtrType value ) Reimplements : datatypes::timeseries::StoragePolicy::Allocate function AllocateValues \u00b6 inline virtual void AllocateValues ( size_t length , const PtrEnsemblePtrType * values ) Reimplements : datatypes::timeseries::StoragePolicy::AllocateValues function AllocateValues \u00b6 inline virtual void AllocateValues ( const vector < PtrEnsemblePtrType > & values ) Reimplements : datatypes::timeseries::StoragePolicy::AllocateValues function CopyTo \u00b6 inline virtual void CopyTo ( vector < PtrEnsemblePtrType > & dest , size_t from = 0 , size_t to = -1 ) const Reimplements : datatypes::timeseries::StoragePolicy::CopyTo function GetProxy \u00b6 inline PtrEnsemblePtrType & GetProxy ( const size_t i ) function operator[] \u00b6 inline virtual PtrEnsemblePtrType & operator []( const size_t i ) Reimplements : datatypes::timeseries::StoragePolicy::operator[] function operator[] \u00b6 inline virtual const PtrEnsemblePtrType & operator []( const size_t i ) const Reimplements : datatypes::timeseries::StoragePolicy::operator[] function Clone \u00b6 inline virtual StoragePolicy < PtrEnsemblePtrType > * Clone () const Reimplements : datatypes::timeseries::StoragePolicy::Clone function GetLength \u00b6 inline virtual size_t GetLength () const Reimplements : datatypes::timeseries::TimeSeriesInfoProvider::GetLength function GetTimeStep \u00b6 inline virtual TimeStep GetTimeStep () const override Reimplements : datatypes::timeseries::StoragePolicy::GetTimeStep function GetStart \u00b6 inline virtual ptime GetStart () const override Reimplements : datatypes::timeseries::StoragePolicy::GetStart function SetTimeStep \u00b6 inline virtual void SetTimeStep ( const TimeStep & tStep ) override Reimplements : datatypes::timeseries::StoragePolicy::SetTimeStep function SetStart \u00b6 inline virtual void SetStart ( const ptime & start ) override Reimplements : datatypes::timeseries::StoragePolicy::SetStart Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::EagerWriter"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#datatypestimeserieseagerwriter","text":"More... #include <time_series_io.hpp> Inherits from datatypes::timeseries::StoragePolicy< StorageType > , datatypes::timeseries::TimeSeriesInfoProvider","title":"datatypes::timeseries::EagerWriter"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#public-types","text":"Name using typename TimeSeriesEnsembleTimeSeriesStore < double >:: EnsemblePtrType EnsemblePtrType using StorageType PtrEnsemblePtrType using typename EnsemblePtrType::ElementType ElementType using EnsemblePtrType::ItemType TsType","title":"Public Types"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#public-functions","text":"Name EagerWriter ( WritableTimeSeriesEnsembleTimeSeriesStore < ElementType > * store) EagerWriter (const EagerWriter & src) virtual bool ReadOnly () override virtual size_t Size () const virtual void Allocate (size_t length, PtrEnsemblePtrType value) virtual void AllocateValues (size_t length, const PtrEnsemblePtrType * values) virtual void AllocateValues (const vector< PtrEnsemblePtrType > & values) virtual void CopyTo (vector< PtrEnsemblePtrType > & dest, size_t from =0, size_t to =-1) const PtrEnsemblePtrType & GetProxy (const size_t i) virtual PtrEnsemblePtrType & operator[] (const size_t i) virtual const PtrEnsemblePtrType & operator[] (const size_t i) const virtual StoragePolicy < PtrEnsemblePtrType > * Clone () const virtual size_t GetLength () const virtual TimeStep GetTimeStep () const override virtual ptime GetStart () const override virtual void SetTimeStep (const TimeStep & tStep) override virtual void SetStart (const ptime & start) override","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::StoragePolicy< StorageType > Name virtual ~StoragePolicy () Protected Functions inherited from datatypes::timeseries::StoragePolicy< StorageType > Name StoragePolicy (const StoragePolicy & src) StoragePolicy () Public Functions inherited from datatypes::timeseries::TimeSeriesInfoProvider Name virtual ~TimeSeriesInfoProvider ()","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#detailed-description","text":"template < typename StorageType > class datatypes :: timeseries :: EagerWriter ;","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#using-ensembleptrtype","text":"using datatypes :: timeseries :: EagerWriter < StorageType >:: EnsemblePtrType = typename TimeSeriesEnsembleTimeSeriesStore < double >:: EnsemblePtrType ;","title":"using EnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#using-ptrensembleptrtype","text":"using datatypes :: timeseries :: EagerWriter < StorageType >:: PtrEnsemblePtrType = StorageType ;","title":"using PtrEnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#using-elementtype","text":"using datatypes :: timeseries :: EagerWriter < StorageType >:: ElementType = typename EnsemblePtrType :: ElementType ;","title":"using ElementType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#using-tstype","text":"using datatypes :: timeseries :: EagerWriter < StorageType >:: TsType = EnsemblePtrType :: ItemType ;","title":"using TsType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#function-eagerwriter","text":"inline EagerWriter ( WritableTimeSeriesEnsembleTimeSeriesStore < ElementType > * store )","title":"function EagerWriter"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#function-eagerwriter_1","text":"inline EagerWriter ( const EagerWriter & src )","title":"function EagerWriter"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#function-readonly","text":"inline virtual bool ReadOnly () override Reimplements : datatypes::timeseries::StoragePolicy::ReadOnly","title":"function ReadOnly"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#function-size","text":"inline virtual size_t Size () const Reimplements : datatypes::timeseries::StoragePolicy::Size","title":"function Size"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#function-allocate","text":"inline virtual void Allocate ( size_t length , PtrEnsemblePtrType value ) Reimplements : datatypes::timeseries::StoragePolicy::Allocate","title":"function Allocate"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#function-allocatevalues","text":"inline virtual void AllocateValues ( size_t length , const PtrEnsemblePtrType * values ) Reimplements : datatypes::timeseries::StoragePolicy::AllocateValues","title":"function AllocateValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#function-allocatevalues_1","text":"inline virtual void AllocateValues ( const vector < PtrEnsemblePtrType > & values ) Reimplements : datatypes::timeseries::StoragePolicy::AllocateValues","title":"function AllocateValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#function-copyto","text":"inline virtual void CopyTo ( vector < PtrEnsemblePtrType > & dest , size_t from = 0 , size_t to = -1 ) const Reimplements : datatypes::timeseries::StoragePolicy::CopyTo","title":"function CopyTo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#function-getproxy","text":"inline PtrEnsemblePtrType & GetProxy ( const size_t i )","title":"function GetProxy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#function-operator","text":"inline virtual PtrEnsemblePtrType & operator []( const size_t i ) Reimplements : datatypes::timeseries::StoragePolicy::operator[]","title":"function operator[]"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#function-operator_1","text":"inline virtual const PtrEnsemblePtrType & operator []( const size_t i ) const Reimplements : datatypes::timeseries::StoragePolicy::operator[]","title":"function operator[]"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#function-clone","text":"inline virtual StoragePolicy < PtrEnsemblePtrType > * Clone () const Reimplements : datatypes::timeseries::StoragePolicy::Clone","title":"function Clone"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#function-getlength","text":"inline virtual size_t GetLength () const Reimplements : datatypes::timeseries::TimeSeriesInfoProvider::GetLength","title":"function GetLength"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#function-gettimestep","text":"inline virtual TimeStep GetTimeStep () const override Reimplements : datatypes::timeseries::StoragePolicy::GetTimeStep","title":"function GetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#function-getstart","text":"inline virtual ptime GetStart () const override Reimplements : datatypes::timeseries::StoragePolicy::GetStart","title":"function GetStart"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#function-settimestep","text":"inline virtual void SetTimeStep ( const TimeStep & tStep ) override Reimplements : datatypes::timeseries::StoragePolicy::SetTimeStep","title":"function SetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EagerWriter/#function-setstart","text":"inline virtual void SetStart ( const ptime & start ) override Reimplements : datatypes::timeseries::StoragePolicy::SetStart Updated on 2022-08-20 at 19:28:22 +1000","title":"function SetStart"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/","text":"datatypes::timeseries::EnsembleStoragePolicy \u00b6 More... #include <time_series_strategies.hpp> Inherited by datatypes::timeseries::StdVectorEnsembleStoragePolicy< TsType > , datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy< TsType > Public Types \u00b6 Name typedef std::remove_pointer< TsType >::type Type typedef std::add_pointer< Type >::type PtrType typedef Type::ElementType ElementType Public Functions \u00b6 Name EnsembleStoragePolicy () virtual ~EnsembleStoragePolicy () virtual void Reset (const vector< PtrType > & values, const ptime & startDate, const TimeStep & timeStep) =0 EnsembleStoragePolicy & operator= (const EnsembleStoragePolicy & src) virtual void ResetSeries (const size_t & numSeries, const size_t & lengthSeries, const ptime & startDate, const TimeStep & timeStep) =0 virtual TsType Get (size_t i) =0 virtual ElementType Get (size_t i, size_t tsIndex) =0 virtual void Set (size_t i, size_t tsIndex, ElementType val) =0 virtual void Set (size_t i, const Type & val) =0 virtual vector< ElementType * > * GetValues () const =0 virtual void CopyTo ( ElementType ** dest) const =0 virtual size_t Size () const =0 virtual size_t GetLength (size_t i) const =0 virtual void Clear () =0 virtual const vector< PtrType > & AsReadonlyVector () const =0 virtual EnsembleStoragePolicy < TsType > * Clone () const =0 Protected Functions \u00b6 Name virtual void OperatorEqualImpl (const EnsembleStoragePolicy < TsType > & src) =0 Detailed Description \u00b6 template < typename TsType > class datatypes :: timeseries :: EnsembleStoragePolicy ; Public Types Documentation \u00b6 typedef Type \u00b6 typedef std :: remove_pointer < TsType >:: type datatypes :: timeseries :: EnsembleStoragePolicy < TsType >:: Type ; typedef PtrType \u00b6 typedef std :: add_pointer < Type >:: type datatypes :: timeseries :: EnsembleStoragePolicy < TsType >:: PtrType ; typedef ElementType \u00b6 typedef Type :: ElementType datatypes :: timeseries :: EnsembleStoragePolicy < TsType >:: ElementType ; Public Functions Documentation \u00b6 function EnsembleStoragePolicy \u00b6 inline EnsembleStoragePolicy () function ~EnsembleStoragePolicy \u00b6 inline virtual ~ EnsembleStoragePolicy () function Reset \u00b6 virtual void Reset ( const vector < PtrType > & values , const ptime & startDate , const TimeStep & timeStep ) = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::Reset , datatypes::timeseries::StdVectorEnsembleStoragePolicy::Reset function operator= \u00b6 inline EnsembleStoragePolicy & operator = ( const EnsembleStoragePolicy & src ) function ResetSeries \u00b6 virtual void ResetSeries ( const size_t & numSeries , const size_t & lengthSeries , const ptime & startDate , const TimeStep & timeStep ) = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::ResetSeries , datatypes::timeseries::StdVectorEnsembleStoragePolicy::ResetSeries function Get \u00b6 virtual TsType Get ( size_t i ) = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::Get , datatypes::timeseries::StdVectorEnsembleStoragePolicy::Get function Get \u00b6 virtual ElementType Get ( size_t i , size_t tsIndex ) = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::Get , datatypes::timeseries::StdVectorEnsembleStoragePolicy::Get function Set \u00b6 virtual void Set ( size_t i , size_t tsIndex , ElementType val ) = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::Set , datatypes::timeseries::StdVectorEnsembleStoragePolicy::Set function Set \u00b6 virtual void Set ( size_t i , const Type & val ) = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::Set , datatypes::timeseries::StdVectorEnsembleStoragePolicy::Set function GetValues \u00b6 virtual vector < ElementType * > * GetValues () const = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::GetValues , datatypes::timeseries::StdVectorEnsembleStoragePolicy::GetValues function CopyTo \u00b6 virtual void CopyTo ( ElementType ** dest ) const = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::CopyTo , datatypes::timeseries::StdVectorEnsembleStoragePolicy::CopyTo function Size \u00b6 virtual size_t Size () const = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::Size , datatypes::timeseries::StdVectorEnsembleStoragePolicy::Size function GetLength \u00b6 virtual size_t GetLength ( size_t i ) const = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::GetLength , datatypes::timeseries::StdVectorEnsembleStoragePolicy::GetLength function Clear \u00b6 virtual void Clear () = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::Clear , datatypes::timeseries::StdVectorEnsembleStoragePolicy::Clear function AsReadonlyVector \u00b6 virtual const vector < PtrType > & AsReadonlyVector () const = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::AsReadonlyVector , datatypes::timeseries::StdVectorEnsembleStoragePolicy::AsReadonlyVector function Clone \u00b6 virtual EnsembleStoragePolicy < TsType > * Clone () const = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::Clone , datatypes::timeseries::StdVectorEnsembleStoragePolicy::Clone Protected Functions Documentation \u00b6 function OperatorEqualImpl \u00b6 virtual void OperatorEqualImpl ( const EnsembleStoragePolicy < TsType > & src ) = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::OperatorEqualImpl , datatypes::timeseries::StdVectorEnsembleStoragePolicy::OperatorEqualImpl Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::EnsembleStoragePolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#datatypestimeseriesensemblestoragepolicy","text":"More... #include <time_series_strategies.hpp> Inherited by datatypes::timeseries::StdVectorEnsembleStoragePolicy< TsType > , datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy< TsType >","title":"datatypes::timeseries::EnsembleStoragePolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#public-types","text":"Name typedef std::remove_pointer< TsType >::type Type typedef std::add_pointer< Type >::type PtrType typedef Type::ElementType ElementType","title":"Public Types"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#public-functions","text":"Name EnsembleStoragePolicy () virtual ~EnsembleStoragePolicy () virtual void Reset (const vector< PtrType > & values, const ptime & startDate, const TimeStep & timeStep) =0 EnsembleStoragePolicy & operator= (const EnsembleStoragePolicy & src) virtual void ResetSeries (const size_t & numSeries, const size_t & lengthSeries, const ptime & startDate, const TimeStep & timeStep) =0 virtual TsType Get (size_t i) =0 virtual ElementType Get (size_t i, size_t tsIndex) =0 virtual void Set (size_t i, size_t tsIndex, ElementType val) =0 virtual void Set (size_t i, const Type & val) =0 virtual vector< ElementType * > * GetValues () const =0 virtual void CopyTo ( ElementType ** dest) const =0 virtual size_t Size () const =0 virtual size_t GetLength (size_t i) const =0 virtual void Clear () =0 virtual const vector< PtrType > & AsReadonlyVector () const =0 virtual EnsembleStoragePolicy < TsType > * Clone () const =0","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#protected-functions","text":"Name virtual void OperatorEqualImpl (const EnsembleStoragePolicy < TsType > & src) =0","title":"Protected Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#detailed-description","text":"template < typename TsType > class datatypes :: timeseries :: EnsembleStoragePolicy ;","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#typedef-type","text":"typedef std :: remove_pointer < TsType >:: type datatypes :: timeseries :: EnsembleStoragePolicy < TsType >:: Type ;","title":"typedef Type"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#typedef-ptrtype","text":"typedef std :: add_pointer < Type >:: type datatypes :: timeseries :: EnsembleStoragePolicy < TsType >:: PtrType ;","title":"typedef PtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#typedef-elementtype","text":"typedef Type :: ElementType datatypes :: timeseries :: EnsembleStoragePolicy < TsType >:: ElementType ;","title":"typedef ElementType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#function-ensemblestoragepolicy","text":"inline EnsembleStoragePolicy ()","title":"function EnsembleStoragePolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#function-ensemblestoragepolicy_1","text":"inline virtual ~ EnsembleStoragePolicy ()","title":"function ~EnsembleStoragePolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#function-reset","text":"virtual void Reset ( const vector < PtrType > & values , const ptime & startDate , const TimeStep & timeStep ) = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::Reset , datatypes::timeseries::StdVectorEnsembleStoragePolicy::Reset","title":"function Reset"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#function-operator","text":"inline EnsembleStoragePolicy & operator = ( const EnsembleStoragePolicy & src )","title":"function operator="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#function-resetseries","text":"virtual void ResetSeries ( const size_t & numSeries , const size_t & lengthSeries , const ptime & startDate , const TimeStep & timeStep ) = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::ResetSeries , datatypes::timeseries::StdVectorEnsembleStoragePolicy::ResetSeries","title":"function ResetSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#function-get","text":"virtual TsType Get ( size_t i ) = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::Get , datatypes::timeseries::StdVectorEnsembleStoragePolicy::Get","title":"function Get"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#function-get_1","text":"virtual ElementType Get ( size_t i , size_t tsIndex ) = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::Get , datatypes::timeseries::StdVectorEnsembleStoragePolicy::Get","title":"function Get"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#function-set","text":"virtual void Set ( size_t i , size_t tsIndex , ElementType val ) = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::Set , datatypes::timeseries::StdVectorEnsembleStoragePolicy::Set","title":"function Set"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#function-set_1","text":"virtual void Set ( size_t i , const Type & val ) = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::Set , datatypes::timeseries::StdVectorEnsembleStoragePolicy::Set","title":"function Set"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#function-getvalues","text":"virtual vector < ElementType * > * GetValues () const = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::GetValues , datatypes::timeseries::StdVectorEnsembleStoragePolicy::GetValues","title":"function GetValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#function-copyto","text":"virtual void CopyTo ( ElementType ** dest ) const = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::CopyTo , datatypes::timeseries::StdVectorEnsembleStoragePolicy::CopyTo","title":"function CopyTo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#function-size","text":"virtual size_t Size () const = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::Size , datatypes::timeseries::StdVectorEnsembleStoragePolicy::Size","title":"function Size"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#function-getlength","text":"virtual size_t GetLength ( size_t i ) const = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::GetLength , datatypes::timeseries::StdVectorEnsembleStoragePolicy::GetLength","title":"function GetLength"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#function-clear","text":"virtual void Clear () = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::Clear , datatypes::timeseries::StdVectorEnsembleStoragePolicy::Clear","title":"function Clear"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#function-asreadonlyvector","text":"virtual const vector < PtrType > & AsReadonlyVector () const = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::AsReadonlyVector , datatypes::timeseries::StdVectorEnsembleStoragePolicy::AsReadonlyVector","title":"function AsReadonlyVector"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#function-clone","text":"virtual EnsembleStoragePolicy < TsType > * Clone () const = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::Clone , datatypes::timeseries::StdVectorEnsembleStoragePolicy::Clone","title":"function Clone"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleStoragePolicy/#function-operatorequalimpl","text":"virtual void OperatorEqualImpl ( const EnsembleStoragePolicy < TsType > & src ) = 0 Reimplemented by : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy::OperatorEqualImpl , datatypes::timeseries::StdVectorEnsembleStoragePolicy::OperatorEqualImpl Updated on 2022-08-20 at 19:28:22 +1000","title":"function OperatorEqualImpl"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleTimeSeriesStore/","text":"datatypes::timeseries::EnsembleTimeSeriesStore \u00b6 Interface definition for storages of ensembles of univariate time series. More... #include <time_series_store.hpp> Inherits from datatypes::timeseries::IdentifiersProvider , datatypes::timeseries::DataDescriptor Inherited by datatypes::timeseries::NetCdfEnsembleTimeSeriesStore< T > Public Functions \u00b6 Name virtual ~EnsembleTimeSeriesStore () virtual MultiTimeSeries < TTimeSeries < T > * > * Read () =0 virtual vector< string > GetIdentifiers () const Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId) Public Functions inherited from datatypes::timeseries::DataDescriptor Name virtual string GetDataSummary () const =0 virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const =0 Detailed Description \u00b6 template < typename T > class datatypes :: timeseries :: EnsembleTimeSeriesStore ; Interface definition for storages of ensembles of univariate time series. Template Parameters : T The element type of the time series dealt with, typically double or float. Public Functions Documentation \u00b6 function ~EnsembleTimeSeriesStore \u00b6 inline virtual ~ EnsembleTimeSeriesStore () function Read \u00b6 virtual MultiTimeSeries < TTimeSeries < T > * > * Read () = 0 Reimplemented by : datatypes::tests::TestEnsembleTimeSeriesStore::Read , datatypes::timeseries::NetCdfEnsembleTimeSeriesStore::Read function GetIdentifiers \u00b6 inline virtual vector < string > GetIdentifiers () const Reimplements : datatypes::timeseries::IdentifiersProvider::GetIdentifiers Reimplemented by : datatypes::timeseries::NetCdfEnsembleTimeSeriesStore::GetIdentifiers Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::EnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleTimeSeriesStore/#datatypestimeseriesensembletimeseriesstore","text":"Interface definition for storages of ensembles of univariate time series. More... #include <time_series_store.hpp> Inherits from datatypes::timeseries::IdentifiersProvider , datatypes::timeseries::DataDescriptor Inherited by datatypes::timeseries::NetCdfEnsembleTimeSeriesStore< T >","title":"datatypes::timeseries::EnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleTimeSeriesStore/#public-functions","text":"Name virtual ~EnsembleTimeSeriesStore () virtual MultiTimeSeries < TTimeSeries < T > * > * Read () =0 virtual vector< string > GetIdentifiers () const","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleTimeSeriesStore/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId) Public Functions inherited from datatypes::timeseries::DataDescriptor Name virtual string GetDataSummary () const =0 virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const =0","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleTimeSeriesStore/#detailed-description","text":"template < typename T > class datatypes :: timeseries :: EnsembleTimeSeriesStore ; Interface definition for storages of ensembles of univariate time series. Template Parameters : T The element type of the time series dealt with, typically double or float.","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleTimeSeriesStore/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleTimeSeriesStore/#function-ensembletimeseriesstore","text":"inline virtual ~ EnsembleTimeSeriesStore ()","title":"function ~EnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleTimeSeriesStore/#function-read","text":"virtual MultiTimeSeries < TTimeSeries < T > * > * Read () = 0 Reimplemented by : datatypes::tests::TestEnsembleTimeSeriesStore::Read , datatypes::timeseries::NetCdfEnsembleTimeSeriesStore::Read","title":"function Read"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1EnsembleTimeSeriesStore/#function-getidentifiers","text":"inline virtual vector < string > GetIdentifiers () const Reimplements : datatypes::timeseries::IdentifiersProvider::GetIdentifiers Reimplemented by : datatypes::timeseries::NetCdfEnsembleTimeSeriesStore::GetIdentifiers Updated on 2022-08-20 at 19:28:22 +1000","title":"function GetIdentifiers"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1GlobalAttributes/","text":"datatypes::timeseries::GlobalAttributes \u00b6 A class to hold the global attributes of a file stored in the SWIFT netCDF format. #include <time_series_io.hpp> Public Functions \u00b6 Name GlobalAttributes () GlobalAttributes (const string & title, const string & institution, const string & source, const string & catchment, double stfConventionVersion, const string & stfNcSpec, const string & comment, const string & history) GlobalAttributes ( GlobalAttributes && src) GlobalAttributes (const GlobalAttributes & src) GlobalAttributes & operator= (const GlobalAttributes & src) GlobalAttributes CreateDefault () GlobalAttributes CreateDefault (const string & catchment) Public Attributes \u00b6 Name string Title string Institution string Source string Catchment double STFConventionVersion string STFNCSpec string Comment string History Public Functions Documentation \u00b6 function GlobalAttributes \u00b6 GlobalAttributes () function GlobalAttributes \u00b6 GlobalAttributes ( const string & title , const string & institution , const string & source , const string & catchment , double stfConventionVersion , const string & stfNcSpec , const string & comment , const string & history ) function GlobalAttributes \u00b6 GlobalAttributes ( GlobalAttributes && src ) function GlobalAttributes \u00b6 GlobalAttributes ( const GlobalAttributes & src ) function operator= \u00b6 GlobalAttributes & operator = ( const GlobalAttributes & src ) function CreateDefault \u00b6 static GlobalAttributes CreateDefault () function CreateDefault \u00b6 static GlobalAttributes CreateDefault ( const string & catchment ) Public Attributes Documentation \u00b6 variable Title \u00b6 string Title ; variable Institution \u00b6 string Institution ; variable Source \u00b6 string Source ; variable Catchment \u00b6 string Catchment ; variable STFConventionVersion \u00b6 double STFConventionVersion ; variable STFNCSpec \u00b6 string STFNCSpec ; variable Comment \u00b6 string Comment ; variable History \u00b6 string History ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::GlobalAttributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1GlobalAttributes/#datatypestimeseriesglobalattributes","text":"A class to hold the global attributes of a file stored in the SWIFT netCDF format. #include <time_series_io.hpp>","title":"datatypes::timeseries::GlobalAttributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1GlobalAttributes/#public-functions","text":"Name GlobalAttributes () GlobalAttributes (const string & title, const string & institution, const string & source, const string & catchment, double stfConventionVersion, const string & stfNcSpec, const string & comment, const string & history) GlobalAttributes ( GlobalAttributes && src) GlobalAttributes (const GlobalAttributes & src) GlobalAttributes & operator= (const GlobalAttributes & src) GlobalAttributes CreateDefault () GlobalAttributes CreateDefault (const string & catchment)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1GlobalAttributes/#public-attributes","text":"Name string Title string Institution string Source string Catchment double STFConventionVersion string STFNCSpec string Comment string History","title":"Public Attributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1GlobalAttributes/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1GlobalAttributes/#function-globalattributes","text":"GlobalAttributes ()","title":"function GlobalAttributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1GlobalAttributes/#function-globalattributes_1","text":"GlobalAttributes ( const string & title , const string & institution , const string & source , const string & catchment , double stfConventionVersion , const string & stfNcSpec , const string & comment , const string & history )","title":"function GlobalAttributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1GlobalAttributes/#function-globalattributes_2","text":"GlobalAttributes ( GlobalAttributes && src )","title":"function GlobalAttributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1GlobalAttributes/#function-globalattributes_3","text":"GlobalAttributes ( const GlobalAttributes & src )","title":"function GlobalAttributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1GlobalAttributes/#function-operator","text":"GlobalAttributes & operator = ( const GlobalAttributes & src )","title":"function operator="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1GlobalAttributes/#function-createdefault","text":"static GlobalAttributes CreateDefault ()","title":"function CreateDefault"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1GlobalAttributes/#function-createdefault_1","text":"static GlobalAttributes CreateDefault ( const string & catchment )","title":"function CreateDefault"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1GlobalAttributes/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1GlobalAttributes/#variable-title","text":"string Title ;","title":"variable Title"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1GlobalAttributes/#variable-institution","text":"string Institution ;","title":"variable Institution"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1GlobalAttributes/#variable-source","text":"string Source ;","title":"variable Source"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1GlobalAttributes/#variable-catchment","text":"string Catchment ;","title":"variable Catchment"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1GlobalAttributes/#variable-stfconventionversion","text":"double STFConventionVersion ;","title":"variable STFConventionVersion"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1GlobalAttributes/#variable-stfncspec","text":"string STFNCSpec ;","title":"variable STFNCSpec"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1GlobalAttributes/#variable-comment","text":"string Comment ;","title":"variable Comment"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1GlobalAttributes/#variable-history","text":"string History ; Updated on 2022-08-20 at 19:28:22 +1000","title":"variable History"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IdentifiersProvider/","text":"datatypes::timeseries::IdentifiersProvider \u00b6 An interface definition for objects that can provide hierarchical identification. More... #include <time_series_store.hpp> Inherited by datatypes::timeseries::EnsembleTimeSeriesStore< double > , datatypes::timeseries::SingleTimeSeriesStore< double > , datatypes::timeseries::TimeSeriesProvider< double > , datatypes::timeseries::EnsembleTimeSeriesStore< T > , datatypes::timeseries::SingleTimeSeriesStore< T > , datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T > , datatypes::timeseries::TimeSeriesProvider< T > Public Functions \u00b6 Name virtual ~IdentifiersProvider () virtual vector< string > GetIdentifiers () const =0 vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId) Detailed Description \u00b6 class datatypes :: timeseries :: IdentifiersProvider ; An interface definition for objects that can provide hierarchical identification. A parent class for objects that can provide hierarchical identification. For instance a dot-separated identification scheme such as \"category.subcatcgory.catchment.instant_flow\" Public Functions Documentation \u00b6 function ~IdentifiersProvider \u00b6 inline virtual ~ IdentifiersProvider () function GetIdentifiers \u00b6 virtual vector < string > GetIdentifiers () const = 0 Reimplemented by : datatypes::tests::TestSingleTimeSeriesStore::GetIdentifiers , datatypes::timeseries::NetCdfSingleSeriesStore::GetIdentifiers , datatypes::timeseries::NetCdfEnsembleTimeSeriesStore::GetIdentifiers , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetIdentifiers , datatypes::timeseries::EnsembleTimeSeriesStore::GetIdentifiers , datatypes::timeseries::EnsembleTimeSeriesStore::GetIdentifiers , datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetIdentifiers , datatypes::timeseries::TimeSeriesLibrary::GetIdentifiers function SplitHierarchicalIdentifier \u00b6 static vector < string > SplitHierarchicalIdentifier ( const string & longId ) function GetTopmostIdentifier \u00b6 static string GetTopmostIdentifier ( const string & longId ) function CheckNotEmpty \u00b6 static void CheckNotEmpty ( const string & longId ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::IdentifiersProvider"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IdentifiersProvider/#datatypestimeseriesidentifiersprovider","text":"An interface definition for objects that can provide hierarchical identification. More... #include <time_series_store.hpp> Inherited by datatypes::timeseries::EnsembleTimeSeriesStore< double > , datatypes::timeseries::SingleTimeSeriesStore< double > , datatypes::timeseries::TimeSeriesProvider< double > , datatypes::timeseries::EnsembleTimeSeriesStore< T > , datatypes::timeseries::SingleTimeSeriesStore< T > , datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T > , datatypes::timeseries::TimeSeriesProvider< T >","title":"datatypes::timeseries::IdentifiersProvider"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IdentifiersProvider/#public-functions","text":"Name virtual ~IdentifiersProvider () virtual vector< string > GetIdentifiers () const =0 vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IdentifiersProvider/#detailed-description","text":"class datatypes :: timeseries :: IdentifiersProvider ; An interface definition for objects that can provide hierarchical identification. A parent class for objects that can provide hierarchical identification. For instance a dot-separated identification scheme such as \"category.subcatcgory.catchment.instant_flow\"","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IdentifiersProvider/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IdentifiersProvider/#function-identifiersprovider","text":"inline virtual ~ IdentifiersProvider ()","title":"function ~IdentifiersProvider"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IdentifiersProvider/#function-getidentifiers","text":"virtual vector < string > GetIdentifiers () const = 0 Reimplemented by : datatypes::tests::TestSingleTimeSeriesStore::GetIdentifiers , datatypes::timeseries::NetCdfSingleSeriesStore::GetIdentifiers , datatypes::timeseries::NetCdfEnsembleTimeSeriesStore::GetIdentifiers , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetIdentifiers , datatypes::timeseries::EnsembleTimeSeriesStore::GetIdentifiers , datatypes::timeseries::EnsembleTimeSeriesStore::GetIdentifiers , datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetIdentifiers , datatypes::timeseries::TimeSeriesLibrary::GetIdentifiers","title":"function GetIdentifiers"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IdentifiersProvider/#function-splithierarchicalidentifier","text":"static vector < string > SplitHierarchicalIdentifier ( const string & longId )","title":"function SplitHierarchicalIdentifier"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IdentifiersProvider/#function-gettopmostidentifier","text":"static string GetTopmostIdentifier ( const string & longId )","title":"function GetTopmostIdentifier"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IdentifiersProvider/#function-checknotempty","text":"static void CheckNotEmpty ( const string & longId ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function CheckNotEmpty"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IrregularTimeStepImplementation/","text":"datatypes::timeseries::IrregularTimeStepImplementation \u00b6 #include <time_step_implementation.h> Inherits from datatypes::timeseries::TimeStepImplementation Inherited by datatypes::timeseries::MonthlyQppTimeStepImplementation Public Functions \u00b6 Name virtual ~IrregularTimeStepImplementation () virtual TimeStepImplementation * Clone () =0 virtual bool Equals ( TimeStepImplementation * tsImpl) const =0 virtual TimeStepImplementation * Multiply (int mult) const virtual TimeStepImplementation * Multiply (double mult) const virtual TimeStepImplementation * Divide (int divisor) const virtual const ptime AddIntSteps (const ptime & startTimeStep, int n) const =0 virtual const ptime AddSteps (const ptime & startTimeStep, double mult) const =0 virtual const time_duration GetTimeStepDuration (const ptime & startTimeStep) const virtual const void Increment (ptime * t) const =0 virtual bool IsRegular () const virtual time_duration GetRegularStepDuration () const virtual std::string GetName () const =0 Protected Functions \u00b6 Name virtual const double GetLinearIndexing (const ptime & start, const ptime & end) const =0 Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::TimeStepImplementation Name virtual ~TimeStepImplementation () virtual const ptrdiff_t GetUpperNumSteps (const ptime & start, const ptime & end) const virtual const ptrdiff_t GetNumSteps (const ptime & start, const ptime & end) const virtual const ptrdiff_t GetOffset (const ptime & start, const ptime & end) const void CheckIsDateTime (const ptime & instant) Public Functions Documentation \u00b6 function ~IrregularTimeStepImplementation \u00b6 inline virtual ~ IrregularTimeStepImplementation () function Clone \u00b6 virtual TimeStepImplementation * Clone () = 0 Reimplements : datatypes::timeseries::TimeStepImplementation::Clone Reimplemented by : datatypes::timeseries::MonthlyQppTimeStepImplementation::Clone function Equals \u00b6 virtual bool Equals ( TimeStepImplementation * tsImpl ) const = 0 Reimplements : datatypes::timeseries::TimeStepImplementation::Equals Reimplemented by : datatypes::timeseries::MonthlyQppTimeStepImplementation::Equals function Multiply \u00b6 virtual TimeStepImplementation * Multiply ( int mult ) const Reimplements : datatypes::timeseries::TimeStepImplementation::Multiply function Multiply \u00b6 virtual TimeStepImplementation * Multiply ( double mult ) const Reimplements : datatypes::timeseries::TimeStepImplementation::Multiply function Divide \u00b6 virtual TimeStepImplementation * Divide ( int divisor ) const Reimplements : datatypes::timeseries::TimeStepImplementation::Divide function AddIntSteps \u00b6 virtual const ptime AddIntSteps ( const ptime & startTimeStep , int n ) const = 0 Reimplements : datatypes::timeseries::TimeStepImplementation::AddIntSteps Reimplemented by : datatypes::timeseries::MonthlyQppTimeStepImplementation::AddIntSteps function AddSteps \u00b6 virtual const ptime AddSteps ( const ptime & startTimeStep , double mult ) const = 0 Reimplements : datatypes::timeseries::TimeStepImplementation::AddSteps Reimplemented by : datatypes::timeseries::MonthlyQppTimeStepImplementation::AddSteps function GetTimeStepDuration \u00b6 virtual const time_duration GetTimeStepDuration ( const ptime & startTimeStep ) const Reimplements : datatypes::timeseries::TimeStepImplementation::GetTimeStepDuration Reimplemented by : datatypes::timeseries::MonthlyQppTimeStepImplementation::GetTimeStepDuration function Increment \u00b6 virtual const void Increment ( ptime * t ) const = 0 Reimplements : datatypes::timeseries::TimeStepImplementation::Increment Reimplemented by : datatypes::timeseries::MonthlyQppTimeStepImplementation::Increment function IsRegular \u00b6 virtual bool IsRegular () const Reimplements : datatypes::timeseries::TimeStepImplementation::IsRegular function GetRegularStepDuration \u00b6 virtual time_duration GetRegularStepDuration () const Reimplements : datatypes::timeseries::TimeStepImplementation::GetRegularStepDuration function GetName \u00b6 virtual std :: string GetName () const = 0 Reimplements : datatypes::timeseries::TimeStepImplementation::GetName Reimplemented by : datatypes::timeseries::MonthlyQppTimeStepImplementation::GetName Protected Functions Documentation \u00b6 function GetLinearIndexing \u00b6 virtual const double GetLinearIndexing ( const ptime & start , const ptime & end ) const = 0 Reimplements : datatypes::timeseries::TimeStepImplementation::GetLinearIndexing Reimplemented by : datatypes::timeseries::MonthlyQppTimeStepImplementation::GetLinearIndexing Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::IrregularTimeStepImplementation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IrregularTimeStepImplementation/#datatypestimeseriesirregulartimestepimplementation","text":"#include <time_step_implementation.h> Inherits from datatypes::timeseries::TimeStepImplementation Inherited by datatypes::timeseries::MonthlyQppTimeStepImplementation","title":"datatypes::timeseries::IrregularTimeStepImplementation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IrregularTimeStepImplementation/#public-functions","text":"Name virtual ~IrregularTimeStepImplementation () virtual TimeStepImplementation * Clone () =0 virtual bool Equals ( TimeStepImplementation * tsImpl) const =0 virtual TimeStepImplementation * Multiply (int mult) const virtual TimeStepImplementation * Multiply (double mult) const virtual TimeStepImplementation * Divide (int divisor) const virtual const ptime AddIntSteps (const ptime & startTimeStep, int n) const =0 virtual const ptime AddSteps (const ptime & startTimeStep, double mult) const =0 virtual const time_duration GetTimeStepDuration (const ptime & startTimeStep) const virtual const void Increment (ptime * t) const =0 virtual bool IsRegular () const virtual time_duration GetRegularStepDuration () const virtual std::string GetName () const =0","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IrregularTimeStepImplementation/#protected-functions","text":"Name virtual const double GetLinearIndexing (const ptime & start, const ptime & end) const =0","title":"Protected Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IrregularTimeStepImplementation/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::TimeStepImplementation Name virtual ~TimeStepImplementation () virtual const ptrdiff_t GetUpperNumSteps (const ptime & start, const ptime & end) const virtual const ptrdiff_t GetNumSteps (const ptime & start, const ptime & end) const virtual const ptrdiff_t GetOffset (const ptime & start, const ptime & end) const void CheckIsDateTime (const ptime & instant)","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IrregularTimeStepImplementation/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IrregularTimeStepImplementation/#function-irregulartimestepimplementation","text":"inline virtual ~ IrregularTimeStepImplementation ()","title":"function ~IrregularTimeStepImplementation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IrregularTimeStepImplementation/#function-clone","text":"virtual TimeStepImplementation * Clone () = 0 Reimplements : datatypes::timeseries::TimeStepImplementation::Clone Reimplemented by : datatypes::timeseries::MonthlyQppTimeStepImplementation::Clone","title":"function Clone"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IrregularTimeStepImplementation/#function-equals","text":"virtual bool Equals ( TimeStepImplementation * tsImpl ) const = 0 Reimplements : datatypes::timeseries::TimeStepImplementation::Equals Reimplemented by : datatypes::timeseries::MonthlyQppTimeStepImplementation::Equals","title":"function Equals"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IrregularTimeStepImplementation/#function-multiply","text":"virtual TimeStepImplementation * Multiply ( int mult ) const Reimplements : datatypes::timeseries::TimeStepImplementation::Multiply","title":"function Multiply"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IrregularTimeStepImplementation/#function-multiply_1","text":"virtual TimeStepImplementation * Multiply ( double mult ) const Reimplements : datatypes::timeseries::TimeStepImplementation::Multiply","title":"function Multiply"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IrregularTimeStepImplementation/#function-divide","text":"virtual TimeStepImplementation * Divide ( int divisor ) const Reimplements : datatypes::timeseries::TimeStepImplementation::Divide","title":"function Divide"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IrregularTimeStepImplementation/#function-addintsteps","text":"virtual const ptime AddIntSteps ( const ptime & startTimeStep , int n ) const = 0 Reimplements : datatypes::timeseries::TimeStepImplementation::AddIntSteps Reimplemented by : datatypes::timeseries::MonthlyQppTimeStepImplementation::AddIntSteps","title":"function AddIntSteps"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IrregularTimeStepImplementation/#function-addsteps","text":"virtual const ptime AddSteps ( const ptime & startTimeStep , double mult ) const = 0 Reimplements : datatypes::timeseries::TimeStepImplementation::AddSteps Reimplemented by : datatypes::timeseries::MonthlyQppTimeStepImplementation::AddSteps","title":"function AddSteps"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IrregularTimeStepImplementation/#function-gettimestepduration","text":"virtual const time_duration GetTimeStepDuration ( const ptime & startTimeStep ) const Reimplements : datatypes::timeseries::TimeStepImplementation::GetTimeStepDuration Reimplemented by : datatypes::timeseries::MonthlyQppTimeStepImplementation::GetTimeStepDuration","title":"function GetTimeStepDuration"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IrregularTimeStepImplementation/#function-increment","text":"virtual const void Increment ( ptime * t ) const = 0 Reimplements : datatypes::timeseries::TimeStepImplementation::Increment Reimplemented by : datatypes::timeseries::MonthlyQppTimeStepImplementation::Increment","title":"function Increment"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IrregularTimeStepImplementation/#function-isregular","text":"virtual bool IsRegular () const Reimplements : datatypes::timeseries::TimeStepImplementation::IsRegular","title":"function IsRegular"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IrregularTimeStepImplementation/#function-getregularstepduration","text":"virtual time_duration GetRegularStepDuration () const Reimplements : datatypes::timeseries::TimeStepImplementation::GetRegularStepDuration","title":"function GetRegularStepDuration"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IrregularTimeStepImplementation/#function-getname","text":"virtual std :: string GetName () const = 0 Reimplements : datatypes::timeseries::TimeStepImplementation::GetName Reimplemented by : datatypes::timeseries::MonthlyQppTimeStepImplementation::GetName","title":"function GetName"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IrregularTimeStepImplementation/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1IrregularTimeStepImplementation/#function-getlinearindexing","text":"virtual const double GetLinearIndexing ( const ptime & start , const ptime & end ) const = 0 Reimplements : datatypes::timeseries::TimeStepImplementation::GetLinearIndexing Reimplemented by : datatypes::timeseries::MonthlyQppTimeStepImplementation::GetLinearIndexing Updated on 2022-08-20 at 19:28:22 +1000","title":"function GetLinearIndexing"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/","text":"datatypes::timeseries::MemoryCachingStorageWriter \u00b6 More... #include <time_series_strategies.hpp> Inherits from datatypes::timeseries::StoragePolicy< double > , datatypes::timeseries::TimeSeriesInfoProvider Public Functions \u00b6 Name MemoryCachingStorageWriter (size_t bufferSize, StoragePolicy < T > * wrappedStorage) T & GetWindowItem (size_t i) T & GetBackendItem (size_t i) virtual size_t Size () const virtual size_t GetLength () const virtual TimeStep GetTimeStep () const override virtual ptime GetStart () const override virtual void SetTimeStep (const TimeStep & tStep) override virtual void SetStart (const ptime & start) override void ResetBuffer () void Allocate (size_t length, T value) void AllocateValues (size_t length, const T * values) void AllocateValues (const vector< T > & values) void CopyTo (vector< T > & dest, size_t from =0, size_t to =-1) const virtual T & operator[] (const size_t i) virtual const T & operator[] (const size_t i) const virtual StoragePolicy < T > * Clone () const Protected Functions \u00b6 Name MemoryCachingStorageWriter (const MemoryCachingStorageWriter & src) Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::StoragePolicy< double > Name virtual ~StoragePolicy () virtual bool ReadOnly () Protected Functions inherited from datatypes::timeseries::StoragePolicy< double > Name StoragePolicy (const StoragePolicy & src) StoragePolicy () Public Functions inherited from datatypes::timeseries::TimeSeriesInfoProvider Name virtual ~TimeSeriesInfoProvider () Detailed Description \u00b6 template < typename T = double > class datatypes :: timeseries :: MemoryCachingStorageWriter ; Public Functions Documentation \u00b6 function MemoryCachingStorageWriter \u00b6 inline MemoryCachingStorageWriter ( size_t bufferSize , StoragePolicy < T > * wrappedStorage ) function GetWindowItem \u00b6 inline T & GetWindowItem ( size_t i ) function GetBackendItem \u00b6 inline T & GetBackendItem ( size_t i ) function Size \u00b6 inline virtual size_t Size () const Reimplements : datatypes::timeseries::StoragePolicy::Size function GetLength \u00b6 inline virtual size_t GetLength () const Reimplements : datatypes::timeseries::TimeSeriesInfoProvider::GetLength function GetTimeStep \u00b6 inline virtual TimeStep GetTimeStep () const override Reimplements : datatypes::timeseries::StoragePolicy::GetTimeStep function GetStart \u00b6 inline virtual ptime GetStart () const override Reimplements : datatypes::timeseries::StoragePolicy::GetStart function SetTimeStep \u00b6 inline virtual void SetTimeStep ( const TimeStep & tStep ) override Reimplements : datatypes::timeseries::StoragePolicy::SetTimeStep function SetStart \u00b6 inline virtual void SetStart ( const ptime & start ) override Reimplements : datatypes::timeseries::StoragePolicy::SetStart function ResetBuffer \u00b6 inline void ResetBuffer () function Allocate \u00b6 inline void Allocate ( size_t length , T value ) function AllocateValues \u00b6 inline void AllocateValues ( size_t length , const T * values ) function AllocateValues \u00b6 inline void AllocateValues ( const vector < T > & values ) function CopyTo \u00b6 inline void CopyTo ( vector < T > & dest , size_t from = 0 , size_t to = -1 ) const function operator[] \u00b6 inline virtual T & operator []( const size_t i ) Reimplements : datatypes::timeseries::StoragePolicy::operator[] function operator[] \u00b6 inline virtual const T & operator []( const size_t i ) const Reimplements : datatypes::timeseries::StoragePolicy::operator[] function Clone \u00b6 inline virtual StoragePolicy < T > * Clone () const Reimplements : datatypes::timeseries::StoragePolicy::Clone Protected Functions Documentation \u00b6 function MemoryCachingStorageWriter \u00b6 inline MemoryCachingStorageWriter ( const MemoryCachingStorageWriter & src ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::MemoryCachingStorageWriter"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#datatypestimeseriesmemorycachingstoragewriter","text":"More... #include <time_series_strategies.hpp> Inherits from datatypes::timeseries::StoragePolicy< double > , datatypes::timeseries::TimeSeriesInfoProvider","title":"datatypes::timeseries::MemoryCachingStorageWriter"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#public-functions","text":"Name MemoryCachingStorageWriter (size_t bufferSize, StoragePolicy < T > * wrappedStorage) T & GetWindowItem (size_t i) T & GetBackendItem (size_t i) virtual size_t Size () const virtual size_t GetLength () const virtual TimeStep GetTimeStep () const override virtual ptime GetStart () const override virtual void SetTimeStep (const TimeStep & tStep) override virtual void SetStart (const ptime & start) override void ResetBuffer () void Allocate (size_t length, T value) void AllocateValues (size_t length, const T * values) void AllocateValues (const vector< T > & values) void CopyTo (vector< T > & dest, size_t from =0, size_t to =-1) const virtual T & operator[] (const size_t i) virtual const T & operator[] (const size_t i) const virtual StoragePolicy < T > * Clone () const","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#protected-functions","text":"Name MemoryCachingStorageWriter (const MemoryCachingStorageWriter & src)","title":"Protected Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::StoragePolicy< double > Name virtual ~StoragePolicy () virtual bool ReadOnly () Protected Functions inherited from datatypes::timeseries::StoragePolicy< double > Name StoragePolicy (const StoragePolicy & src) StoragePolicy () Public Functions inherited from datatypes::timeseries::TimeSeriesInfoProvider Name virtual ~TimeSeriesInfoProvider ()","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#detailed-description","text":"template < typename T = double > class datatypes :: timeseries :: MemoryCachingStorageWriter ;","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#function-memorycachingstoragewriter","text":"inline MemoryCachingStorageWriter ( size_t bufferSize , StoragePolicy < T > * wrappedStorage )","title":"function MemoryCachingStorageWriter"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#function-getwindowitem","text":"inline T & GetWindowItem ( size_t i )","title":"function GetWindowItem"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#function-getbackenditem","text":"inline T & GetBackendItem ( size_t i )","title":"function GetBackendItem"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#function-size","text":"inline virtual size_t Size () const Reimplements : datatypes::timeseries::StoragePolicy::Size","title":"function Size"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#function-getlength","text":"inline virtual size_t GetLength () const Reimplements : datatypes::timeseries::TimeSeriesInfoProvider::GetLength","title":"function GetLength"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#function-gettimestep","text":"inline virtual TimeStep GetTimeStep () const override Reimplements : datatypes::timeseries::StoragePolicy::GetTimeStep","title":"function GetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#function-getstart","text":"inline virtual ptime GetStart () const override Reimplements : datatypes::timeseries::StoragePolicy::GetStart","title":"function GetStart"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#function-settimestep","text":"inline virtual void SetTimeStep ( const TimeStep & tStep ) override Reimplements : datatypes::timeseries::StoragePolicy::SetTimeStep","title":"function SetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#function-setstart","text":"inline virtual void SetStart ( const ptime & start ) override Reimplements : datatypes::timeseries::StoragePolicy::SetStart","title":"function SetStart"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#function-resetbuffer","text":"inline void ResetBuffer ()","title":"function ResetBuffer"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#function-allocate","text":"inline void Allocate ( size_t length , T value )","title":"function Allocate"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#function-allocatevalues","text":"inline void AllocateValues ( size_t length , const T * values )","title":"function AllocateValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#function-allocatevalues_1","text":"inline void AllocateValues ( const vector < T > & values )","title":"function AllocateValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#function-copyto","text":"inline void CopyTo ( vector < T > & dest , size_t from = 0 , size_t to = -1 ) const","title":"function CopyTo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#function-operator","text":"inline virtual T & operator []( const size_t i ) Reimplements : datatypes::timeseries::StoragePolicy::operator[]","title":"function operator[]"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#function-operator_1","text":"inline virtual const T & operator []( const size_t i ) const Reimplements : datatypes::timeseries::StoragePolicy::operator[]","title":"function operator[]"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#function-clone","text":"inline virtual StoragePolicy < T > * Clone () const Reimplements : datatypes::timeseries::StoragePolicy::Clone","title":"function Clone"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MemoryCachingStorageWriter/#function-memorycachingstoragewriter_1","text":"inline MemoryCachingStorageWriter ( const MemoryCachingStorageWriter & src ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function MemoryCachingStorageWriter"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MissingValuePolicy/","text":"datatypes::timeseries::MissingValuePolicy \u00b6 An interface for classes that define missing values in time series. More... #include <time_series_strategies.hpp> Inherited by datatypes::timeseries::NullPointerIsMissingPolicy< T > Public Functions \u00b6 Name virtual ~MissingValuePolicy () virtual bool IsMissingValue (const T & a) const =0 virtual T GetMissingValue () const =0 virtual MissingValuePolicy * Clone () const =0 Detailed Description \u00b6 template < typename T > class datatypes :: timeseries :: MissingValuePolicy ; An interface for classes that define missing values in time series. Template Parameters : T Generic type parameter. Public Functions Documentation \u00b6 function ~MissingValuePolicy \u00b6 inline virtual ~ MissingValuePolicy () function IsMissingValue \u00b6 virtual bool IsMissingValue ( const T & a ) const = 0 Reimplemented by : datatypes::timeseries::NullPointerIsMissingPolicy::IsMissingValue function GetMissingValue \u00b6 virtual T GetMissingValue () const = 0 Reimplemented by : datatypes::timeseries::DefaultMissingFloatingPointPolicy::GetMissingValue , datatypes::timeseries::NullPointerIsMissingPolicy::GetMissingValue , datatypes::timeseries::NegativeIsMissingFloadingPointPolicy::GetMissingValue function Clone \u00b6 virtual MissingValuePolicy * Clone () const = 0 Reimplemented by : datatypes::timeseries::DefaultMissingFloatingPointPolicy::Clone , datatypes::timeseries::NullPointerIsMissingPolicy::Clone , datatypes::timeseries::NegativeIsMissingFloadingPointPolicy::Clone Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::MissingValuePolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MissingValuePolicy/#datatypestimeseriesmissingvaluepolicy","text":"An interface for classes that define missing values in time series. More... #include <time_series_strategies.hpp> Inherited by datatypes::timeseries::NullPointerIsMissingPolicy< T >","title":"datatypes::timeseries::MissingValuePolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MissingValuePolicy/#public-functions","text":"Name virtual ~MissingValuePolicy () virtual bool IsMissingValue (const T & a) const =0 virtual T GetMissingValue () const =0 virtual MissingValuePolicy * Clone () const =0","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MissingValuePolicy/#detailed-description","text":"template < typename T > class datatypes :: timeseries :: MissingValuePolicy ; An interface for classes that define missing values in time series. Template Parameters : T Generic type parameter.","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MissingValuePolicy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MissingValuePolicy/#function-missingvaluepolicy","text":"inline virtual ~ MissingValuePolicy ()","title":"function ~MissingValuePolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MissingValuePolicy/#function-ismissingvalue","text":"virtual bool IsMissingValue ( const T & a ) const = 0 Reimplemented by : datatypes::timeseries::NullPointerIsMissingPolicy::IsMissingValue","title":"function IsMissingValue"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MissingValuePolicy/#function-getmissingvalue","text":"virtual T GetMissingValue () const = 0 Reimplemented by : datatypes::timeseries::DefaultMissingFloatingPointPolicy::GetMissingValue , datatypes::timeseries::NullPointerIsMissingPolicy::GetMissingValue , datatypes::timeseries::NegativeIsMissingFloadingPointPolicy::GetMissingValue","title":"function GetMissingValue"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MissingValuePolicy/#function-clone","text":"virtual MissingValuePolicy * Clone () const = 0 Reimplemented by : datatypes::timeseries::DefaultMissingFloatingPointPolicy::Clone , datatypes::timeseries::NullPointerIsMissingPolicy::Clone , datatypes::timeseries::NegativeIsMissingFloadingPointPolicy::Clone Updated on 2022-08-20 at 19:28:22 +1000","title":"function Clone"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MonthlyQppTimeStepImplementation/","text":"datatypes::timeseries::MonthlyQppTimeStepImplementation \u00b6 #include <time_step_implementation.h> Inherits from datatypes::timeseries::IrregularTimeStepImplementation , datatypes::timeseries::TimeStepImplementation Public Functions \u00b6 Name virtual ~MonthlyQppTimeStepImplementation () virtual TimeStepImplementation * Clone () virtual bool Equals ( TimeStepImplementation * tsImpl) const virtual const ptime AddIntSteps (const ptime & startTimeStep, int n) const virtual const ptime AddSteps (const ptime & startTimeStep, double mult) const virtual const time_duration GetTimeStepDuration (const ptime & startTimeStep) const override virtual const void Increment (ptime * t) const virtual std::string GetName () const Protected Functions \u00b6 Name virtual const double GetLinearIndexing (const ptime & start, const ptime & end) const Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::IrregularTimeStepImplementation Name virtual ~IrregularTimeStepImplementation () virtual TimeStepImplementation * Multiply (int mult) const virtual TimeStepImplementation * Multiply (double mult) const virtual TimeStepImplementation * Divide (int divisor) const virtual bool IsRegular () const virtual time_duration GetRegularStepDuration () const Public Functions inherited from datatypes::timeseries::TimeStepImplementation Name virtual ~TimeStepImplementation () virtual TimeStepImplementation * Multiply (int mult) const =0 virtual TimeStepImplementation * Divide (int divisor) const =0 virtual TimeStepImplementation * Multiply (double mult) const =0 virtual const ptrdiff_t GetUpperNumSteps (const ptime & start, const ptime & end) const virtual const ptrdiff_t GetNumSteps (const ptime & start, const ptime & end) const virtual const ptrdiff_t GetOffset (const ptime & start, const ptime & end) const virtual bool IsRegular () const =0 virtual time_duration GetRegularStepDuration () const =0 void CheckIsDateTime (const ptime & instant) Public Functions Documentation \u00b6 function ~MonthlyQppTimeStepImplementation \u00b6 inline virtual ~ MonthlyQppTimeStepImplementation () function Clone \u00b6 virtual TimeStepImplementation * Clone () Reimplements : datatypes::timeseries::IrregularTimeStepImplementation::Clone function Equals \u00b6 virtual bool Equals ( TimeStepImplementation * tsImpl ) const Reimplements : datatypes::timeseries::IrregularTimeStepImplementation::Equals function AddIntSteps \u00b6 virtual const ptime AddIntSteps ( const ptime & startTimeStep , int n ) const Reimplements : datatypes::timeseries::IrregularTimeStepImplementation::AddIntSteps function AddSteps \u00b6 virtual const ptime AddSteps ( const ptime & startTimeStep , double mult ) const Reimplements : datatypes::timeseries::IrregularTimeStepImplementation::AddSteps function GetTimeStepDuration \u00b6 virtual const time_duration GetTimeStepDuration ( const ptime & startTimeStep ) const override Reimplements : datatypes::timeseries::IrregularTimeStepImplementation::GetTimeStepDuration function Increment \u00b6 virtual const void Increment ( ptime * t ) const Reimplements : datatypes::timeseries::IrregularTimeStepImplementation::Increment function GetName \u00b6 virtual std :: string GetName () const Reimplements : datatypes::timeseries::IrregularTimeStepImplementation::GetName Protected Functions Documentation \u00b6 function GetLinearIndexing \u00b6 virtual const double GetLinearIndexing ( const ptime & start , const ptime & end ) const Reimplements : datatypes::timeseries::IrregularTimeStepImplementation::GetLinearIndexing Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::MonthlyQppTimeStepImplementation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MonthlyQppTimeStepImplementation/#datatypestimeseriesmonthlyqpptimestepimplementation","text":"#include <time_step_implementation.h> Inherits from datatypes::timeseries::IrregularTimeStepImplementation , datatypes::timeseries::TimeStepImplementation","title":"datatypes::timeseries::MonthlyQppTimeStepImplementation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MonthlyQppTimeStepImplementation/#public-functions","text":"Name virtual ~MonthlyQppTimeStepImplementation () virtual TimeStepImplementation * Clone () virtual bool Equals ( TimeStepImplementation * tsImpl) const virtual const ptime AddIntSteps (const ptime & startTimeStep, int n) const virtual const ptime AddSteps (const ptime & startTimeStep, double mult) const virtual const time_duration GetTimeStepDuration (const ptime & startTimeStep) const override virtual const void Increment (ptime * t) const virtual std::string GetName () const","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MonthlyQppTimeStepImplementation/#protected-functions","text":"Name virtual const double GetLinearIndexing (const ptime & start, const ptime & end) const","title":"Protected Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MonthlyQppTimeStepImplementation/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::IrregularTimeStepImplementation Name virtual ~IrregularTimeStepImplementation () virtual TimeStepImplementation * Multiply (int mult) const virtual TimeStepImplementation * Multiply (double mult) const virtual TimeStepImplementation * Divide (int divisor) const virtual bool IsRegular () const virtual time_duration GetRegularStepDuration () const Public Functions inherited from datatypes::timeseries::TimeStepImplementation Name virtual ~TimeStepImplementation () virtual TimeStepImplementation * Multiply (int mult) const =0 virtual TimeStepImplementation * Divide (int divisor) const =0 virtual TimeStepImplementation * Multiply (double mult) const =0 virtual const ptrdiff_t GetUpperNumSteps (const ptime & start, const ptime & end) const virtual const ptrdiff_t GetNumSteps (const ptime & start, const ptime & end) const virtual const ptrdiff_t GetOffset (const ptime & start, const ptime & end) const virtual bool IsRegular () const =0 virtual time_duration GetRegularStepDuration () const =0 void CheckIsDateTime (const ptime & instant)","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MonthlyQppTimeStepImplementation/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MonthlyQppTimeStepImplementation/#function-monthlyqpptimestepimplementation","text":"inline virtual ~ MonthlyQppTimeStepImplementation ()","title":"function ~MonthlyQppTimeStepImplementation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MonthlyQppTimeStepImplementation/#function-clone","text":"virtual TimeStepImplementation * Clone () Reimplements : datatypes::timeseries::IrregularTimeStepImplementation::Clone","title":"function Clone"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MonthlyQppTimeStepImplementation/#function-equals","text":"virtual bool Equals ( TimeStepImplementation * tsImpl ) const Reimplements : datatypes::timeseries::IrregularTimeStepImplementation::Equals","title":"function Equals"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MonthlyQppTimeStepImplementation/#function-addintsteps","text":"virtual const ptime AddIntSteps ( const ptime & startTimeStep , int n ) const Reimplements : datatypes::timeseries::IrregularTimeStepImplementation::AddIntSteps","title":"function AddIntSteps"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MonthlyQppTimeStepImplementation/#function-addsteps","text":"virtual const ptime AddSteps ( const ptime & startTimeStep , double mult ) const Reimplements : datatypes::timeseries::IrregularTimeStepImplementation::AddSteps","title":"function AddSteps"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MonthlyQppTimeStepImplementation/#function-gettimestepduration","text":"virtual const time_duration GetTimeStepDuration ( const ptime & startTimeStep ) const override Reimplements : datatypes::timeseries::IrregularTimeStepImplementation::GetTimeStepDuration","title":"function GetTimeStepDuration"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MonthlyQppTimeStepImplementation/#function-increment","text":"virtual const void Increment ( ptime * t ) const Reimplements : datatypes::timeseries::IrregularTimeStepImplementation::Increment","title":"function Increment"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MonthlyQppTimeStepImplementation/#function-getname","text":"virtual std :: string GetName () const Reimplements : datatypes::timeseries::IrregularTimeStepImplementation::GetName","title":"function GetName"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MonthlyQppTimeStepImplementation/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MonthlyQppTimeStepImplementation/#function-getlinearindexing","text":"virtual const double GetLinearIndexing ( const ptime & start , const ptime & end ) const Reimplements : datatypes::timeseries::IrregularTimeStepImplementation::GetLinearIndexing Updated on 2022-08-20 at 19:28:22 +1000","title":"function GetLinearIndexing"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/","text":"datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore \u00b6 An implementation of TimeSeriesEnsembleTimeSeriesStore such that the content of a time series is spread amongst several files. More... #include <time_series_io.hpp> Inherits from datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T > , datatypes::timeseries::IdentifiersProvider , datatypes::timeseries::TimeSeriesInfoProvider , datatypes::timeseries::DataDescriptor Public Types \u00b6 Name using typename CommonTypes < T >:: SeriesType SeriesType Public Functions \u00b6 Name MultiFileTimeSeriesEnsembleTimeSeriesStore () Default constructor. Needed for class member properties; should otherwise not be used. MultiFileTimeSeriesEnsembleTimeSeriesStore (const string & forecastDataFiles, const string & varName, const string & varIdentifier, int index, const TimeStep & timeStep, const ptime & start, int length, int ensembleSize, int ensembleLength, const TimeStep & ensembleTimeStep) virtual ~MultiFileTimeSeriesEnsembleTimeSeriesStore () virtual EnsembleForecastTimeSeries < SeriesType > * GetSeries (const string & dataId) virtual MultiTimeSeries < SeriesType * > * Read (const string & fileIdentifier) override MultiTimeSeries < SeriesType * > * ReadAt (size_t index) const virtual size_t GetLength () const virtual TimeStep GetTimeStep () const virtual ptime GetStart () const ptime GetEnd () const string ShortFileNamePattern () const virtual string GetDataSummary () const virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const Public Attributes \u00b6 Name string DatePattern string FileNamePattern Additional inherited members \u00b6 Public Types inherited from datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T > Name using typename CommonTypes < T >:: PtrSeriesType PtrSeriesType using typename CommonTypes < T >:: EnsemblePtrType EnsemblePtrType using typename CommonTypes < T >:: PtrEnsemblePtrType PtrEnsemblePtrType using typename CommonTypes < T >:: TSeriesEnsemblePtrType TSeriesEnsemblePtrType using typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType PtrTSeriesEnsemblePtrType Public Functions inherited from datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T > Name virtual ~TimeSeriesEnsembleTimeSeriesStore () virtual PtrEnsemblePtrType GetItem (const string & dataId, size_t fcastIndex) virtual PtrSeriesType GetItem (const string & dataId, size_t fcastIndex, size_t ensIndex) virtual size_t GetEnsembleSize (const string & dataId, size_t fcastIndex) const virtual vector< string > GetIdentifiers () const Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () virtual vector< string > GetIdentifiers () const =0 vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId) Public Functions inherited from datatypes::timeseries::TimeSeriesInfoProvider Name virtual ~TimeSeriesInfoProvider () Detailed Description \u00b6 template < typename T > class datatypes :: timeseries :: MultiFileTimeSeriesEnsembleTimeSeriesStore ; An implementation of TimeSeriesEnsembleTimeSeriesStore such that the content of a time series is spread amongst several files. Template Parameters : T The type of each data item this can handle. Public Types Documentation \u00b6 using SeriesType \u00b6 using datatypes :: timeseries :: MultiFileTimeSeriesEnsembleTimeSeriesStore < T >:: SeriesType = typename CommonTypes < T >:: SeriesType ; Public Functions Documentation \u00b6 function MultiFileTimeSeriesEnsembleTimeSeriesStore \u00b6 inline MultiFileTimeSeriesEnsembleTimeSeriesStore () Default constructor. Needed for class member properties; should otherwise not be used. function MultiFileTimeSeriesEnsembleTimeSeriesStore \u00b6 inline MultiFileTimeSeriesEnsembleTimeSeriesStore ( const string & forecastDataFiles , const string & varName , const string & varIdentifier , int index , const TimeStep & timeStep , const ptime & start , int length , int ensembleSize , int ensembleLength , const TimeStep & ensembleTimeStep ) function ~MultiFileTimeSeriesEnsembleTimeSeriesStore \u00b6 inline virtual ~ MultiFileTimeSeriesEnsembleTimeSeriesStore () function GetSeries \u00b6 inline virtual EnsembleForecastTimeSeries < SeriesType > * GetSeries ( const string & dataId ) Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetSeries function Read \u00b6 inline virtual MultiTimeSeries < SeriesType * > * Read ( const string & fileIdentifier ) override Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::Read function ReadAt \u00b6 inline MultiTimeSeries < SeriesType * > * ReadAt ( size_t index ) const function GetLength \u00b6 inline virtual size_t GetLength () const Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetLength function GetTimeStep \u00b6 inline virtual TimeStep GetTimeStep () const Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetTimeStep function GetStart \u00b6 inline virtual ptime GetStart () const Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetStart function GetEnd \u00b6 inline ptime GetEnd () const function ShortFileNamePattern \u00b6 inline string ShortFileNamePattern () const function GetDataSummary \u00b6 inline virtual string GetDataSummary () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataSummary function GetDataDimensionsDescription \u00b6 inline virtual vector < DataDimensionDescriptor > GetDataDimensionsDescription () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataDimensionsDescription Public Attributes Documentation \u00b6 variable DatePattern \u00b6 string DatePattern = \"YYYYMMDD\" ; variable FileNamePattern \u00b6 string FileNamePattern = datatypes :: io :: IoHelper :: DefaultFilePattern ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#datatypestimeseriesmultifiletimeseriesensembletimeseriesstore","text":"An implementation of TimeSeriesEnsembleTimeSeriesStore such that the content of a time series is spread amongst several files. More... #include <time_series_io.hpp> Inherits from datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T > , datatypes::timeseries::IdentifiersProvider , datatypes::timeseries::TimeSeriesInfoProvider , datatypes::timeseries::DataDescriptor","title":"datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#public-types","text":"Name using typename CommonTypes < T >:: SeriesType SeriesType","title":"Public Types"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#public-functions","text":"Name MultiFileTimeSeriesEnsembleTimeSeriesStore () Default constructor. Needed for class member properties; should otherwise not be used. MultiFileTimeSeriesEnsembleTimeSeriesStore (const string & forecastDataFiles, const string & varName, const string & varIdentifier, int index, const TimeStep & timeStep, const ptime & start, int length, int ensembleSize, int ensembleLength, const TimeStep & ensembleTimeStep) virtual ~MultiFileTimeSeriesEnsembleTimeSeriesStore () virtual EnsembleForecastTimeSeries < SeriesType > * GetSeries (const string & dataId) virtual MultiTimeSeries < SeriesType * > * Read (const string & fileIdentifier) override MultiTimeSeries < SeriesType * > * ReadAt (size_t index) const virtual size_t GetLength () const virtual TimeStep GetTimeStep () const virtual ptime GetStart () const ptime GetEnd () const string ShortFileNamePattern () const virtual string GetDataSummary () const virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#public-attributes","text":"Name string DatePattern string FileNamePattern","title":"Public Attributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#additional-inherited-members","text":"Public Types inherited from datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T > Name using typename CommonTypes < T >:: PtrSeriesType PtrSeriesType using typename CommonTypes < T >:: EnsemblePtrType EnsemblePtrType using typename CommonTypes < T >:: PtrEnsemblePtrType PtrEnsemblePtrType using typename CommonTypes < T >:: TSeriesEnsemblePtrType TSeriesEnsemblePtrType using typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType PtrTSeriesEnsemblePtrType Public Functions inherited from datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T > Name virtual ~TimeSeriesEnsembleTimeSeriesStore () virtual PtrEnsemblePtrType GetItem (const string & dataId, size_t fcastIndex) virtual PtrSeriesType GetItem (const string & dataId, size_t fcastIndex, size_t ensIndex) virtual size_t GetEnsembleSize (const string & dataId, size_t fcastIndex) const virtual vector< string > GetIdentifiers () const Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () virtual vector< string > GetIdentifiers () const =0 vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId) Public Functions inherited from datatypes::timeseries::TimeSeriesInfoProvider Name virtual ~TimeSeriesInfoProvider ()","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#detailed-description","text":"template < typename T > class datatypes :: timeseries :: MultiFileTimeSeriesEnsembleTimeSeriesStore ; An implementation of TimeSeriesEnsembleTimeSeriesStore such that the content of a time series is spread amongst several files. Template Parameters : T The type of each data item this can handle.","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#using-seriestype","text":"using datatypes :: timeseries :: MultiFileTimeSeriesEnsembleTimeSeriesStore < T >:: SeriesType = typename CommonTypes < T >:: SeriesType ;","title":"using SeriesType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#function-multifiletimeseriesensembletimeseriesstore","text":"inline MultiFileTimeSeriesEnsembleTimeSeriesStore () Default constructor. Needed for class member properties; should otherwise not be used.","title":"function MultiFileTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#function-multifiletimeseriesensembletimeseriesstore_1","text":"inline MultiFileTimeSeriesEnsembleTimeSeriesStore ( const string & forecastDataFiles , const string & varName , const string & varIdentifier , int index , const TimeStep & timeStep , const ptime & start , int length , int ensembleSize , int ensembleLength , const TimeStep & ensembleTimeStep )","title":"function MultiFileTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#function-multifiletimeseriesensembletimeseriesstore_2","text":"inline virtual ~ MultiFileTimeSeriesEnsembleTimeSeriesStore ()","title":"function ~MultiFileTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#function-getseries","text":"inline virtual EnsembleForecastTimeSeries < SeriesType > * GetSeries ( const string & dataId ) Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetSeries","title":"function GetSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#function-read","text":"inline virtual MultiTimeSeries < SeriesType * > * Read ( const string & fileIdentifier ) override Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::Read","title":"function Read"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#function-readat","text":"inline MultiTimeSeries < SeriesType * > * ReadAt ( size_t index ) const","title":"function ReadAt"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#function-getlength","text":"inline virtual size_t GetLength () const Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetLength","title":"function GetLength"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#function-gettimestep","text":"inline virtual TimeStep GetTimeStep () const Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetTimeStep","title":"function GetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#function-getstart","text":"inline virtual ptime GetStart () const Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetStart","title":"function GetStart"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#function-getend","text":"inline ptime GetEnd () const","title":"function GetEnd"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#function-shortfilenamepattern","text":"inline string ShortFileNamePattern () const","title":"function ShortFileNamePattern"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#function-getdatasummary","text":"inline virtual string GetDataSummary () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataSummary","title":"function GetDataSummary"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#function-getdatadimensionsdescription","text":"inline virtual vector < DataDimensionDescriptor > GetDataDimensionsDescription () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataDimensionsDescription","title":"function GetDataDimensionsDescription"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#variable-datepattern","text":"string DatePattern = \"YYYYMMDD\" ;","title":"variable DatePattern"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTimeSeriesEnsembleTimeSeriesStore/#variable-filenamepattern","text":"string FileNamePattern = datatypes :: io :: IoHelper :: DefaultFilePattern ; Updated on 2022-08-20 at 19:28:22 +1000","title":"variable FileNamePattern"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/","text":"datatypes::timeseries::MultiFileTsStorage \u00b6 An implementation of StoragePolicy such that the content of a time series is spread amongst several files. More... #include <time_series_io.hpp> Inherits from datatypes::timeseries::StoragePolicy< T > , datatypes::timeseries::TimeSeriesInfoProvider Public Types \u00b6 Name typedef std::remove_pointer< T >::type::ElementType ElementType Public Functions \u00b6 Name MultiFileTsStorage (const MultiFileTimeSeriesEnsembleTimeSeriesStore < ElementType > & storage, const string & dataIdentifier, bool readOnly =true) virtual bool ReadOnly () override virtual size_t Size () const void ReserveVectorData (size_t length) virtual void Allocate (size_t length, T value) virtual void AllocateValues (size_t length, const T * values) virtual void AllocateValues (const vector< T > & values) virtual void CopyTo (vector< T > & dest, size_t from =0, size_t to =-1) const virtual T & operator[] (const size_t i) virtual const T & operator[] (const size_t i) const virtual StoragePolicy < T > * Clone () const virtual size_t GetLength () const virtual TimeStep GetTimeStep () const override virtual ptime GetStart () const override virtual void SetTimeStep (const TimeStep & tStep) override virtual void SetStart (const ptime & start) override Public Attributes \u00b6 Name vector< T > data bool readOnly Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::StoragePolicy< T > Name virtual ~StoragePolicy () Protected Functions inherited from datatypes::timeseries::StoragePolicy< T > Name StoragePolicy (const StoragePolicy & src) StoragePolicy () Public Functions inherited from datatypes::timeseries::TimeSeriesInfoProvider Name virtual ~TimeSeriesInfoProvider () Detailed Description \u00b6 template < typename T > class datatypes :: timeseries :: MultiFileTsStorage ; An implementation of StoragePolicy such that the content of a time series is spread amongst several files. Template Parameters : T The type of each data item this can handle. Public Types Documentation \u00b6 typedef ElementType \u00b6 typedef std :: remove_pointer < T >:: type :: ElementType datatypes :: timeseries :: MultiFileTsStorage < T >:: ElementType ; Public Functions Documentation \u00b6 function MultiFileTsStorage \u00b6 inline MultiFileTsStorage ( const MultiFileTimeSeriesEnsembleTimeSeriesStore < ElementType > & storage , const string & dataIdentifier , bool readOnly = true ) function ReadOnly \u00b6 inline virtual bool ReadOnly () override Reimplements : datatypes::timeseries::StoragePolicy::ReadOnly function Size \u00b6 inline virtual size_t Size () const Reimplements : datatypes::timeseries::StoragePolicy::Size function ReserveVectorData \u00b6 inline void ReserveVectorData ( size_t length ) function Allocate \u00b6 inline virtual void Allocate ( size_t length , T value ) Reimplements : datatypes::timeseries::StoragePolicy::Allocate function AllocateValues \u00b6 inline virtual void AllocateValues ( size_t length , const T * values ) Reimplements : datatypes::timeseries::StoragePolicy::AllocateValues function AllocateValues \u00b6 inline virtual void AllocateValues ( const vector < T > & values ) Reimplements : datatypes::timeseries::StoragePolicy::AllocateValues function CopyTo \u00b6 inline virtual void CopyTo ( vector < T > & dest , size_t from = 0 , size_t to = -1 ) const Reimplements : datatypes::timeseries::StoragePolicy::CopyTo function operator[] \u00b6 inline virtual T & operator []( const size_t i ) Reimplements : datatypes::timeseries::StoragePolicy::operator[] function operator[] \u00b6 inline virtual const T & operator []( const size_t i ) const Reimplements : datatypes::timeseries::StoragePolicy::operator[] function Clone \u00b6 inline virtual StoragePolicy < T > * Clone () const Reimplements : datatypes::timeseries::StoragePolicy::Clone function GetLength \u00b6 inline virtual size_t GetLength () const Reimplements : datatypes::timeseries::TimeSeriesInfoProvider::GetLength function GetTimeStep \u00b6 inline virtual TimeStep GetTimeStep () const override Reimplements : datatypes::timeseries::StoragePolicy::GetTimeStep function GetStart \u00b6 inline virtual ptime GetStart () const override Reimplements : datatypes::timeseries::StoragePolicy::GetStart function SetTimeStep \u00b6 inline virtual void SetTimeStep ( const TimeStep & tStep ) override Reimplements : datatypes::timeseries::StoragePolicy::SetTimeStep function SetStart \u00b6 inline virtual void SetStart ( const ptime & start ) override Reimplements : datatypes::timeseries::StoragePolicy::SetStart Public Attributes Documentation \u00b6 variable data \u00b6 vector < T > data ; variable readOnly \u00b6 bool readOnly = true ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::MultiFileTsStorage"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#datatypestimeseriesmultifiletsstorage","text":"An implementation of StoragePolicy such that the content of a time series is spread amongst several files. More... #include <time_series_io.hpp> Inherits from datatypes::timeseries::StoragePolicy< T > , datatypes::timeseries::TimeSeriesInfoProvider","title":"datatypes::timeseries::MultiFileTsStorage"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#public-types","text":"Name typedef std::remove_pointer< T >::type::ElementType ElementType","title":"Public Types"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#public-functions","text":"Name MultiFileTsStorage (const MultiFileTimeSeriesEnsembleTimeSeriesStore < ElementType > & storage, const string & dataIdentifier, bool readOnly =true) virtual bool ReadOnly () override virtual size_t Size () const void ReserveVectorData (size_t length) virtual void Allocate (size_t length, T value) virtual void AllocateValues (size_t length, const T * values) virtual void AllocateValues (const vector< T > & values) virtual void CopyTo (vector< T > & dest, size_t from =0, size_t to =-1) const virtual T & operator[] (const size_t i) virtual const T & operator[] (const size_t i) const virtual StoragePolicy < T > * Clone () const virtual size_t GetLength () const virtual TimeStep GetTimeStep () const override virtual ptime GetStart () const override virtual void SetTimeStep (const TimeStep & tStep) override virtual void SetStart (const ptime & start) override","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#public-attributes","text":"Name vector< T > data bool readOnly","title":"Public Attributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::StoragePolicy< T > Name virtual ~StoragePolicy () Protected Functions inherited from datatypes::timeseries::StoragePolicy< T > Name StoragePolicy (const StoragePolicy & src) StoragePolicy () Public Functions inherited from datatypes::timeseries::TimeSeriesInfoProvider Name virtual ~TimeSeriesInfoProvider ()","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#detailed-description","text":"template < typename T > class datatypes :: timeseries :: MultiFileTsStorage ; An implementation of StoragePolicy such that the content of a time series is spread amongst several files. Template Parameters : T The type of each data item this can handle.","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#typedef-elementtype","text":"typedef std :: remove_pointer < T >:: type :: ElementType datatypes :: timeseries :: MultiFileTsStorage < T >:: ElementType ;","title":"typedef ElementType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#function-multifiletsstorage","text":"inline MultiFileTsStorage ( const MultiFileTimeSeriesEnsembleTimeSeriesStore < ElementType > & storage , const string & dataIdentifier , bool readOnly = true )","title":"function MultiFileTsStorage"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#function-readonly","text":"inline virtual bool ReadOnly () override Reimplements : datatypes::timeseries::StoragePolicy::ReadOnly","title":"function ReadOnly"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#function-size","text":"inline virtual size_t Size () const Reimplements : datatypes::timeseries::StoragePolicy::Size","title":"function Size"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#function-reservevectordata","text":"inline void ReserveVectorData ( size_t length )","title":"function ReserveVectorData"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#function-allocate","text":"inline virtual void Allocate ( size_t length , T value ) Reimplements : datatypes::timeseries::StoragePolicy::Allocate","title":"function Allocate"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#function-allocatevalues","text":"inline virtual void AllocateValues ( size_t length , const T * values ) Reimplements : datatypes::timeseries::StoragePolicy::AllocateValues","title":"function AllocateValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#function-allocatevalues_1","text":"inline virtual void AllocateValues ( const vector < T > & values ) Reimplements : datatypes::timeseries::StoragePolicy::AllocateValues","title":"function AllocateValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#function-copyto","text":"inline virtual void CopyTo ( vector < T > & dest , size_t from = 0 , size_t to = -1 ) const Reimplements : datatypes::timeseries::StoragePolicy::CopyTo","title":"function CopyTo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#function-operator","text":"inline virtual T & operator []( const size_t i ) Reimplements : datatypes::timeseries::StoragePolicy::operator[]","title":"function operator[]"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#function-operator_1","text":"inline virtual const T & operator []( const size_t i ) const Reimplements : datatypes::timeseries::StoragePolicy::operator[]","title":"function operator[]"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#function-clone","text":"inline virtual StoragePolicy < T > * Clone () const Reimplements : datatypes::timeseries::StoragePolicy::Clone","title":"function Clone"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#function-getlength","text":"inline virtual size_t GetLength () const Reimplements : datatypes::timeseries::TimeSeriesInfoProvider::GetLength","title":"function GetLength"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#function-gettimestep","text":"inline virtual TimeStep GetTimeStep () const override Reimplements : datatypes::timeseries::StoragePolicy::GetTimeStep","title":"function GetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#function-getstart","text":"inline virtual ptime GetStart () const override Reimplements : datatypes::timeseries::StoragePolicy::GetStart","title":"function GetStart"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#function-settimestep","text":"inline virtual void SetTimeStep ( const TimeStep & tStep ) override Reimplements : datatypes::timeseries::StoragePolicy::SetTimeStep","title":"function SetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#function-setstart","text":"inline virtual void SetStart ( const ptime & start ) override Reimplements : datatypes::timeseries::StoragePolicy::SetStart","title":"function SetStart"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#variable-data","text":"vector < T > data ;","title":"variable data"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiFileTsStorage/#variable-readonly","text":"bool readOnly = true ; Updated on 2022-08-20 at 19:28:22 +1000","title":"variable readOnly"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/","text":"datatypes::timeseries::MultiTimeSeries \u00b6 Template for time series with multiple values at time point; e.g. to hold multiple realizations of time series in an ensemble. More... #include <time_series.hpp> Public Types \u00b6 Name typedef std::remove_pointer< TsType >::type Type typedef std::add_pointer< Type >::type PtrType typedef TsType ItemType typedef Type::ElementType ElementType Public Functions \u00b6 Name MultiTimeSeries (const vector< ElementType * > & values, size_t length, const ptime & startDate, const TimeStep & timeStep) MultiTimeSeries (const vector< vector< ElementType >> & values, const ptime & startDate, const TimeStep & timeStep) MultiTimeSeries ( ElementType **const values, size_t ensSize, size_t length, const ptime & startDate, const TimeStep & timeStep) MultiTimeSeries (const vector< PtrType > & values, const ptime & startDate, const TimeStep & timeStep) MultiTimeSeries (const Type & series) MultiTimeSeries (const vector< Type > & values, const ptime & startDate, const TimeStep & timeStep) MultiTimeSeries (std::function< Type (size_t)> & valueGen, size_t ensSize, const ptime & startDate, const TimeStep & timeStep) MultiTimeSeries (const MultiTimeSeries < TsType > & src) MultiTimeSeries ( EnsembleStoragePolicy < TsType > * store) MultiTimeSeries () MultiTimeSeries < PtrType > * AsPointerSeries () MultiTimeSeries < Type > AsValueSeries () ~MultiTimeSeries () MultiTimeSeries & operator= (const MultiTimeSeries & src) MultiTimeSeries & operator= ( MultiTimeSeries && src) void ResetSeries (const size_t & numSeries, const size_t & lengthSeries, const ptime & startDate, const TimeStep & timeStep) TsType Get (size_t i) Type Get (size_t i) const ElementType Get (size_t i, size_t tsIndex) void Set (size_t i, size_t tsIndex, ElementType val) void Set (size_t i, const Type & val) vector< ElementType * > * GetValues () const void CopyTo ( ElementType ** dest) const size_t Size () const size_t GetLength (size_t i) const ptime GetStartDate () const void SetStartDate (const ptime & start) TimeStep GetTimeStep () const void Clear () Protected Functions \u00b6 Name virtual void InitializeStorage () virtual void OperatorEqualImpl (const MultiTimeSeries < TsType > & src) Detailed Description \u00b6 template < typename TsType = TimeSeries > class datatypes :: timeseries :: MultiTimeSeries ; Template for time series with multiple values at time point; e.g. to hold multiple realizations of time series in an ensemble. Template Parameters : TsType type of time series, typically a time series of double or float. Public Types Documentation \u00b6 typedef Type \u00b6 typedef std :: remove_pointer < TsType >:: type datatypes :: timeseries :: MultiTimeSeries < TsType >:: Type ; typedef PtrType \u00b6 typedef std :: add_pointer < Type >:: type datatypes :: timeseries :: MultiTimeSeries < TsType >:: PtrType ; typedef ItemType \u00b6 typedef TsType datatypes :: timeseries :: MultiTimeSeries < TsType >:: ItemType ; typedef ElementType \u00b6 typedef Type :: ElementType datatypes :: timeseries :: MultiTimeSeries < TsType >:: ElementType ; Public Functions Documentation \u00b6 function MultiTimeSeries \u00b6 inline MultiTimeSeries ( const vector < ElementType * > & values , size_t length , const ptime & startDate , const TimeStep & timeStep ) function MultiTimeSeries \u00b6 inline MultiTimeSeries ( const vector < vector < ElementType >> & values , const ptime & startDate , const TimeStep & timeStep ) function MultiTimeSeries \u00b6 inline MultiTimeSeries ( ElementType ** const values , size_t ensSize , size_t length , const ptime & startDate , const TimeStep & timeStep ) function MultiTimeSeries \u00b6 inline MultiTimeSeries ( const vector < PtrType > & values , const ptime & startDate , const TimeStep & timeStep ) function MultiTimeSeries \u00b6 inline MultiTimeSeries ( const Type & series ) function MultiTimeSeries \u00b6 inline MultiTimeSeries ( const vector < Type > & values , const ptime & startDate , const TimeStep & timeStep ) function MultiTimeSeries \u00b6 inline MultiTimeSeries ( std :: function < Type ( size_t ) > & valueGen , size_t ensSize , const ptime & startDate , const TimeStep & timeStep ) function MultiTimeSeries \u00b6 inline MultiTimeSeries ( const MultiTimeSeries < TsType > & src ) function MultiTimeSeries \u00b6 inline MultiTimeSeries ( EnsembleStoragePolicy < TsType > * store ) function MultiTimeSeries \u00b6 inline MultiTimeSeries () function AsPointerSeries \u00b6 inline MultiTimeSeries < PtrType > * AsPointerSeries () function AsValueSeries \u00b6 inline MultiTimeSeries < Type > AsValueSeries () function ~MultiTimeSeries \u00b6 inline ~ MultiTimeSeries () function operator= \u00b6 inline MultiTimeSeries & operator = ( const MultiTimeSeries & src ) function operator= \u00b6 inline MultiTimeSeries & operator = ( MultiTimeSeries && src ) function ResetSeries \u00b6 inline void ResetSeries ( const size_t & numSeries , const size_t & lengthSeries , const ptime & startDate , const TimeStep & timeStep ) function Get \u00b6 inline TsType Get ( size_t i ) function Get \u00b6 inline Type Get ( size_t i ) const function Get \u00b6 inline ElementType Get ( size_t i , size_t tsIndex ) function Set \u00b6 inline void Set ( size_t i , size_t tsIndex , ElementType val ) function Set \u00b6 inline void Set ( size_t i , const Type & val ) function GetValues \u00b6 inline vector < ElementType * > * GetValues () const function CopyTo \u00b6 inline void CopyTo ( ElementType ** dest ) const function Size \u00b6 inline size_t Size () const function GetLength \u00b6 inline size_t GetLength ( size_t i ) const function GetStartDate \u00b6 inline ptime GetStartDate () const function SetStartDate \u00b6 inline void SetStartDate ( const ptime & start ) function GetTimeStep \u00b6 inline TimeStep GetTimeStep () const function Clear \u00b6 inline void Clear () Protected Functions Documentation \u00b6 function InitializeStorage \u00b6 inline virtual void InitializeStorage () function OperatorEqualImpl \u00b6 inline virtual void OperatorEqualImpl ( const MultiTimeSeries < TsType > & src ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::MultiTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#datatypestimeseriesmultitimeseries","text":"Template for time series with multiple values at time point; e.g. to hold multiple realizations of time series in an ensemble. More... #include <time_series.hpp>","title":"datatypes::timeseries::MultiTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#public-types","text":"Name typedef std::remove_pointer< TsType >::type Type typedef std::add_pointer< Type >::type PtrType typedef TsType ItemType typedef Type::ElementType ElementType","title":"Public Types"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#public-functions","text":"Name MultiTimeSeries (const vector< ElementType * > & values, size_t length, const ptime & startDate, const TimeStep & timeStep) MultiTimeSeries (const vector< vector< ElementType >> & values, const ptime & startDate, const TimeStep & timeStep) MultiTimeSeries ( ElementType **const values, size_t ensSize, size_t length, const ptime & startDate, const TimeStep & timeStep) MultiTimeSeries (const vector< PtrType > & values, const ptime & startDate, const TimeStep & timeStep) MultiTimeSeries (const Type & series) MultiTimeSeries (const vector< Type > & values, const ptime & startDate, const TimeStep & timeStep) MultiTimeSeries (std::function< Type (size_t)> & valueGen, size_t ensSize, const ptime & startDate, const TimeStep & timeStep) MultiTimeSeries (const MultiTimeSeries < TsType > & src) MultiTimeSeries ( EnsembleStoragePolicy < TsType > * store) MultiTimeSeries () MultiTimeSeries < PtrType > * AsPointerSeries () MultiTimeSeries < Type > AsValueSeries () ~MultiTimeSeries () MultiTimeSeries & operator= (const MultiTimeSeries & src) MultiTimeSeries & operator= ( MultiTimeSeries && src) void ResetSeries (const size_t & numSeries, const size_t & lengthSeries, const ptime & startDate, const TimeStep & timeStep) TsType Get (size_t i) Type Get (size_t i) const ElementType Get (size_t i, size_t tsIndex) void Set (size_t i, size_t tsIndex, ElementType val) void Set (size_t i, const Type & val) vector< ElementType * > * GetValues () const void CopyTo ( ElementType ** dest) const size_t Size () const size_t GetLength (size_t i) const ptime GetStartDate () const void SetStartDate (const ptime & start) TimeStep GetTimeStep () const void Clear ()","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#protected-functions","text":"Name virtual void InitializeStorage () virtual void OperatorEqualImpl (const MultiTimeSeries < TsType > & src)","title":"Protected Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#detailed-description","text":"template < typename TsType = TimeSeries > class datatypes :: timeseries :: MultiTimeSeries ; Template for time series with multiple values at time point; e.g. to hold multiple realizations of time series in an ensemble. Template Parameters : TsType type of time series, typically a time series of double or float.","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#typedef-type","text":"typedef std :: remove_pointer < TsType >:: type datatypes :: timeseries :: MultiTimeSeries < TsType >:: Type ;","title":"typedef Type"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#typedef-ptrtype","text":"typedef std :: add_pointer < Type >:: type datatypes :: timeseries :: MultiTimeSeries < TsType >:: PtrType ;","title":"typedef PtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#typedef-itemtype","text":"typedef TsType datatypes :: timeseries :: MultiTimeSeries < TsType >:: ItemType ;","title":"typedef ItemType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#typedef-elementtype","text":"typedef Type :: ElementType datatypes :: timeseries :: MultiTimeSeries < TsType >:: ElementType ;","title":"typedef ElementType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-multitimeseries","text":"inline MultiTimeSeries ( const vector < ElementType * > & values , size_t length , const ptime & startDate , const TimeStep & timeStep )","title":"function MultiTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-multitimeseries_1","text":"inline MultiTimeSeries ( const vector < vector < ElementType >> & values , const ptime & startDate , const TimeStep & timeStep )","title":"function MultiTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-multitimeseries_2","text":"inline MultiTimeSeries ( ElementType ** const values , size_t ensSize , size_t length , const ptime & startDate , const TimeStep & timeStep )","title":"function MultiTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-multitimeseries_3","text":"inline MultiTimeSeries ( const vector < PtrType > & values , const ptime & startDate , const TimeStep & timeStep )","title":"function MultiTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-multitimeseries_4","text":"inline MultiTimeSeries ( const Type & series )","title":"function MultiTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-multitimeseries_5","text":"inline MultiTimeSeries ( const vector < Type > & values , const ptime & startDate , const TimeStep & timeStep )","title":"function MultiTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-multitimeseries_6","text":"inline MultiTimeSeries ( std :: function < Type ( size_t ) > & valueGen , size_t ensSize , const ptime & startDate , const TimeStep & timeStep )","title":"function MultiTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-multitimeseries_7","text":"inline MultiTimeSeries ( const MultiTimeSeries < TsType > & src )","title":"function MultiTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-multitimeseries_8","text":"inline MultiTimeSeries ( EnsembleStoragePolicy < TsType > * store )","title":"function MultiTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-multitimeseries_9","text":"inline MultiTimeSeries ()","title":"function MultiTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-aspointerseries","text":"inline MultiTimeSeries < PtrType > * AsPointerSeries ()","title":"function AsPointerSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-asvalueseries","text":"inline MultiTimeSeries < Type > AsValueSeries ()","title":"function AsValueSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-multitimeseries_10","text":"inline ~ MultiTimeSeries ()","title":"function ~MultiTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-operator","text":"inline MultiTimeSeries & operator = ( const MultiTimeSeries & src )","title":"function operator="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-operator_1","text":"inline MultiTimeSeries & operator = ( MultiTimeSeries && src )","title":"function operator="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-resetseries","text":"inline void ResetSeries ( const size_t & numSeries , const size_t & lengthSeries , const ptime & startDate , const TimeStep & timeStep )","title":"function ResetSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-get","text":"inline TsType Get ( size_t i )","title":"function Get"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-get_1","text":"inline Type Get ( size_t i ) const","title":"function Get"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-get_2","text":"inline ElementType Get ( size_t i , size_t tsIndex )","title":"function Get"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-set","text":"inline void Set ( size_t i , size_t tsIndex , ElementType val )","title":"function Set"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-set_1","text":"inline void Set ( size_t i , const Type & val )","title":"function Set"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-getvalues","text":"inline vector < ElementType * > * GetValues () const","title":"function GetValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-copyto","text":"inline void CopyTo ( ElementType ** dest ) const","title":"function CopyTo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-size","text":"inline size_t Size () const","title":"function Size"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-getlength","text":"inline size_t GetLength ( size_t i ) const","title":"function GetLength"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-getstartdate","text":"inline ptime GetStartDate () const","title":"function GetStartDate"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-setstartdate","text":"inline void SetStartDate ( const ptime & start )","title":"function SetStartDate"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-gettimestep","text":"inline TimeStep GetTimeStep () const","title":"function GetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-clear","text":"inline void Clear ()","title":"function Clear"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-initializestorage","text":"inline virtual void InitializeStorage ()","title":"function InitializeStorage"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1MultiTimeSeries/#function-operatorequalimpl","text":"inline virtual void OperatorEqualImpl ( const MultiTimeSeries < TsType > & src ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function OperatorEqualImpl"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NegativeIsMissingFloadingPointPolicy/","text":"datatypes::timeseries::NegativeIsMissingFloadingPointPolicy \u00b6 More... #include <time_series_strategies.hpp> Inherits from datatypes::timeseries::MissingValuePolicy< double > Public Functions \u00b6 Name bool IsMissingValue (const T & a) const virtual T GetMissingValue () const virtual MissingValuePolicy < T > * Clone () const Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::MissingValuePolicy< double > Name virtual ~MissingValuePolicy () Detailed Description \u00b6 template < typename T = double > class datatypes :: timeseries :: NegativeIsMissingFloadingPointPolicy ; Public Functions Documentation \u00b6 function IsMissingValue \u00b6 inline bool IsMissingValue ( const T & a ) const function GetMissingValue \u00b6 inline virtual T GetMissingValue () const Reimplements : datatypes::timeseries::MissingValuePolicy::GetMissingValue function Clone \u00b6 inline virtual MissingValuePolicy < T > * Clone () const Reimplements : datatypes::timeseries::MissingValuePolicy::Clone Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::NegativeIsMissingFloadingPointPolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NegativeIsMissingFloadingPointPolicy/#datatypestimeseriesnegativeismissingfloadingpointpolicy","text":"More... #include <time_series_strategies.hpp> Inherits from datatypes::timeseries::MissingValuePolicy< double >","title":"datatypes::timeseries::NegativeIsMissingFloadingPointPolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NegativeIsMissingFloadingPointPolicy/#public-functions","text":"Name bool IsMissingValue (const T & a) const virtual T GetMissingValue () const virtual MissingValuePolicy < T > * Clone () const","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NegativeIsMissingFloadingPointPolicy/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::MissingValuePolicy< double > Name virtual ~MissingValuePolicy ()","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NegativeIsMissingFloadingPointPolicy/#detailed-description","text":"template < typename T = double > class datatypes :: timeseries :: NegativeIsMissingFloadingPointPolicy ;","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NegativeIsMissingFloadingPointPolicy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NegativeIsMissingFloadingPointPolicy/#function-ismissingvalue","text":"inline bool IsMissingValue ( const T & a ) const","title":"function IsMissingValue"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NegativeIsMissingFloadingPointPolicy/#function-getmissingvalue","text":"inline virtual T GetMissingValue () const Reimplements : datatypes::timeseries::MissingValuePolicy::GetMissingValue","title":"function GetMissingValue"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NegativeIsMissingFloadingPointPolicy/#function-clone","text":"inline virtual MissingValuePolicy < T > * Clone () const Reimplements : datatypes::timeseries::MissingValuePolicy::Clone Updated on 2022-08-20 at 19:28:22 +1000","title":"function Clone"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfEnsembleTimeSeriesStore/","text":"datatypes::timeseries::NetCdfEnsembleTimeSeriesStore \u00b6 More... #include <time_series_io.hpp> Inherits from datatypes::timeseries::EnsembleTimeSeriesStore< T > , datatypes::timeseries::SingleNetCdfFileStore< T > , datatypes::timeseries::IdentifiersProvider , datatypes::timeseries::DataDescriptor Public Functions \u00b6 Name NetCdfEnsembleTimeSeriesStore (const string & filename, const size_t nEns, const vector< double > & leadTimeVar, const string & timeUnits, const vector< double > & timeVar, const vector< string > & stationIds, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName, const string & identifier =\"\", const string & leadTimeUnits =\"\") NetCdfEnsembleTimeSeriesStore (const string & filename, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName, const string & identifier =\"\") NetCdfEnsembleTimeSeriesStore (const string & fname, const string & ncVarName, const string & identifier =\"\") virtual string GetDataSummary () const virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const virtual vector< string > GetIdentifiers () const virtual MultiTimeSeries < TTimeSeries < T > * > * Read () void Write ( MultiTimeSeries < TTimeSeries < T > * > * ensemble) string Dimensions () Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::EnsembleTimeSeriesStore< T > Name virtual ~EnsembleTimeSeriesStore () Public Functions inherited from datatypes::timeseries::SingleNetCdfFileStore< T > Name virtual ~SingleNetCdfFileStore () virtual void Close () bool HasNcAccess () size_t GetEnsembleSize () const size_t GetLeadTimeCount () const size_t GetTimeLength () const TimeStep GetTimeStep () const ptime TimeForIndex (size_t timeIndex) const vector< ptime > GetTimeDim () const vector< double > GetLeadTimeDim () const ptime GetStart () const ptime GetEnd () const size_t IndexForIdentifier (const string & identifier) const VariableAttributes GetVarAttributes () GlobalAttributes GetGlobalAttributes () Protected Functions inherited from datatypes::timeseries::SingleNetCdfFileStore< T > Name SingleNetCdfFileStore () SingleNetCdfFileStore (const string & fname, const size_t nEns, const vector< double > & leadTimeVar, const string & timeUnits, const vector< double > & timeVar, const vector< string > & stationIds, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName =\"\", const string & identifier =\"\", const string & leadTimeUnits =\"\") Constructor to create a new SWIFT netCDF file. SingleNetCdfFileStore (const string & fname, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName =\"\", const string & identifier =\"\") SingleNetCdfFileStore (const string & fname, const string & ncVarName =\"\", const string & identifier =\"\", bool writeMode =false) void Init (const string & filename, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes) void MoveFrom ( SingleNetCdfFileStore & src) void CopyFrom (const SingleNetCdfFileStore & src) string GetNcVarName (bool allowDiscovery =true) const string DataSummaryForIdentifier () const string GetDefaultDataSummary () const size_t IndexForIdentifier (bool strict =true) const virtual bool HasIdentifier () const virtual string GetIdentifier (bool strict =true) const void SetIdentifier (string ident) Sets the current station identifier. SwiftNetCDFAccess * GetNcAccess () const string & GetFileName () Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId) Detailed Description \u00b6 template < typename T > class datatypes :: timeseries :: NetCdfEnsembleTimeSeriesStore ; Public Functions Documentation \u00b6 function NetCdfEnsembleTimeSeriesStore \u00b6 inline NetCdfEnsembleTimeSeriesStore ( const string & filename , const size_t nEns , const vector < double > & leadTimeVar , const string & timeUnits , const vector < double > & timeVar , const vector < string > & stationIds , const std :: map < string , VariableDefinition > & varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName , const string & identifier = \"\" , const string & leadTimeUnits = \"\" ) function NetCdfEnsembleTimeSeriesStore \u00b6 inline NetCdfEnsembleTimeSeriesStore ( const string & filename , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition > & varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName , const string & identifier = \"\" ) function NetCdfEnsembleTimeSeriesStore \u00b6 inline NetCdfEnsembleTimeSeriesStore ( const string & fname , const string & ncVarName , const string & identifier = \"\" ) function GetDataSummary \u00b6 inline virtual string GetDataSummary () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataSummary function GetDataDimensionsDescription \u00b6 inline virtual vector < DataDimensionDescriptor > GetDataDimensionsDescription () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataDimensionsDescription function GetIdentifiers \u00b6 inline virtual vector < string > GetIdentifiers () const Reimplements : datatypes::timeseries::SingleNetCdfFileStore::GetIdentifiers function Read \u00b6 inline virtual MultiTimeSeries < TTimeSeries < T > * > * Read () Reimplements : datatypes::timeseries::EnsembleTimeSeriesStore::Read function Write \u00b6 inline void Write ( MultiTimeSeries < TTimeSeries < T > * > * ensemble ) function Dimensions \u00b6 static inline string Dimensions () Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::NetCdfEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfEnsembleTimeSeriesStore/#datatypestimeseriesnetcdfensembletimeseriesstore","text":"More... #include <time_series_io.hpp> Inherits from datatypes::timeseries::EnsembleTimeSeriesStore< T > , datatypes::timeseries::SingleNetCdfFileStore< T > , datatypes::timeseries::IdentifiersProvider , datatypes::timeseries::DataDescriptor","title":"datatypes::timeseries::NetCdfEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfEnsembleTimeSeriesStore/#public-functions","text":"Name NetCdfEnsembleTimeSeriesStore (const string & filename, const size_t nEns, const vector< double > & leadTimeVar, const string & timeUnits, const vector< double > & timeVar, const vector< string > & stationIds, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName, const string & identifier =\"\", const string & leadTimeUnits =\"\") NetCdfEnsembleTimeSeriesStore (const string & filename, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName, const string & identifier =\"\") NetCdfEnsembleTimeSeriesStore (const string & fname, const string & ncVarName, const string & identifier =\"\") virtual string GetDataSummary () const virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const virtual vector< string > GetIdentifiers () const virtual MultiTimeSeries < TTimeSeries < T > * > * Read () void Write ( MultiTimeSeries < TTimeSeries < T > * > * ensemble) string Dimensions ()","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfEnsembleTimeSeriesStore/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::EnsembleTimeSeriesStore< T > Name virtual ~EnsembleTimeSeriesStore () Public Functions inherited from datatypes::timeseries::SingleNetCdfFileStore< T > Name virtual ~SingleNetCdfFileStore () virtual void Close () bool HasNcAccess () size_t GetEnsembleSize () const size_t GetLeadTimeCount () const size_t GetTimeLength () const TimeStep GetTimeStep () const ptime TimeForIndex (size_t timeIndex) const vector< ptime > GetTimeDim () const vector< double > GetLeadTimeDim () const ptime GetStart () const ptime GetEnd () const size_t IndexForIdentifier (const string & identifier) const VariableAttributes GetVarAttributes () GlobalAttributes GetGlobalAttributes () Protected Functions inherited from datatypes::timeseries::SingleNetCdfFileStore< T > Name SingleNetCdfFileStore () SingleNetCdfFileStore (const string & fname, const size_t nEns, const vector< double > & leadTimeVar, const string & timeUnits, const vector< double > & timeVar, const vector< string > & stationIds, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName =\"\", const string & identifier =\"\", const string & leadTimeUnits =\"\") Constructor to create a new SWIFT netCDF file. SingleNetCdfFileStore (const string & fname, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName =\"\", const string & identifier =\"\") SingleNetCdfFileStore (const string & fname, const string & ncVarName =\"\", const string & identifier =\"\", bool writeMode =false) void Init (const string & filename, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes) void MoveFrom ( SingleNetCdfFileStore & src) void CopyFrom (const SingleNetCdfFileStore & src) string GetNcVarName (bool allowDiscovery =true) const string DataSummaryForIdentifier () const string GetDefaultDataSummary () const size_t IndexForIdentifier (bool strict =true) const virtual bool HasIdentifier () const virtual string GetIdentifier (bool strict =true) const void SetIdentifier (string ident) Sets the current station identifier. SwiftNetCDFAccess * GetNcAccess () const string & GetFileName () Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId)","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfEnsembleTimeSeriesStore/#detailed-description","text":"template < typename T > class datatypes :: timeseries :: NetCdfEnsembleTimeSeriesStore ;","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfEnsembleTimeSeriesStore/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfEnsembleTimeSeriesStore/#function-netcdfensembletimeseriesstore","text":"inline NetCdfEnsembleTimeSeriesStore ( const string & filename , const size_t nEns , const vector < double > & leadTimeVar , const string & timeUnits , const vector < double > & timeVar , const vector < string > & stationIds , const std :: map < string , VariableDefinition > & varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName , const string & identifier = \"\" , const string & leadTimeUnits = \"\" )","title":"function NetCdfEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfEnsembleTimeSeriesStore/#function-netcdfensembletimeseriesstore_1","text":"inline NetCdfEnsembleTimeSeriesStore ( const string & filename , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition > & varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName , const string & identifier = \"\" )","title":"function NetCdfEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfEnsembleTimeSeriesStore/#function-netcdfensembletimeseriesstore_2","text":"inline NetCdfEnsembleTimeSeriesStore ( const string & fname , const string & ncVarName , const string & identifier = \"\" )","title":"function NetCdfEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfEnsembleTimeSeriesStore/#function-getdatasummary","text":"inline virtual string GetDataSummary () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataSummary","title":"function GetDataSummary"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfEnsembleTimeSeriesStore/#function-getdatadimensionsdescription","text":"inline virtual vector < DataDimensionDescriptor > GetDataDimensionsDescription () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataDimensionsDescription","title":"function GetDataDimensionsDescription"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfEnsembleTimeSeriesStore/#function-getidentifiers","text":"inline virtual vector < string > GetIdentifiers () const Reimplements : datatypes::timeseries::SingleNetCdfFileStore::GetIdentifiers","title":"function GetIdentifiers"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfEnsembleTimeSeriesStore/#function-read","text":"inline virtual MultiTimeSeries < TTimeSeries < T > * > * Read () Reimplements : datatypes::timeseries::EnsembleTimeSeriesStore::Read","title":"function Read"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfEnsembleTimeSeriesStore/#function-write","text":"inline void Write ( MultiTimeSeries < TTimeSeries < T > * > * ensemble )","title":"function Write"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfEnsembleTimeSeriesStore/#function-dimensions","text":"static inline string Dimensions () Updated on 2022-08-20 at 19:28:22 +1000","title":"function Dimensions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/","text":"datatypes::timeseries::NetCdfSingleSeriesStore \u00b6 More... #include <time_series_io.hpp> Inherits from datatypes::timeseries::SingleTimeSeriesStore< T > , datatypes::timeseries::SingleNetCdfFileStore< T > , datatypes::timeseries::IdentifiersProvider , datatypes::timeseries::DataDescriptor Public Functions \u00b6 Name NetCdfSingleSeriesStore (const string & filename, const size_t nEns, const vector< double > & leadTimeVar, const string & timeUnits, const vector< double > & timeVar, const vector< string > & stationIds, const std::map< string, VariableDefinition > & varDefinitions, const string & ncVarName, const string & identifier =\"\", const string & leadTimeUnits =\"\") NetCdfSingleSeriesStore (const string & filename, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName, const string & identifier =\"\") NetCdfSingleSeriesStore (const string & fname) NetCdfSingleSeriesStore (const string & fname, const string & ncVarName, const string & identifier =\"\") NetCdfSingleSeriesStore & operator= ( NetCdfSingleSeriesStore && src) NetCdfSingleSeriesStore & operator= (const NetCdfSingleSeriesStore & src) NetCdfSingleSeriesStore ( NetCdfSingleSeriesStore && src) NetCdfSingleSeriesStore (const NetCdfSingleSeriesStore & src) virtual string GetDataSummary () const virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const virtual TTimeSeries < T > * Read () virtual TTimeSeries < T > * Read (const string & identifier) virtual MultiTimeSeries < TTimeSeries < T > * > * ReadAllCollection () void Write ( TTimeSeries < T > * timeSeries) vector< TTimeSeries < T > * > ReorderPerIdentifier (const std::map< string, TTimeSeries < T > * > & toSave) vector< T > Serialize (const vector< TTimeSeries < T > * > & series) void WriteToIdentifiers (const std::map< string, TTimeSeries < T > * > & toSave) void WriteToNcVariables (const std::map< string, TTimeSeries < T > * > & toSave) virtual vector< string > GetIdentifiers () const string Dimensions () Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::SingleTimeSeriesStore< T > Name virtual ~SingleTimeSeriesStore () Public Functions inherited from datatypes::timeseries::SingleNetCdfFileStore< T > Name virtual ~SingleNetCdfFileStore () virtual void Close () bool HasNcAccess () size_t GetEnsembleSize () const size_t GetLeadTimeCount () const size_t GetTimeLength () const TimeStep GetTimeStep () const ptime TimeForIndex (size_t timeIndex) const vector< ptime > GetTimeDim () const vector< double > GetLeadTimeDim () const ptime GetStart () const ptime GetEnd () const size_t IndexForIdentifier (const string & identifier) const VariableAttributes GetVarAttributes () GlobalAttributes GetGlobalAttributes () Protected Functions inherited from datatypes::timeseries::SingleNetCdfFileStore< T > Name SingleNetCdfFileStore () SingleNetCdfFileStore (const string & fname, const size_t nEns, const vector< double > & leadTimeVar, const string & timeUnits, const vector< double > & timeVar, const vector< string > & stationIds, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName =\"\", const string & identifier =\"\", const string & leadTimeUnits =\"\") Constructor to create a new SWIFT netCDF file. SingleNetCdfFileStore (const string & fname, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName =\"\", const string & identifier =\"\") SingleNetCdfFileStore (const string & fname, const string & ncVarName =\"\", const string & identifier =\"\", bool writeMode =false) void Init (const string & filename, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes) void MoveFrom ( SingleNetCdfFileStore & src) void CopyFrom (const SingleNetCdfFileStore & src) string GetNcVarName (bool allowDiscovery =true) const string DataSummaryForIdentifier () const string GetDefaultDataSummary () const size_t IndexForIdentifier (bool strict =true) const virtual bool HasIdentifier () const virtual string GetIdentifier (bool strict =true) const void SetIdentifier (string ident) Sets the current station identifier. SwiftNetCDFAccess * GetNcAccess () const string & GetFileName () Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId) Detailed Description \u00b6 template < typename T > class datatypes :: timeseries :: NetCdfSingleSeriesStore ; Public Functions Documentation \u00b6 function NetCdfSingleSeriesStore \u00b6 inline NetCdfSingleSeriesStore ( const string & filename , const size_t nEns , const vector < double > & leadTimeVar , const string & timeUnits , const vector < double > & timeVar , const vector < string > & stationIds , const std :: map < string , VariableDefinition > & varDefinitions , const string & ncVarName , const string & identifier = \"\" , const string & leadTimeUnits = \"\" ) function NetCdfSingleSeriesStore \u00b6 inline NetCdfSingleSeriesStore ( const string & filename , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition > & varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName , const string & identifier = \"\" ) function NetCdfSingleSeriesStore \u00b6 inline NetCdfSingleSeriesStore ( const string & fname ) function NetCdfSingleSeriesStore \u00b6 inline NetCdfSingleSeriesStore ( const string & fname , const string & ncVarName , const string & identifier = \"\" ) function operator= \u00b6 inline NetCdfSingleSeriesStore & operator = ( NetCdfSingleSeriesStore && src ) function operator= \u00b6 inline NetCdfSingleSeriesStore & operator = ( const NetCdfSingleSeriesStore & src ) function NetCdfSingleSeriesStore \u00b6 inline NetCdfSingleSeriesStore ( NetCdfSingleSeriesStore && src ) function NetCdfSingleSeriesStore \u00b6 inline NetCdfSingleSeriesStore ( const NetCdfSingleSeriesStore & src ) function GetDataSummary \u00b6 inline virtual string GetDataSummary () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataSummary function GetDataDimensionsDescription \u00b6 inline virtual vector < DataDimensionDescriptor > GetDataDimensionsDescription () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataDimensionsDescription function Read \u00b6 inline virtual TTimeSeries < T > * Read () Reimplements : datatypes::timeseries::SingleTimeSeriesStore::Read function Read \u00b6 inline virtual TTimeSeries < T > * Read ( const string & identifier ) Reimplements : datatypes::timeseries::SingleTimeSeriesStore::Read function ReadAllCollection \u00b6 inline virtual MultiTimeSeries < TTimeSeries < T > * > * ReadAllCollection () Reimplements : datatypes::timeseries::SingleTimeSeriesStore::ReadAllCollection function Write \u00b6 inline void Write ( TTimeSeries < T > * timeSeries ) function ReorderPerIdentifier \u00b6 inline vector < TTimeSeries < T > * > ReorderPerIdentifier ( const std :: map < string , TTimeSeries < T > * > & toSave ) function Serialize \u00b6 inline vector < T > Serialize ( const vector < TTimeSeries < T > * > & series ) function WriteToIdentifiers \u00b6 inline void WriteToIdentifiers ( const std :: map < string , TTimeSeries < T > * > & toSave ) function WriteToNcVariables \u00b6 inline void WriteToNcVariables ( const std :: map < string , TTimeSeries < T > * > & toSave ) function GetIdentifiers \u00b6 inline virtual vector < string > GetIdentifiers () const Reimplements : datatypes::timeseries::SingleNetCdfFileStore::GetIdentifiers function Dimensions \u00b6 static inline string Dimensions () Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::NetCdfSingleSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#datatypestimeseriesnetcdfsingleseriesstore","text":"More... #include <time_series_io.hpp> Inherits from datatypes::timeseries::SingleTimeSeriesStore< T > , datatypes::timeseries::SingleNetCdfFileStore< T > , datatypes::timeseries::IdentifiersProvider , datatypes::timeseries::DataDescriptor","title":"datatypes::timeseries::NetCdfSingleSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#public-functions","text":"Name NetCdfSingleSeriesStore (const string & filename, const size_t nEns, const vector< double > & leadTimeVar, const string & timeUnits, const vector< double > & timeVar, const vector< string > & stationIds, const std::map< string, VariableDefinition > & varDefinitions, const string & ncVarName, const string & identifier =\"\", const string & leadTimeUnits =\"\") NetCdfSingleSeriesStore (const string & filename, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName, const string & identifier =\"\") NetCdfSingleSeriesStore (const string & fname) NetCdfSingleSeriesStore (const string & fname, const string & ncVarName, const string & identifier =\"\") NetCdfSingleSeriesStore & operator= ( NetCdfSingleSeriesStore && src) NetCdfSingleSeriesStore & operator= (const NetCdfSingleSeriesStore & src) NetCdfSingleSeriesStore ( NetCdfSingleSeriesStore && src) NetCdfSingleSeriesStore (const NetCdfSingleSeriesStore & src) virtual string GetDataSummary () const virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const virtual TTimeSeries < T > * Read () virtual TTimeSeries < T > * Read (const string & identifier) virtual MultiTimeSeries < TTimeSeries < T > * > * ReadAllCollection () void Write ( TTimeSeries < T > * timeSeries) vector< TTimeSeries < T > * > ReorderPerIdentifier (const std::map< string, TTimeSeries < T > * > & toSave) vector< T > Serialize (const vector< TTimeSeries < T > * > & series) void WriteToIdentifiers (const std::map< string, TTimeSeries < T > * > & toSave) void WriteToNcVariables (const std::map< string, TTimeSeries < T > * > & toSave) virtual vector< string > GetIdentifiers () const string Dimensions ()","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::SingleTimeSeriesStore< T > Name virtual ~SingleTimeSeriesStore () Public Functions inherited from datatypes::timeseries::SingleNetCdfFileStore< T > Name virtual ~SingleNetCdfFileStore () virtual void Close () bool HasNcAccess () size_t GetEnsembleSize () const size_t GetLeadTimeCount () const size_t GetTimeLength () const TimeStep GetTimeStep () const ptime TimeForIndex (size_t timeIndex) const vector< ptime > GetTimeDim () const vector< double > GetLeadTimeDim () const ptime GetStart () const ptime GetEnd () const size_t IndexForIdentifier (const string & identifier) const VariableAttributes GetVarAttributes () GlobalAttributes GetGlobalAttributes () Protected Functions inherited from datatypes::timeseries::SingleNetCdfFileStore< T > Name SingleNetCdfFileStore () SingleNetCdfFileStore (const string & fname, const size_t nEns, const vector< double > & leadTimeVar, const string & timeUnits, const vector< double > & timeVar, const vector< string > & stationIds, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName =\"\", const string & identifier =\"\", const string & leadTimeUnits =\"\") Constructor to create a new SWIFT netCDF file. SingleNetCdfFileStore (const string & fname, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName =\"\", const string & identifier =\"\") SingleNetCdfFileStore (const string & fname, const string & ncVarName =\"\", const string & identifier =\"\", bool writeMode =false) void Init (const string & filename, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes) void MoveFrom ( SingleNetCdfFileStore & src) void CopyFrom (const SingleNetCdfFileStore & src) string GetNcVarName (bool allowDiscovery =true) const string DataSummaryForIdentifier () const string GetDefaultDataSummary () const size_t IndexForIdentifier (bool strict =true) const virtual bool HasIdentifier () const virtual string GetIdentifier (bool strict =true) const void SetIdentifier (string ident) Sets the current station identifier. SwiftNetCDFAccess * GetNcAccess () const string & GetFileName () Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId)","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#detailed-description","text":"template < typename T > class datatypes :: timeseries :: NetCdfSingleSeriesStore ;","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#function-netcdfsingleseriesstore","text":"inline NetCdfSingleSeriesStore ( const string & filename , const size_t nEns , const vector < double > & leadTimeVar , const string & timeUnits , const vector < double > & timeVar , const vector < string > & stationIds , const std :: map < string , VariableDefinition > & varDefinitions , const string & ncVarName , const string & identifier = \"\" , const string & leadTimeUnits = \"\" )","title":"function NetCdfSingleSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#function-netcdfsingleseriesstore_1","text":"inline NetCdfSingleSeriesStore ( const string & filename , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition > & varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName , const string & identifier = \"\" )","title":"function NetCdfSingleSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#function-netcdfsingleseriesstore_2","text":"inline NetCdfSingleSeriesStore ( const string & fname )","title":"function NetCdfSingleSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#function-netcdfsingleseriesstore_3","text":"inline NetCdfSingleSeriesStore ( const string & fname , const string & ncVarName , const string & identifier = \"\" )","title":"function NetCdfSingleSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#function-operator","text":"inline NetCdfSingleSeriesStore & operator = ( NetCdfSingleSeriesStore && src )","title":"function operator="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#function-operator_1","text":"inline NetCdfSingleSeriesStore & operator = ( const NetCdfSingleSeriesStore & src )","title":"function operator="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#function-netcdfsingleseriesstore_4","text":"inline NetCdfSingleSeriesStore ( NetCdfSingleSeriesStore && src )","title":"function NetCdfSingleSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#function-netcdfsingleseriesstore_5","text":"inline NetCdfSingleSeriesStore ( const NetCdfSingleSeriesStore & src )","title":"function NetCdfSingleSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#function-getdatasummary","text":"inline virtual string GetDataSummary () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataSummary","title":"function GetDataSummary"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#function-getdatadimensionsdescription","text":"inline virtual vector < DataDimensionDescriptor > GetDataDimensionsDescription () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataDimensionsDescription","title":"function GetDataDimensionsDescription"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#function-read","text":"inline virtual TTimeSeries < T > * Read () Reimplements : datatypes::timeseries::SingleTimeSeriesStore::Read","title":"function Read"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#function-read_1","text":"inline virtual TTimeSeries < T > * Read ( const string & identifier ) Reimplements : datatypes::timeseries::SingleTimeSeriesStore::Read","title":"function Read"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#function-readallcollection","text":"inline virtual MultiTimeSeries < TTimeSeries < T > * > * ReadAllCollection () Reimplements : datatypes::timeseries::SingleTimeSeriesStore::ReadAllCollection","title":"function ReadAllCollection"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#function-write","text":"inline void Write ( TTimeSeries < T > * timeSeries )","title":"function Write"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#function-reorderperidentifier","text":"inline vector < TTimeSeries < T > * > ReorderPerIdentifier ( const std :: map < string , TTimeSeries < T > * > & toSave )","title":"function ReorderPerIdentifier"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#function-serialize","text":"inline vector < T > Serialize ( const vector < TTimeSeries < T > * > & series )","title":"function Serialize"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#function-writetoidentifiers","text":"inline void WriteToIdentifiers ( const std :: map < string , TTimeSeries < T > * > & toSave )","title":"function WriteToIdentifiers"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#function-writetoncvariables","text":"inline void WriteToNcVariables ( const std :: map < string , TTimeSeries < T > * > & toSave )","title":"function WriteToNcVariables"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#function-getidentifiers","text":"inline virtual vector < string > GetIdentifiers () const Reimplements : datatypes::timeseries::SingleNetCdfFileStore::GetIdentifiers","title":"function GetIdentifiers"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSingleSeriesStore/#function-dimensions","text":"static inline string Dimensions () Updated on 2022-08-20 at 19:28:22 +1000","title":"function Dimensions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSourceInfo/","text":"datatypes::timeseries::NetCdfSourceInfo \u00b6 #include <time_series_store.hpp> Inherits from datatypes::timeseries::TimeSeriesSourceInfoImpl Public Functions \u00b6 Name NetCdfSourceInfo () NetCdfSourceInfo (const string & dataId, const string & fileName, const string & ncVarName, const string & identifier =\"\", int index =-1, const string & storageType =\"\", const string & timeStep =\"\", const string & start =\"\", int length =-1, int ensembleSize =-1, int ensembleLength =-1, const string & ensembleTimeStep =\"\", const string & containingDirectory =\"\") NetCdfSourceInfo (const string & dataId, const string & fileName, const string & ncVarName, const string & identifier, int index, const string & storageType, const TimeStep & timeStep, const ptime & start, int length, int ensembleSize, int ensembleLength, const TimeStep & ensembleTimeStep) virtual TimeSeriesSourceInfoImpl * Clone () const virtual bool ApplyRootDir (const string & rootDir) virtual SingleTimeSeriesStore < double > * CreateSingleTimeSeriesStore () const virtual EnsembleTimeSeriesStore < double > * CreateEnsembleTimeSeriesStore () const virtual TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore () const virtual std::map< string, string > GetSerializableConfiguration () const Public Attributes \u00b6 Name const string FileKey const string VarKey const string IdentifierKey const string IndexKey const string TypeKey const string StorageTypeSingleNetcdfFile const string StorageTypeMultipleNetcdfFiles Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::TimeSeriesSourceInfoImpl Name virtual ~TimeSeriesSourceInfoImpl () string OptionalApplyRootDir (const std::string & rootDir, const std::string & filename, bool checkDirExists =true) Protected Functions inherited from datatypes::timeseries::TimeSeriesSourceInfoImpl Name TimeSeriesSourceInfoImpl () TimeSeriesSourceInfoImpl (const TimeSeriesSourceInfoImpl & src) Public Functions Documentation \u00b6 function NetCdfSourceInfo \u00b6 inline NetCdfSourceInfo () function NetCdfSourceInfo \u00b6 NetCdfSourceInfo ( const string & dataId , const string & fileName , const string & ncVarName , const string & identifier = \"\" , int index = -1 , const string & storageType = \"\" , const string & timeStep = \"\" , const string & start = \"\" , int length = -1 , int ensembleSize = -1 , int ensembleLength = -1 , const string & ensembleTimeStep = \"\" , const string & containingDirectory = \"\" ) function NetCdfSourceInfo \u00b6 NetCdfSourceInfo ( const string & dataId , const string & fileName , const string & ncVarName , const string & identifier , int index , const string & storageType , const TimeStep & timeStep , const ptime & start , int length , int ensembleSize , int ensembleLength , const TimeStep & ensembleTimeStep ) function Clone \u00b6 virtual TimeSeriesSourceInfoImpl * Clone () const Reimplements : datatypes::timeseries::TimeSeriesSourceInfoImpl::Clone function ApplyRootDir \u00b6 virtual bool ApplyRootDir ( const string & rootDir ) Reimplements : datatypes::timeseries::TimeSeriesSourceInfoImpl::ApplyRootDir function CreateSingleTimeSeriesStore \u00b6 virtual SingleTimeSeriesStore < double > * CreateSingleTimeSeriesStore () const Reimplements : datatypes::timeseries::TimeSeriesSourceInfoImpl::CreateSingleTimeSeriesStore function CreateEnsembleTimeSeriesStore \u00b6 virtual EnsembleTimeSeriesStore < double > * CreateEnsembleTimeSeriesStore () const Reimplements : datatypes::timeseries::TimeSeriesSourceInfoImpl::CreateEnsembleTimeSeriesStore function CreateTimeSeriesEnsembleTimeSeriesStore \u00b6 virtual TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore () const Reimplements : datatypes::timeseries::TimeSeriesSourceInfoImpl::CreateTimeSeriesEnsembleTimeSeriesStore function GetSerializableConfiguration \u00b6 virtual std :: map < string , string > GetSerializableConfiguration () const Reimplements : datatypes::timeseries::TimeSeriesSourceInfoImpl::GetSerializableConfiguration Public Attributes Documentation \u00b6 variable FileKey \u00b6 static const string FileKey ; variable VarKey \u00b6 static const string VarKey ; variable IdentifierKey \u00b6 static const string IdentifierKey ; variable IndexKey \u00b6 static const string IndexKey ; variable TypeKey \u00b6 static const string TypeKey ; variable StorageTypeSingleNetcdfFile \u00b6 static const string StorageTypeSingleNetcdfFile ; variable StorageTypeMultipleNetcdfFiles \u00b6 static const string StorageTypeMultipleNetcdfFiles ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::NetCdfSourceInfo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSourceInfo/#datatypestimeseriesnetcdfsourceinfo","text":"#include <time_series_store.hpp> Inherits from datatypes::timeseries::TimeSeriesSourceInfoImpl","title":"datatypes::timeseries::NetCdfSourceInfo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSourceInfo/#public-functions","text":"Name NetCdfSourceInfo () NetCdfSourceInfo (const string & dataId, const string & fileName, const string & ncVarName, const string & identifier =\"\", int index =-1, const string & storageType =\"\", const string & timeStep =\"\", const string & start =\"\", int length =-1, int ensembleSize =-1, int ensembleLength =-1, const string & ensembleTimeStep =\"\", const string & containingDirectory =\"\") NetCdfSourceInfo (const string & dataId, const string & fileName, const string & ncVarName, const string & identifier, int index, const string & storageType, const TimeStep & timeStep, const ptime & start, int length, int ensembleSize, int ensembleLength, const TimeStep & ensembleTimeStep) virtual TimeSeriesSourceInfoImpl * Clone () const virtual bool ApplyRootDir (const string & rootDir) virtual SingleTimeSeriesStore < double > * CreateSingleTimeSeriesStore () const virtual EnsembleTimeSeriesStore < double > * CreateEnsembleTimeSeriesStore () const virtual TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore () const virtual std::map< string, string > GetSerializableConfiguration () const","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSourceInfo/#public-attributes","text":"Name const string FileKey const string VarKey const string IdentifierKey const string IndexKey const string TypeKey const string StorageTypeSingleNetcdfFile const string StorageTypeMultipleNetcdfFiles","title":"Public Attributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSourceInfo/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::TimeSeriesSourceInfoImpl Name virtual ~TimeSeriesSourceInfoImpl () string OptionalApplyRootDir (const std::string & rootDir, const std::string & filename, bool checkDirExists =true) Protected Functions inherited from datatypes::timeseries::TimeSeriesSourceInfoImpl Name TimeSeriesSourceInfoImpl () TimeSeriesSourceInfoImpl (const TimeSeriesSourceInfoImpl & src)","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSourceInfo/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSourceInfo/#function-netcdfsourceinfo","text":"inline NetCdfSourceInfo ()","title":"function NetCdfSourceInfo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSourceInfo/#function-netcdfsourceinfo_1","text":"NetCdfSourceInfo ( const string & dataId , const string & fileName , const string & ncVarName , const string & identifier = \"\" , int index = -1 , const string & storageType = \"\" , const string & timeStep = \"\" , const string & start = \"\" , int length = -1 , int ensembleSize = -1 , int ensembleLength = -1 , const string & ensembleTimeStep = \"\" , const string & containingDirectory = \"\" )","title":"function NetCdfSourceInfo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSourceInfo/#function-netcdfsourceinfo_2","text":"NetCdfSourceInfo ( const string & dataId , const string & fileName , const string & ncVarName , const string & identifier , int index , const string & storageType , const TimeStep & timeStep , const ptime & start , int length , int ensembleSize , int ensembleLength , const TimeStep & ensembleTimeStep )","title":"function NetCdfSourceInfo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSourceInfo/#function-clone","text":"virtual TimeSeriesSourceInfoImpl * Clone () const Reimplements : datatypes::timeseries::TimeSeriesSourceInfoImpl::Clone","title":"function Clone"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSourceInfo/#function-applyrootdir","text":"virtual bool ApplyRootDir ( const string & rootDir ) Reimplements : datatypes::timeseries::TimeSeriesSourceInfoImpl::ApplyRootDir","title":"function ApplyRootDir"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSourceInfo/#function-createsingletimeseriesstore","text":"virtual SingleTimeSeriesStore < double > * CreateSingleTimeSeriesStore () const Reimplements : datatypes::timeseries::TimeSeriesSourceInfoImpl::CreateSingleTimeSeriesStore","title":"function CreateSingleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSourceInfo/#function-createensembletimeseriesstore","text":"virtual EnsembleTimeSeriesStore < double > * CreateEnsembleTimeSeriesStore () const Reimplements : datatypes::timeseries::TimeSeriesSourceInfoImpl::CreateEnsembleTimeSeriesStore","title":"function CreateEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSourceInfo/#function-createtimeseriesensembletimeseriesstore","text":"virtual TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore () const Reimplements : datatypes::timeseries::TimeSeriesSourceInfoImpl::CreateTimeSeriesEnsembleTimeSeriesStore","title":"function CreateTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSourceInfo/#function-getserializableconfiguration","text":"virtual std :: map < string , string > GetSerializableConfiguration () const Reimplements : datatypes::timeseries::TimeSeriesSourceInfoImpl::GetSerializableConfiguration","title":"function GetSerializableConfiguration"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSourceInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSourceInfo/#variable-filekey","text":"static const string FileKey ;","title":"variable FileKey"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSourceInfo/#variable-varkey","text":"static const string VarKey ;","title":"variable VarKey"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSourceInfo/#variable-identifierkey","text":"static const string IdentifierKey ;","title":"variable IdentifierKey"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSourceInfo/#variable-indexkey","text":"static const string IndexKey ;","title":"variable IndexKey"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSourceInfo/#variable-typekey","text":"static const string TypeKey ;","title":"variable TypeKey"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSourceInfo/#variable-storagetypesinglenetcdffile","text":"static const string StorageTypeSingleNetcdfFile ;","title":"variable StorageTypeSingleNetcdfFile"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfSourceInfo/#variable-storagetypemultiplenetcdffiles","text":"static const string StorageTypeMultipleNetcdfFiles ; Updated on 2022-08-20 at 19:28:22 +1000","title":"variable StorageTypeMultipleNetcdfFiles"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/","text":"datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore \u00b6 More... #include <time_series_io.hpp> Inherits from datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore< double > , datatypes::timeseries::SingleNetCdfFileStore< double > , datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T > , datatypes::timeseries::IdentifiersProvider , datatypes::timeseries::TimeSeriesInfoProvider , datatypes::timeseries::DataDescriptor Public Types \u00b6 Name using typename CommonTypes < T >:: SeriesType SeriesType using typename CommonTypes < T >:: PtrSeriesType PtrSeriesType using typename CommonTypes < T >:: EnsemblePtrType EnsemblePtrType using typename CommonTypes < T >:: PtrEnsemblePtrType PtrEnsemblePtrType using typename CommonTypes < T >:: TSeriesEnsemblePtrType TSeriesEnsemblePtrType using typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType PtrTSeriesEnsemblePtrType using typename EnsemblePtrType::ElementType ElementType Public Functions \u00b6 Name NetCdfTimeSeriesEnsembleTimeSeriesStore (const string & filename, const size_t nEns, const vector< double > & leadTimeVar, const string & timeUnits, const vector< double > & timeVar, const vector< string > & stationIds, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName, const string & identifier =\"\") NetCdfTimeSeriesEnsembleTimeSeriesStore (const string & filename, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName, const string & identifier =\"\") NetCdfTimeSeriesEnsembleTimeSeriesStore (const string & fname, const string & ncVarName, const string & varIdentifier, bool writeMode =false) virtual EnsembleForecastTimeSeries < TTimeSeries < T > > * GetSeries (const string & dataId) virtual vector< string > GetIdentifiers () const void SetIdentifier (string ident) Sets the current station identifier. PtrEnsemblePtrType GetForecasts (size_t i) Gets the ensemble forecast for a given index in the time dimension. void SetForecasts (size_t i, MultiTimeSeries < TimeSeries * > * forecasts) virtual ~NetCdfTimeSeriesEnsembleTimeSeriesStore () virtual MultiTimeSeries < TTimeSeries < T > * > * Read (const string & ensembleIdentifier) override size_t GetIndexForTime (const ptime & dateIndex) ptime GetTimeForIndex (size_t index) virtual size_t GetLength () const virtual TimeStep GetTimeStep () const TimeStep GetLeadTimeStep () const virtual ptime GetStart () const ptime GetEnd () const virtual string GetDataSummary () const virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const virtual void Allocate (size_t length, PtrEnsemblePtrType value) virtual void AllocateValues (const vector< PtrEnsemblePtrType > & values) virtual void SetSeries (const string & dataId, PtrTSeriesEnsemblePtrType value) virtual void SetItem (const string & dataId, size_t index, PtrEnsemblePtrType value) virtual void SetItem (const string & dataId, size_t index, const EnsemblePtrType & value) virtual void SetLength (size_t length) virtual void SetStart (ptime start) virtual void SetTimeStep (const TimeStep & ) virtual bool IsActive () string Dimensions () Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore< double > Name virtual ~WritableTimeSeriesEnsembleTimeSeriesStore () Public Functions inherited from datatypes::timeseries::SingleNetCdfFileStore< double > Name virtual ~SingleNetCdfFileStore () virtual void Close () bool HasNcAccess () size_t GetEnsembleSize () const size_t GetLeadTimeCount () const size_t GetTimeLength () const ptime TimeForIndex (size_t timeIndex) const vector< ptime > GetTimeDim () const vector< double > GetLeadTimeDim () const size_t IndexForIdentifier (const string & identifier) const VariableAttributes GetVarAttributes () GlobalAttributes GetGlobalAttributes () Protected Functions inherited from datatypes::timeseries::SingleNetCdfFileStore< double > Name SingleNetCdfFileStore () SingleNetCdfFileStore (const string & fname, const size_t nEns, const vector< double > & leadTimeVar, const string & timeUnits, const vector< double > & timeVar, const vector< string > & stationIds, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName =\"\", const string & identifier =\"\", const string & leadTimeUnits =\"\") Constructor to create a new SWIFT netCDF file. SingleNetCdfFileStore (const string & fname, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName =\"\", const string & identifier =\"\") SingleNetCdfFileStore (const string & fname, const string & ncVarName =\"\", const string & identifier =\"\", bool writeMode =false) void Init (const string & filename, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes) void MoveFrom ( SingleNetCdfFileStore & src) void CopyFrom (const SingleNetCdfFileStore & src) string GetNcVarName (bool allowDiscovery =true) const string DataSummaryForIdentifier () const string GetDefaultDataSummary () const size_t IndexForIdentifier (bool strict =true) const virtual bool HasIdentifier () const virtual string GetIdentifier (bool strict =true) const SwiftNetCDFAccess * GetNcAccess () const string & GetFileName () Public Functions inherited from datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T > Name virtual ~TimeSeriesEnsembleTimeSeriesStore () virtual PtrEnsemblePtrType GetItem (const string & dataId, size_t fcastIndex) virtual PtrSeriesType GetItem (const string & dataId, size_t fcastIndex, size_t ensIndex) virtual size_t GetEnsembleSize (const string & dataId, size_t fcastIndex) const Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId) Public Functions inherited from datatypes::timeseries::TimeSeriesInfoProvider Name virtual ~TimeSeriesInfoProvider () Detailed Description \u00b6 template < typename T = double > class datatypes :: timeseries :: NetCdfTimeSeriesEnsembleTimeSeriesStore ; Public Types Documentation \u00b6 using SeriesType \u00b6 using datatypes :: timeseries :: NetCdfTimeSeriesEnsembleTimeSeriesStore < T >:: SeriesType = typename CommonTypes < T >:: SeriesType ; using PtrSeriesType \u00b6 using datatypes :: timeseries :: NetCdfTimeSeriesEnsembleTimeSeriesStore < T >:: PtrSeriesType = typename CommonTypes < T >:: PtrSeriesType ; using EnsemblePtrType \u00b6 using datatypes :: timeseries :: NetCdfTimeSeriesEnsembleTimeSeriesStore < T >:: EnsemblePtrType = typename CommonTypes < T >:: EnsemblePtrType ; using PtrEnsemblePtrType \u00b6 using datatypes :: timeseries :: NetCdfTimeSeriesEnsembleTimeSeriesStore < T >:: PtrEnsemblePtrType = typename CommonTypes < T >:: PtrEnsemblePtrType ; using TSeriesEnsemblePtrType \u00b6 using datatypes :: timeseries :: NetCdfTimeSeriesEnsembleTimeSeriesStore < T >:: TSeriesEnsemblePtrType = typename CommonTypes < T >:: TSeriesEnsemblePtrType ; using PtrTSeriesEnsemblePtrType \u00b6 using datatypes :: timeseries :: NetCdfTimeSeriesEnsembleTimeSeriesStore < T >:: PtrTSeriesEnsemblePtrType = typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType ; using ElementType \u00b6 using datatypes :: timeseries :: NetCdfTimeSeriesEnsembleTimeSeriesStore < T >:: ElementType = typename EnsemblePtrType :: ElementType ; Public Functions Documentation \u00b6 function NetCdfTimeSeriesEnsembleTimeSeriesStore \u00b6 inline NetCdfTimeSeriesEnsembleTimeSeriesStore ( const string & filename , const size_t nEns , const vector < double > & leadTimeVar , const string & timeUnits , const vector < double > & timeVar , const vector < string > & stationIds , const std :: map < string , VariableDefinition > & varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName , const string & identifier = \"\" ) function NetCdfTimeSeriesEnsembleTimeSeriesStore \u00b6 inline NetCdfTimeSeriesEnsembleTimeSeriesStore ( const string & filename , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition > & varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName , const string & identifier = \"\" ) function NetCdfTimeSeriesEnsembleTimeSeriesStore \u00b6 inline NetCdfTimeSeriesEnsembleTimeSeriesStore ( const string & fname , const string & ncVarName , const string & varIdentifier , bool writeMode = false ) function GetSeries \u00b6 inline virtual EnsembleForecastTimeSeries < TTimeSeries < T > > * GetSeries ( const string & dataId ) Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetSeries function GetIdentifiers \u00b6 inline virtual vector < string > GetIdentifiers () const Reimplements : datatypes::timeseries::SingleNetCdfFileStore::GetIdentifiers function SetIdentifier \u00b6 inline void SetIdentifier ( string ident ) Sets the current station identifier. Parameters : ident String identifier to set as the identifier the NetCDF store is to operate on. function GetForecasts \u00b6 inline PtrEnsemblePtrType GetForecasts ( size_t i ) Gets the ensemble forecast for a given index in the time dimension. Parameters : i Zero-based index of the time step of interest. Return : a pointer to a new MultiTimeSeries . function SetForecasts \u00b6 inline void SetForecasts ( size_t i , MultiTimeSeries < TimeSeries * > * forecasts ) function ~NetCdfTimeSeriesEnsembleTimeSeriesStore \u00b6 inline virtual ~ NetCdfTimeSeriesEnsembleTimeSeriesStore () function Read \u00b6 inline virtual MultiTimeSeries < TTimeSeries < T > * > * Read ( const string & ensembleIdentifier ) override Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::Read function GetIndexForTime \u00b6 inline size_t GetIndexForTime ( const ptime & dateIndex ) function GetTimeForIndex \u00b6 inline ptime GetTimeForIndex ( size_t index ) function GetLength \u00b6 inline virtual size_t GetLength () const Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetLength function GetTimeStep \u00b6 inline virtual TimeStep GetTimeStep () const Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetTimeStep function GetLeadTimeStep \u00b6 inline TimeStep GetLeadTimeStep () const function GetStart \u00b6 inline virtual ptime GetStart () const Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetStart function GetEnd \u00b6 inline ptime GetEnd () const function GetDataSummary \u00b6 inline virtual string GetDataSummary () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataSummary function GetDataDimensionsDescription \u00b6 inline virtual vector < DataDimensionDescriptor > GetDataDimensionsDescription () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataDimensionsDescription function Allocate \u00b6 inline virtual void Allocate ( size_t length , PtrEnsemblePtrType value ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::Allocate function AllocateValues \u00b6 inline virtual void AllocateValues ( const vector < PtrEnsemblePtrType > & values ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::AllocateValues function SetSeries \u00b6 inline virtual void SetSeries ( const string & dataId , PtrTSeriesEnsemblePtrType value ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetSeries function SetItem \u00b6 inline virtual void SetItem ( const string & dataId , size_t index , PtrEnsemblePtrType value ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetItem function SetItem \u00b6 inline virtual void SetItem ( const string & dataId , size_t index , const EnsemblePtrType & value ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetItem function SetLength \u00b6 inline virtual void SetLength ( size_t length ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetLength function SetStart \u00b6 inline virtual void SetStart ( ptime start ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetStart function SetTimeStep \u00b6 inline virtual void SetTimeStep ( const TimeStep & ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetTimeStep function IsActive \u00b6 inline virtual bool IsActive () Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::IsActive function Dimensions \u00b6 static inline string Dimensions () Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#datatypestimeseriesnetcdftimeseriesensembletimeseriesstore","text":"More... #include <time_series_io.hpp> Inherits from datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore< double > , datatypes::timeseries::SingleNetCdfFileStore< double > , datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T > , datatypes::timeseries::IdentifiersProvider , datatypes::timeseries::TimeSeriesInfoProvider , datatypes::timeseries::DataDescriptor","title":"datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#public-types","text":"Name using typename CommonTypes < T >:: SeriesType SeriesType using typename CommonTypes < T >:: PtrSeriesType PtrSeriesType using typename CommonTypes < T >:: EnsemblePtrType EnsemblePtrType using typename CommonTypes < T >:: PtrEnsemblePtrType PtrEnsemblePtrType using typename CommonTypes < T >:: TSeriesEnsemblePtrType TSeriesEnsemblePtrType using typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType PtrTSeriesEnsemblePtrType using typename EnsemblePtrType::ElementType ElementType","title":"Public Types"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#public-functions","text":"Name NetCdfTimeSeriesEnsembleTimeSeriesStore (const string & filename, const size_t nEns, const vector< double > & leadTimeVar, const string & timeUnits, const vector< double > & timeVar, const vector< string > & stationIds, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName, const string & identifier =\"\") NetCdfTimeSeriesEnsembleTimeSeriesStore (const string & filename, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName, const string & identifier =\"\") NetCdfTimeSeriesEnsembleTimeSeriesStore (const string & fname, const string & ncVarName, const string & varIdentifier, bool writeMode =false) virtual EnsembleForecastTimeSeries < TTimeSeries < T > > * GetSeries (const string & dataId) virtual vector< string > GetIdentifiers () const void SetIdentifier (string ident) Sets the current station identifier. PtrEnsemblePtrType GetForecasts (size_t i) Gets the ensemble forecast for a given index in the time dimension. void SetForecasts (size_t i, MultiTimeSeries < TimeSeries * > * forecasts) virtual ~NetCdfTimeSeriesEnsembleTimeSeriesStore () virtual MultiTimeSeries < TTimeSeries < T > * > * Read (const string & ensembleIdentifier) override size_t GetIndexForTime (const ptime & dateIndex) ptime GetTimeForIndex (size_t index) virtual size_t GetLength () const virtual TimeStep GetTimeStep () const TimeStep GetLeadTimeStep () const virtual ptime GetStart () const ptime GetEnd () const virtual string GetDataSummary () const virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const virtual void Allocate (size_t length, PtrEnsemblePtrType value) virtual void AllocateValues (const vector< PtrEnsemblePtrType > & values) virtual void SetSeries (const string & dataId, PtrTSeriesEnsemblePtrType value) virtual void SetItem (const string & dataId, size_t index, PtrEnsemblePtrType value) virtual void SetItem (const string & dataId, size_t index, const EnsemblePtrType & value) virtual void SetLength (size_t length) virtual void SetStart (ptime start) virtual void SetTimeStep (const TimeStep & ) virtual bool IsActive () string Dimensions ()","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore< double > Name virtual ~WritableTimeSeriesEnsembleTimeSeriesStore () Public Functions inherited from datatypes::timeseries::SingleNetCdfFileStore< double > Name virtual ~SingleNetCdfFileStore () virtual void Close () bool HasNcAccess () size_t GetEnsembleSize () const size_t GetLeadTimeCount () const size_t GetTimeLength () const ptime TimeForIndex (size_t timeIndex) const vector< ptime > GetTimeDim () const vector< double > GetLeadTimeDim () const size_t IndexForIdentifier (const string & identifier) const VariableAttributes GetVarAttributes () GlobalAttributes GetGlobalAttributes () Protected Functions inherited from datatypes::timeseries::SingleNetCdfFileStore< double > Name SingleNetCdfFileStore () SingleNetCdfFileStore (const string & fname, const size_t nEns, const vector< double > & leadTimeVar, const string & timeUnits, const vector< double > & timeVar, const vector< string > & stationIds, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName =\"\", const string & identifier =\"\", const string & leadTimeUnits =\"\") Constructor to create a new SWIFT netCDF file. SingleNetCdfFileStore (const string & fname, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName =\"\", const string & identifier =\"\") SingleNetCdfFileStore (const string & fname, const string & ncVarName =\"\", const string & identifier =\"\", bool writeMode =false) void Init (const string & filename, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes) void MoveFrom ( SingleNetCdfFileStore & src) void CopyFrom (const SingleNetCdfFileStore & src) string GetNcVarName (bool allowDiscovery =true) const string DataSummaryForIdentifier () const string GetDefaultDataSummary () const size_t IndexForIdentifier (bool strict =true) const virtual bool HasIdentifier () const virtual string GetIdentifier (bool strict =true) const SwiftNetCDFAccess * GetNcAccess () const string & GetFileName () Public Functions inherited from datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T > Name virtual ~TimeSeriesEnsembleTimeSeriesStore () virtual PtrEnsemblePtrType GetItem (const string & dataId, size_t fcastIndex) virtual PtrSeriesType GetItem (const string & dataId, size_t fcastIndex, size_t ensIndex) virtual size_t GetEnsembleSize (const string & dataId, size_t fcastIndex) const Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId) Public Functions inherited from datatypes::timeseries::TimeSeriesInfoProvider Name virtual ~TimeSeriesInfoProvider ()","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#detailed-description","text":"template < typename T = double > class datatypes :: timeseries :: NetCdfTimeSeriesEnsembleTimeSeriesStore ;","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#using-seriestype","text":"using datatypes :: timeseries :: NetCdfTimeSeriesEnsembleTimeSeriesStore < T >:: SeriesType = typename CommonTypes < T >:: SeriesType ;","title":"using SeriesType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#using-ptrseriestype","text":"using datatypes :: timeseries :: NetCdfTimeSeriesEnsembleTimeSeriesStore < T >:: PtrSeriesType = typename CommonTypes < T >:: PtrSeriesType ;","title":"using PtrSeriesType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#using-ensembleptrtype","text":"using datatypes :: timeseries :: NetCdfTimeSeriesEnsembleTimeSeriesStore < T >:: EnsemblePtrType = typename CommonTypes < T >:: EnsemblePtrType ;","title":"using EnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#using-ptrensembleptrtype","text":"using datatypes :: timeseries :: NetCdfTimeSeriesEnsembleTimeSeriesStore < T >:: PtrEnsemblePtrType = typename CommonTypes < T >:: PtrEnsemblePtrType ;","title":"using PtrEnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#using-tseriesensembleptrtype","text":"using datatypes :: timeseries :: NetCdfTimeSeriesEnsembleTimeSeriesStore < T >:: TSeriesEnsemblePtrType = typename CommonTypes < T >:: TSeriesEnsemblePtrType ;","title":"using TSeriesEnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#using-ptrtseriesensembleptrtype","text":"using datatypes :: timeseries :: NetCdfTimeSeriesEnsembleTimeSeriesStore < T >:: PtrTSeriesEnsemblePtrType = typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType ;","title":"using PtrTSeriesEnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#using-elementtype","text":"using datatypes :: timeseries :: NetCdfTimeSeriesEnsembleTimeSeriesStore < T >:: ElementType = typename EnsemblePtrType :: ElementType ;","title":"using ElementType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-netcdftimeseriesensembletimeseriesstore","text":"inline NetCdfTimeSeriesEnsembleTimeSeriesStore ( const string & filename , const size_t nEns , const vector < double > & leadTimeVar , const string & timeUnits , const vector < double > & timeVar , const vector < string > & stationIds , const std :: map < string , VariableDefinition > & varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName , const string & identifier = \"\" )","title":"function NetCdfTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-netcdftimeseriesensembletimeseriesstore_1","text":"inline NetCdfTimeSeriesEnsembleTimeSeriesStore ( const string & filename , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition > & varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName , const string & identifier = \"\" )","title":"function NetCdfTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-netcdftimeseriesensembletimeseriesstore_2","text":"inline NetCdfTimeSeriesEnsembleTimeSeriesStore ( const string & fname , const string & ncVarName , const string & varIdentifier , bool writeMode = false )","title":"function NetCdfTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-getseries","text":"inline virtual EnsembleForecastTimeSeries < TTimeSeries < T > > * GetSeries ( const string & dataId ) Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetSeries","title":"function GetSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-getidentifiers","text":"inline virtual vector < string > GetIdentifiers () const Reimplements : datatypes::timeseries::SingleNetCdfFileStore::GetIdentifiers","title":"function GetIdentifiers"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-setidentifier","text":"inline void SetIdentifier ( string ident ) Sets the current station identifier. Parameters : ident String identifier to set as the identifier the NetCDF store is to operate on.","title":"function SetIdentifier"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-getforecasts","text":"inline PtrEnsemblePtrType GetForecasts ( size_t i ) Gets the ensemble forecast for a given index in the time dimension. Parameters : i Zero-based index of the time step of interest. Return : a pointer to a new MultiTimeSeries .","title":"function GetForecasts"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-setforecasts","text":"inline void SetForecasts ( size_t i , MultiTimeSeries < TimeSeries * > * forecasts )","title":"function SetForecasts"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-netcdftimeseriesensembletimeseriesstore_3","text":"inline virtual ~ NetCdfTimeSeriesEnsembleTimeSeriesStore ()","title":"function ~NetCdfTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-read","text":"inline virtual MultiTimeSeries < TTimeSeries < T > * > * Read ( const string & ensembleIdentifier ) override Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::Read","title":"function Read"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-getindexfortime","text":"inline size_t GetIndexForTime ( const ptime & dateIndex )","title":"function GetIndexForTime"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-gettimeforindex","text":"inline ptime GetTimeForIndex ( size_t index )","title":"function GetTimeForIndex"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-getlength","text":"inline virtual size_t GetLength () const Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetLength","title":"function GetLength"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-gettimestep","text":"inline virtual TimeStep GetTimeStep () const Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetTimeStep","title":"function GetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-getleadtimestep","text":"inline TimeStep GetLeadTimeStep () const","title":"function GetLeadTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-getstart","text":"inline virtual ptime GetStart () const Reimplements : datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetStart","title":"function GetStart"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-getend","text":"inline ptime GetEnd () const","title":"function GetEnd"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-getdatasummary","text":"inline virtual string GetDataSummary () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataSummary","title":"function GetDataSummary"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-getdatadimensionsdescription","text":"inline virtual vector < DataDimensionDescriptor > GetDataDimensionsDescription () const Reimplements : datatypes::timeseries::DataDescriptor::GetDataDimensionsDescription","title":"function GetDataDimensionsDescription"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-allocate","text":"inline virtual void Allocate ( size_t length , PtrEnsemblePtrType value ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::Allocate","title":"function Allocate"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-allocatevalues","text":"inline virtual void AllocateValues ( const vector < PtrEnsemblePtrType > & values ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::AllocateValues","title":"function AllocateValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-setseries","text":"inline virtual void SetSeries ( const string & dataId , PtrTSeriesEnsemblePtrType value ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetSeries","title":"function SetSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-setitem","text":"inline virtual void SetItem ( const string & dataId , size_t index , PtrEnsemblePtrType value ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetItem","title":"function SetItem"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-setitem_1","text":"inline virtual void SetItem ( const string & dataId , size_t index , const EnsemblePtrType & value ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetItem","title":"function SetItem"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-setlength","text":"inline virtual void SetLength ( size_t length ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetLength","title":"function SetLength"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-setstart","text":"inline virtual void SetStart ( ptime start ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetStart","title":"function SetStart"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-settimestep","text":"inline virtual void SetTimeStep ( const TimeStep & ) Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::SetTimeStep","title":"function SetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-isactive","text":"inline virtual bool IsActive () Reimplements : datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore::IsActive","title":"function IsActive"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NetCdfTimeSeriesEnsembleTimeSeriesStore/#function-dimensions","text":"static inline string Dimensions () Updated on 2022-08-20 at 19:28:22 +1000","title":"function Dimensions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NullPointerIsMissingPolicy/","text":"datatypes::timeseries::NullPointerIsMissingPolicy \u00b6 More... #include <time_series_strategies.hpp> Inherits from datatypes::timeseries::MissingValuePolicy< T > Public Functions \u00b6 Name virtual bool IsMissingValue (const T & a) const virtual T GetMissingValue () const virtual MissingValuePolicy < T > * Clone () const Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::MissingValuePolicy< T > Name virtual ~MissingValuePolicy () Detailed Description \u00b6 template < typename T > class datatypes :: timeseries :: NullPointerIsMissingPolicy ; Public Functions Documentation \u00b6 function IsMissingValue \u00b6 inline virtual bool IsMissingValue ( const T & a ) const Reimplements : datatypes::timeseries::MissingValuePolicy::IsMissingValue function GetMissingValue \u00b6 inline virtual T GetMissingValue () const Reimplements : datatypes::timeseries::MissingValuePolicy::GetMissingValue function Clone \u00b6 inline virtual MissingValuePolicy < T > * Clone () const Reimplements : datatypes::timeseries::MissingValuePolicy::Clone Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::NullPointerIsMissingPolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NullPointerIsMissingPolicy/#datatypestimeseriesnullpointerismissingpolicy","text":"More... #include <time_series_strategies.hpp> Inherits from datatypes::timeseries::MissingValuePolicy< T >","title":"datatypes::timeseries::NullPointerIsMissingPolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NullPointerIsMissingPolicy/#public-functions","text":"Name virtual bool IsMissingValue (const T & a) const virtual T GetMissingValue () const virtual MissingValuePolicy < T > * Clone () const","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NullPointerIsMissingPolicy/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::MissingValuePolicy< T > Name virtual ~MissingValuePolicy ()","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NullPointerIsMissingPolicy/#detailed-description","text":"template < typename T > class datatypes :: timeseries :: NullPointerIsMissingPolicy ;","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NullPointerIsMissingPolicy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NullPointerIsMissingPolicy/#function-ismissingvalue","text":"inline virtual bool IsMissingValue ( const T & a ) const Reimplements : datatypes::timeseries::MissingValuePolicy::IsMissingValue","title":"function IsMissingValue"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NullPointerIsMissingPolicy/#function-getmissingvalue","text":"inline virtual T GetMissingValue () const Reimplements : datatypes::timeseries::MissingValuePolicy::GetMissingValue","title":"function GetMissingValue"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1NullPointerIsMissingPolicy/#function-clone","text":"inline virtual MissingValuePolicy < T > * Clone () const Reimplements : datatypes::timeseries::MissingValuePolicy::Clone Updated on 2022-08-20 at 19:28:22 +1000","title":"function Clone"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/","text":"datatypes::timeseries::RegularTimeStepImplementation \u00b6 #include <time_step_implementation.h> Inherits from datatypes::timeseries::TimeStepImplementation Public Functions \u00b6 Name RegularTimeStepImplementation * GetHourly () RegularTimeStepImplementation * GetDaily () RegularTimeStepImplementation (const time_duration & stepDuration) virtual ~RegularTimeStepImplementation () virtual TimeStepImplementation * Clone () virtual bool Equals ( TimeStepImplementation * tsImpl) const virtual TimeStepImplementation * Multiply (int mult) const virtual TimeStepImplementation * Multiply (double mult) const virtual TimeStepImplementation * Divide (int divisor) const virtual const ptime AddIntSteps (const ptime & startTimeStep, int n) const virtual const ptime AddSteps (const ptime & startTimeStep, double mult) const virtual const time_duration GetTimeStepDuration (const ptime & startTimeStep) const virtual const void Increment (ptime * t) const virtual bool IsRegular () const virtual time_duration GetRegularStepDuration () const virtual std::string GetName () const Protected Functions \u00b6 Name virtual const double GetLinearIndexing (const ptime & start, const ptime & end) const Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::TimeStepImplementation Name virtual ~TimeStepImplementation () virtual const ptrdiff_t GetUpperNumSteps (const ptime & start, const ptime & end) const virtual const ptrdiff_t GetNumSteps (const ptime & start, const ptime & end) const virtual const ptrdiff_t GetOffset (const ptime & start, const ptime & end) const void CheckIsDateTime (const ptime & instant) Public Functions Documentation \u00b6 function GetHourly \u00b6 static RegularTimeStepImplementation * GetHourly () function GetDaily \u00b6 static RegularTimeStepImplementation * GetDaily () function RegularTimeStepImplementation \u00b6 RegularTimeStepImplementation ( const time_duration & stepDuration ) function ~RegularTimeStepImplementation \u00b6 virtual ~ RegularTimeStepImplementation () function Clone \u00b6 virtual TimeStepImplementation * Clone () Reimplements : datatypes::timeseries::TimeStepImplementation::Clone function Equals \u00b6 virtual bool Equals ( TimeStepImplementation * tsImpl ) const Reimplements : datatypes::timeseries::TimeStepImplementation::Equals function Multiply \u00b6 virtual TimeStepImplementation * Multiply ( int mult ) const Reimplements : datatypes::timeseries::TimeStepImplementation::Multiply function Multiply \u00b6 virtual TimeStepImplementation * Multiply ( double mult ) const Reimplements : datatypes::timeseries::TimeStepImplementation::Multiply function Divide \u00b6 virtual TimeStepImplementation * Divide ( int divisor ) const Reimplements : datatypes::timeseries::TimeStepImplementation::Divide function AddIntSteps \u00b6 virtual const ptime AddIntSteps ( const ptime & startTimeStep , int n ) const Reimplements : datatypes::timeseries::TimeStepImplementation::AddIntSteps function AddSteps \u00b6 virtual const ptime AddSteps ( const ptime & startTimeStep , double mult ) const Reimplements : datatypes::timeseries::TimeStepImplementation::AddSteps function GetTimeStepDuration \u00b6 virtual const time_duration GetTimeStepDuration ( const ptime & startTimeStep ) const Reimplements : datatypes::timeseries::TimeStepImplementation::GetTimeStepDuration function Increment \u00b6 virtual const void Increment ( ptime * t ) const Reimplements : datatypes::timeseries::TimeStepImplementation::Increment function IsRegular \u00b6 virtual bool IsRegular () const Reimplements : datatypes::timeseries::TimeStepImplementation::IsRegular function GetRegularStepDuration \u00b6 virtual time_duration GetRegularStepDuration () const Reimplements : datatypes::timeseries::TimeStepImplementation::GetRegularStepDuration function GetName \u00b6 virtual std :: string GetName () const Reimplements : datatypes::timeseries::TimeStepImplementation::GetName Protected Functions Documentation \u00b6 function GetLinearIndexing \u00b6 virtual const double GetLinearIndexing ( const ptime & start , const ptime & end ) const Reimplements : datatypes::timeseries::TimeStepImplementation::GetLinearIndexing Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::RegularTimeStepImplementation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/#datatypestimeseriesregulartimestepimplementation","text":"#include <time_step_implementation.h> Inherits from datatypes::timeseries::TimeStepImplementation","title":"datatypes::timeseries::RegularTimeStepImplementation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/#public-functions","text":"Name RegularTimeStepImplementation * GetHourly () RegularTimeStepImplementation * GetDaily () RegularTimeStepImplementation (const time_duration & stepDuration) virtual ~RegularTimeStepImplementation () virtual TimeStepImplementation * Clone () virtual bool Equals ( TimeStepImplementation * tsImpl) const virtual TimeStepImplementation * Multiply (int mult) const virtual TimeStepImplementation * Multiply (double mult) const virtual TimeStepImplementation * Divide (int divisor) const virtual const ptime AddIntSteps (const ptime & startTimeStep, int n) const virtual const ptime AddSteps (const ptime & startTimeStep, double mult) const virtual const time_duration GetTimeStepDuration (const ptime & startTimeStep) const virtual const void Increment (ptime * t) const virtual bool IsRegular () const virtual time_duration GetRegularStepDuration () const virtual std::string GetName () const","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/#protected-functions","text":"Name virtual const double GetLinearIndexing (const ptime & start, const ptime & end) const","title":"Protected Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::TimeStepImplementation Name virtual ~TimeStepImplementation () virtual const ptrdiff_t GetUpperNumSteps (const ptime & start, const ptime & end) const virtual const ptrdiff_t GetNumSteps (const ptime & start, const ptime & end) const virtual const ptrdiff_t GetOffset (const ptime & start, const ptime & end) const void CheckIsDateTime (const ptime & instant)","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/#function-gethourly","text":"static RegularTimeStepImplementation * GetHourly ()","title":"function GetHourly"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/#function-getdaily","text":"static RegularTimeStepImplementation * GetDaily ()","title":"function GetDaily"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/#function-regulartimestepimplementation","text":"RegularTimeStepImplementation ( const time_duration & stepDuration )","title":"function RegularTimeStepImplementation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/#function-regulartimestepimplementation_1","text":"virtual ~ RegularTimeStepImplementation ()","title":"function ~RegularTimeStepImplementation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/#function-clone","text":"virtual TimeStepImplementation * Clone () Reimplements : datatypes::timeseries::TimeStepImplementation::Clone","title":"function Clone"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/#function-equals","text":"virtual bool Equals ( TimeStepImplementation * tsImpl ) const Reimplements : datatypes::timeseries::TimeStepImplementation::Equals","title":"function Equals"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/#function-multiply","text":"virtual TimeStepImplementation * Multiply ( int mult ) const Reimplements : datatypes::timeseries::TimeStepImplementation::Multiply","title":"function Multiply"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/#function-multiply_1","text":"virtual TimeStepImplementation * Multiply ( double mult ) const Reimplements : datatypes::timeseries::TimeStepImplementation::Multiply","title":"function Multiply"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/#function-divide","text":"virtual TimeStepImplementation * Divide ( int divisor ) const Reimplements : datatypes::timeseries::TimeStepImplementation::Divide","title":"function Divide"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/#function-addintsteps","text":"virtual const ptime AddIntSteps ( const ptime & startTimeStep , int n ) const Reimplements : datatypes::timeseries::TimeStepImplementation::AddIntSteps","title":"function AddIntSteps"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/#function-addsteps","text":"virtual const ptime AddSteps ( const ptime & startTimeStep , double mult ) const Reimplements : datatypes::timeseries::TimeStepImplementation::AddSteps","title":"function AddSteps"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/#function-gettimestepduration","text":"virtual const time_duration GetTimeStepDuration ( const ptime & startTimeStep ) const Reimplements : datatypes::timeseries::TimeStepImplementation::GetTimeStepDuration","title":"function GetTimeStepDuration"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/#function-increment","text":"virtual const void Increment ( ptime * t ) const Reimplements : datatypes::timeseries::TimeStepImplementation::Increment","title":"function Increment"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/#function-isregular","text":"virtual bool IsRegular () const Reimplements : datatypes::timeseries::TimeStepImplementation::IsRegular","title":"function IsRegular"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/#function-getregularstepduration","text":"virtual time_duration GetRegularStepDuration () const Reimplements : datatypes::timeseries::TimeStepImplementation::GetRegularStepDuration","title":"function GetRegularStepDuration"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/#function-getname","text":"virtual std :: string GetName () const Reimplements : datatypes::timeseries::TimeStepImplementation::GetName","title":"function GetName"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1RegularTimeStepImplementation/#function-getlinearindexing","text":"virtual const double GetLinearIndexing ( const ptime & start , const ptime & end ) const Reimplements : datatypes::timeseries::TimeStepImplementation::GetLinearIndexing Updated on 2022-08-20 at 19:28:22 +1000","title":"function GetLinearIndexing"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage/","text":"datatypes::timeseries::SharedVectorStorage \u00b6 A storage strategy for time serie such that data is a shared state amongst several time series. More... #include <time_series_strategies.hpp> Inherits from datatypes::timeseries::StoragePolicy< double > , datatypes::timeseries::TimeSeriesInfoProvider Public Functions \u00b6 Name SharedVectorStorage () virtual size_t Size () const void Allocate (size_t length, T value) void AllocateValues (size_t length, const T * values) void AllocateValues (const vector< T > & values) void CopyTo (vector< T > & dest, size_t from =0, size_t to =-1) const virtual T & operator[] (const size_t i) virtual const T & operator[] (const size_t i) const virtual StoragePolicy < T > * Clone () const virtual size_t GetLength () const virtual TimeStep GetTimeStep () const override virtual ptime GetStart () const override virtual void SetTimeStep (const TimeStep & tStep) override virtual void SetStart (const ptime & start) override Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::StoragePolicy< double > Name virtual ~StoragePolicy () virtual bool ReadOnly () Protected Functions inherited from datatypes::timeseries::StoragePolicy< double > Name StoragePolicy (const StoragePolicy & src) StoragePolicy () Public Functions inherited from datatypes::timeseries::TimeSeriesInfoProvider Name virtual ~TimeSeriesInfoProvider () Detailed Description \u00b6 template < typename T = double > class datatypes :: timeseries :: SharedVectorStorage ; A storage strategy for time serie such that data is a shared state amongst several time series. Template Parameters : T The type of the elements in the time series. Public Functions Documentation \u00b6 function SharedVectorStorage \u00b6 inline SharedVectorStorage () function Size \u00b6 inline virtual size_t Size () const Reimplements : datatypes::timeseries::StoragePolicy::Size function Allocate \u00b6 inline void Allocate ( size_t length , T value ) function AllocateValues \u00b6 inline void AllocateValues ( size_t length , const T * values ) function AllocateValues \u00b6 inline void AllocateValues ( const vector < T > & values ) function CopyTo \u00b6 inline void CopyTo ( vector < T > & dest , size_t from = 0 , size_t to = -1 ) const function operator[] \u00b6 inline virtual T & operator []( const size_t i ) Reimplements : datatypes::timeseries::StoragePolicy::operator[] function operator[] \u00b6 inline virtual const T & operator []( const size_t i ) const Reimplements : datatypes::timeseries::StoragePolicy::operator[] function Clone \u00b6 inline virtual StoragePolicy < T > * Clone () const Reimplements : datatypes::timeseries::StoragePolicy::Clone function GetLength \u00b6 inline virtual size_t GetLength () const Reimplements : datatypes::timeseries::TimeSeriesInfoProvider::GetLength function GetTimeStep \u00b6 inline virtual TimeStep GetTimeStep () const override Reimplements : datatypes::timeseries::StoragePolicy::GetTimeStep function GetStart \u00b6 inline virtual ptime GetStart () const override Reimplements : datatypes::timeseries::StoragePolicy::GetStart function SetTimeStep \u00b6 inline virtual void SetTimeStep ( const TimeStep & tStep ) override Reimplements : datatypes::timeseries::StoragePolicy::SetTimeStep function SetStart \u00b6 inline virtual void SetStart ( const ptime & start ) override Reimplements : datatypes::timeseries::StoragePolicy::SetStart Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::SharedVectorStorage"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage/#datatypestimeseriessharedvectorstorage","text":"A storage strategy for time serie such that data is a shared state amongst several time series. More... #include <time_series_strategies.hpp> Inherits from datatypes::timeseries::StoragePolicy< double > , datatypes::timeseries::TimeSeriesInfoProvider","title":"datatypes::timeseries::SharedVectorStorage"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage/#public-functions","text":"Name SharedVectorStorage () virtual size_t Size () const void Allocate (size_t length, T value) void AllocateValues (size_t length, const T * values) void AllocateValues (const vector< T > & values) void CopyTo (vector< T > & dest, size_t from =0, size_t to =-1) const virtual T & operator[] (const size_t i) virtual const T & operator[] (const size_t i) const virtual StoragePolicy < T > * Clone () const virtual size_t GetLength () const virtual TimeStep GetTimeStep () const override virtual ptime GetStart () const override virtual void SetTimeStep (const TimeStep & tStep) override virtual void SetStart (const ptime & start) override","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::StoragePolicy< double > Name virtual ~StoragePolicy () virtual bool ReadOnly () Protected Functions inherited from datatypes::timeseries::StoragePolicy< double > Name StoragePolicy (const StoragePolicy & src) StoragePolicy () Public Functions inherited from datatypes::timeseries::TimeSeriesInfoProvider Name virtual ~TimeSeriesInfoProvider ()","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage/#detailed-description","text":"template < typename T = double > class datatypes :: timeseries :: SharedVectorStorage ; A storage strategy for time serie such that data is a shared state amongst several time series. Template Parameters : T The type of the elements in the time series.","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage/#function-sharedvectorstorage","text":"inline SharedVectorStorage ()","title":"function SharedVectorStorage"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage/#function-size","text":"inline virtual size_t Size () const Reimplements : datatypes::timeseries::StoragePolicy::Size","title":"function Size"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage/#function-allocate","text":"inline void Allocate ( size_t length , T value )","title":"function Allocate"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage/#function-allocatevalues","text":"inline void AllocateValues ( size_t length , const T * values )","title":"function AllocateValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage/#function-allocatevalues_1","text":"inline void AllocateValues ( const vector < T > & values )","title":"function AllocateValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage/#function-copyto","text":"inline void CopyTo ( vector < T > & dest , size_t from = 0 , size_t to = -1 ) const","title":"function CopyTo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage/#function-operator","text":"inline virtual T & operator []( const size_t i ) Reimplements : datatypes::timeseries::StoragePolicy::operator[]","title":"function operator[]"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage/#function-operator_1","text":"inline virtual const T & operator []( const size_t i ) const Reimplements : datatypes::timeseries::StoragePolicy::operator[]","title":"function operator[]"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage/#function-clone","text":"inline virtual StoragePolicy < T > * Clone () const Reimplements : datatypes::timeseries::StoragePolicy::Clone","title":"function Clone"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage/#function-getlength","text":"inline virtual size_t GetLength () const Reimplements : datatypes::timeseries::TimeSeriesInfoProvider::GetLength","title":"function GetLength"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage/#function-gettimestep","text":"inline virtual TimeStep GetTimeStep () const override Reimplements : datatypes::timeseries::StoragePolicy::GetTimeStep","title":"function GetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage/#function-getstart","text":"inline virtual ptime GetStart () const override Reimplements : datatypes::timeseries::StoragePolicy::GetStart","title":"function GetStart"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage/#function-settimestep","text":"inline virtual void SetTimeStep ( const TimeStep & tStep ) override Reimplements : datatypes::timeseries::StoragePolicy::SetTimeStep","title":"function SetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage/#function-setstart","text":"inline virtual void SetStart ( const ptime & start ) override Reimplements : datatypes::timeseries::StoragePolicy::SetStart Updated on 2022-08-20 at 19:28:22 +1000","title":"function SetStart"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage_1_1SharedData/","text":"datatypes::timeseries::SharedVectorStorage::SharedData \u00b6 Public Attributes \u00b6 Name vector< T > data ptime startDate TimeStep timeStep Public Attributes Documentation \u00b6 variable data \u00b6 vector < T > data ; variable startDate \u00b6 ptime startDate ; variable timeStep \u00b6 TimeStep timeStep ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::SharedVectorStorage::SharedData"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage_1_1SharedData/#datatypestimeseriessharedvectorstorageshareddata","text":"","title":"datatypes::timeseries::SharedVectorStorage::SharedData"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage_1_1SharedData/#public-attributes","text":"Name vector< T > data ptime startDate TimeStep timeStep","title":"Public Attributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage_1_1SharedData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage_1_1SharedData/#variable-data","text":"vector < T > data ;","title":"variable data"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage_1_1SharedData/#variable-startdate","text":"ptime startDate ;","title":"variable startDate"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SharedVectorStorage_1_1SharedData/#variable-timestep","text":"TimeStep timeStep ; Updated on 2022-08-20 at 19:28:22 +1000","title":"variable timeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/","text":"datatypes::timeseries::SingleNetCdfFileStore \u00b6 More... #include <time_series_io.hpp> Inherited by datatypes::timeseries::NetCdfEnsembleTimeSeriesStore< T > , datatypes::timeseries::NetCdfSingleSeriesStore< T > Public Functions \u00b6 Name virtual ~SingleNetCdfFileStore () virtual void Close () bool HasNcAccess () size_t GetEnsembleSize () const size_t GetLeadTimeCount () const size_t GetTimeLength () const TimeStep GetTimeStep () const ptime TimeForIndex (size_t timeIndex) const vector< ptime > GetTimeDim () const vector< double > GetLeadTimeDim () const ptime GetStart () const ptime GetEnd () const size_t IndexForIdentifier (const string & identifier) const VariableAttributes GetVarAttributes () GlobalAttributes GetGlobalAttributes () Protected Functions \u00b6 Name SingleNetCdfFileStore () SingleNetCdfFileStore (const string & fname, const size_t nEns, const vector< double > & leadTimeVar, const string & timeUnits, const vector< double > & timeVar, const vector< string > & stationIds, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName =\"\", const string & identifier =\"\", const string & leadTimeUnits =\"\") Constructor to create a new SWIFT netCDF file. SingleNetCdfFileStore (const string & fname, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName =\"\", const string & identifier =\"\") SingleNetCdfFileStore (const string & fname, const string & ncVarName =\"\", const string & identifier =\"\", bool writeMode =false) void Init (const string & filename, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes) void MoveFrom ( SingleNetCdfFileStore & src) void CopyFrom (const SingleNetCdfFileStore & src) string GetNcVarName (bool allowDiscovery =true) const string DataSummaryForIdentifier () const string GetDefaultDataSummary () const size_t IndexForIdentifier (bool strict =true) const virtual bool HasIdentifier () const virtual string GetIdentifier (bool strict =true) const void SetIdentifier (string ident) Sets the current station identifier. virtual vector< string > GetIdentifiers () const SwiftNetCDFAccess * GetNcAccess () const string & GetFileName () Detailed Description \u00b6 template < typename T > class datatypes :: timeseries :: SingleNetCdfFileStore ; Public Functions Documentation \u00b6 function ~SingleNetCdfFileStore \u00b6 inline virtual ~ SingleNetCdfFileStore () function Close \u00b6 inline virtual void Close () function HasNcAccess \u00b6 inline bool HasNcAccess () function GetEnsembleSize \u00b6 inline size_t GetEnsembleSize () const function GetLeadTimeCount \u00b6 inline size_t GetLeadTimeCount () const function GetTimeLength \u00b6 inline size_t GetTimeLength () const function GetTimeStep \u00b6 inline TimeStep GetTimeStep () const function TimeForIndex \u00b6 inline ptime TimeForIndex ( size_t timeIndex ) const function GetTimeDim \u00b6 inline vector < ptime > GetTimeDim () const function GetLeadTimeDim \u00b6 inline vector < double > GetLeadTimeDim () const function GetStart \u00b6 inline ptime GetStart () const function GetEnd \u00b6 inline ptime GetEnd () const function IndexForIdentifier \u00b6 inline size_t IndexForIdentifier ( const string & identifier ) const function GetVarAttributes \u00b6 inline VariableAttributes GetVarAttributes () function GetGlobalAttributes \u00b6 inline GlobalAttributes GetGlobalAttributes () Protected Functions Documentation \u00b6 function SingleNetCdfFileStore \u00b6 inline SingleNetCdfFileStore () function SingleNetCdfFileStore \u00b6 inline SingleNetCdfFileStore ( const string & fname , const size_t nEns , const vector < double > & leadTimeVar , const string & timeUnits , const vector < double > & timeVar , const vector < string > & stationIds , const std :: map < string , VariableDefinition > & varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName = \"\" , const string & identifier = \"\" , const string & leadTimeUnits = \"\" ) Constructor to create a new SWIFT netCDF file. Parameters : filename name of the new file to create. nEns Size of the ensembles nLead Length of the lead time for each of the time series in the ensemble forecast for a given time. timeUnits Units of the temporal dimension(s). timeVar The values of the \"main\" time dimension, consistent with the temporal units given with the previous parameter stationIds List of identifiers for the stations. leadTimeUnits Units of the lead time dimension (if applicable) function SingleNetCdfFileStore \u00b6 inline SingleNetCdfFileStore ( const string & fname , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition > & varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName = \"\" , const string & identifier = \"\" ) function SingleNetCdfFileStore \u00b6 inline SingleNetCdfFileStore ( const string & fname , const string & ncVarName = \"\" , const string & identifier = \"\" , bool writeMode = false ) function Init \u00b6 inline void Init ( const string & filename , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition > & varDefinitions , const GlobalAttributes & globalAttributes ) function MoveFrom \u00b6 inline void MoveFrom ( SingleNetCdfFileStore & src ) function CopyFrom \u00b6 inline void CopyFrom ( const SingleNetCdfFileStore & src ) function GetNcVarName \u00b6 inline string GetNcVarName ( bool allowDiscovery = true ) const function DataSummaryForIdentifier \u00b6 inline string DataSummaryForIdentifier () const function GetDefaultDataSummary \u00b6 inline string GetDefaultDataSummary () const function IndexForIdentifier \u00b6 inline size_t IndexForIdentifier ( bool strict = true ) const function HasIdentifier \u00b6 inline virtual bool HasIdentifier () const function GetIdentifier \u00b6 inline virtual string GetIdentifier ( bool strict = true ) const function SetIdentifier \u00b6 inline void SetIdentifier ( string ident ) Sets the current station identifier. Parameters : ident String identifier to set as the identifier the NetCDF store is to operate on. function GetIdentifiers \u00b6 inline virtual vector < string > GetIdentifiers () const Reimplemented by : datatypes::timeseries::NetCdfSingleSeriesStore::GetIdentifiers , datatypes::timeseries::NetCdfEnsembleTimeSeriesStore::GetIdentifiers , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetIdentifiers function GetNcAccess \u00b6 inline SwiftNetCDFAccess * GetNcAccess () const function GetFileName \u00b6 inline string & GetFileName () Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::SingleNetCdfFileStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#datatypestimeseriessinglenetcdffilestore","text":"More... #include <time_series_io.hpp> Inherited by datatypes::timeseries::NetCdfEnsembleTimeSeriesStore< T > , datatypes::timeseries::NetCdfSingleSeriesStore< T >","title":"datatypes::timeseries::SingleNetCdfFileStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#public-functions","text":"Name virtual ~SingleNetCdfFileStore () virtual void Close () bool HasNcAccess () size_t GetEnsembleSize () const size_t GetLeadTimeCount () const size_t GetTimeLength () const TimeStep GetTimeStep () const ptime TimeForIndex (size_t timeIndex) const vector< ptime > GetTimeDim () const vector< double > GetLeadTimeDim () const ptime GetStart () const ptime GetEnd () const size_t IndexForIdentifier (const string & identifier) const VariableAttributes GetVarAttributes () GlobalAttributes GetGlobalAttributes ()","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#protected-functions","text":"Name SingleNetCdfFileStore () SingleNetCdfFileStore (const string & fname, const size_t nEns, const vector< double > & leadTimeVar, const string & timeUnits, const vector< double > & timeVar, const vector< string > & stationIds, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName =\"\", const string & identifier =\"\", const string & leadTimeUnits =\"\") Constructor to create a new SWIFT netCDF file. SingleNetCdfFileStore (const string & fname, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & ncVarName =\"\", const string & identifier =\"\") SingleNetCdfFileStore (const string & fname, const string & ncVarName =\"\", const string & identifier =\"\", bool writeMode =false) void Init (const string & filename, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes) void MoveFrom ( SingleNetCdfFileStore & src) void CopyFrom (const SingleNetCdfFileStore & src) string GetNcVarName (bool allowDiscovery =true) const string DataSummaryForIdentifier () const string GetDefaultDataSummary () const size_t IndexForIdentifier (bool strict =true) const virtual bool HasIdentifier () const virtual string GetIdentifier (bool strict =true) const void SetIdentifier (string ident) Sets the current station identifier. virtual vector< string > GetIdentifiers () const SwiftNetCDFAccess * GetNcAccess () const string & GetFileName ()","title":"Protected Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#detailed-description","text":"template < typename T > class datatypes :: timeseries :: SingleNetCdfFileStore ;","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-singlenetcdffilestore","text":"inline virtual ~ SingleNetCdfFileStore ()","title":"function ~SingleNetCdfFileStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-close","text":"inline virtual void Close ()","title":"function Close"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-hasncaccess","text":"inline bool HasNcAccess ()","title":"function HasNcAccess"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-getensemblesize","text":"inline size_t GetEnsembleSize () const","title":"function GetEnsembleSize"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-getleadtimecount","text":"inline size_t GetLeadTimeCount () const","title":"function GetLeadTimeCount"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-gettimelength","text":"inline size_t GetTimeLength () const","title":"function GetTimeLength"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-gettimestep","text":"inline TimeStep GetTimeStep () const","title":"function GetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-timeforindex","text":"inline ptime TimeForIndex ( size_t timeIndex ) const","title":"function TimeForIndex"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-gettimedim","text":"inline vector < ptime > GetTimeDim () const","title":"function GetTimeDim"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-getleadtimedim","text":"inline vector < double > GetLeadTimeDim () const","title":"function GetLeadTimeDim"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-getstart","text":"inline ptime GetStart () const","title":"function GetStart"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-getend","text":"inline ptime GetEnd () const","title":"function GetEnd"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-indexforidentifier","text":"inline size_t IndexForIdentifier ( const string & identifier ) const","title":"function IndexForIdentifier"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-getvarattributes","text":"inline VariableAttributes GetVarAttributes ()","title":"function GetVarAttributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-getglobalattributes","text":"inline GlobalAttributes GetGlobalAttributes ()","title":"function GetGlobalAttributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-singlenetcdffilestore_1","text":"inline SingleNetCdfFileStore ()","title":"function SingleNetCdfFileStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-singlenetcdffilestore_2","text":"inline SingleNetCdfFileStore ( const string & fname , const size_t nEns , const vector < double > & leadTimeVar , const string & timeUnits , const vector < double > & timeVar , const vector < string > & stationIds , const std :: map < string , VariableDefinition > & varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName = \"\" , const string & identifier = \"\" , const string & leadTimeUnits = \"\" ) Constructor to create a new SWIFT netCDF file. Parameters : filename name of the new file to create. nEns Size of the ensembles nLead Length of the lead time for each of the time series in the ensemble forecast for a given time. timeUnits Units of the temporal dimension(s). timeVar The values of the \"main\" time dimension, consistent with the temporal units given with the previous parameter stationIds List of identifiers for the stations. leadTimeUnits Units of the lead time dimension (if applicable)","title":"function SingleNetCdfFileStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-singlenetcdffilestore_3","text":"inline SingleNetCdfFileStore ( const string & fname , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition > & varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName = \"\" , const string & identifier = \"\" )","title":"function SingleNetCdfFileStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-singlenetcdffilestore_4","text":"inline SingleNetCdfFileStore ( const string & fname , const string & ncVarName = \"\" , const string & identifier = \"\" , bool writeMode = false )","title":"function SingleNetCdfFileStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-init","text":"inline void Init ( const string & filename , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition > & varDefinitions , const GlobalAttributes & globalAttributes )","title":"function Init"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-movefrom","text":"inline void MoveFrom ( SingleNetCdfFileStore & src )","title":"function MoveFrom"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-copyfrom","text":"inline void CopyFrom ( const SingleNetCdfFileStore & src )","title":"function CopyFrom"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-getncvarname","text":"inline string GetNcVarName ( bool allowDiscovery = true ) const","title":"function GetNcVarName"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-datasummaryforidentifier","text":"inline string DataSummaryForIdentifier () const","title":"function DataSummaryForIdentifier"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-getdefaultdatasummary","text":"inline string GetDefaultDataSummary () const","title":"function GetDefaultDataSummary"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-indexforidentifier_1","text":"inline size_t IndexForIdentifier ( bool strict = true ) const","title":"function IndexForIdentifier"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-hasidentifier","text":"inline virtual bool HasIdentifier () const","title":"function HasIdentifier"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-getidentifier","text":"inline virtual string GetIdentifier ( bool strict = true ) const","title":"function GetIdentifier"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-setidentifier","text":"inline void SetIdentifier ( string ident ) Sets the current station identifier. Parameters : ident String identifier to set as the identifier the NetCDF store is to operate on.","title":"function SetIdentifier"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-getidentifiers","text":"inline virtual vector < string > GetIdentifiers () const Reimplemented by : datatypes::timeseries::NetCdfSingleSeriesStore::GetIdentifiers , datatypes::timeseries::NetCdfEnsembleTimeSeriesStore::GetIdentifiers , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetIdentifiers","title":"function GetIdentifiers"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-getncaccess","text":"inline SwiftNetCDFAccess * GetNcAccess () const","title":"function GetNcAccess"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleNetCdfFileStore/#function-getfilename","text":"inline string & GetFileName () Updated on 2022-08-20 at 19:28:22 +1000","title":"function GetFileName"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleTimeSeriesStore/","text":"datatypes::timeseries::SingleTimeSeriesStore \u00b6 Interface definition for storages of single, univariate time series. More... #include <time_series_store.hpp> Inherits from datatypes::timeseries::IdentifiersProvider , datatypes::timeseries::DataDescriptor Inherited by datatypes::timeseries::NetCdfSingleSeriesStore< T > Public Functions \u00b6 Name virtual ~SingleTimeSeriesStore () virtual TTimeSeries < T > * Read () =0 virtual TTimeSeries < T > * Read (const string & collectionIdentifier) =0 virtual MultiTimeSeries < TTimeSeries < T > * > * ReadAllCollection () =0 Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () virtual vector< string > GetIdentifiers () const =0 vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId) Public Functions inherited from datatypes::timeseries::DataDescriptor Name virtual string GetDataSummary () const =0 virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const =0 Detailed Description \u00b6 template < typename T > class datatypes :: timeseries :: SingleTimeSeriesStore ; Interface definition for storages of single, univariate time series. Template Parameters : T The element type of the time series dealt with, typically double or float. Public Functions Documentation \u00b6 function ~SingleTimeSeriesStore \u00b6 inline virtual ~ SingleTimeSeriesStore () function Read \u00b6 virtual TTimeSeries < T > * Read () = 0 Reimplemented by : datatypes::tests::TestSingleTimeSeriesStore::Read , datatypes::timeseries::NetCdfSingleSeriesStore::Read function Read \u00b6 virtual TTimeSeries < T > * Read ( const string & collectionIdentifier ) = 0 Reimplemented by : datatypes::tests::TestSingleTimeSeriesStore::Read , datatypes::timeseries::NetCdfSingleSeriesStore::Read function ReadAllCollection \u00b6 virtual MultiTimeSeries < TTimeSeries < T > * > * ReadAllCollection () = 0 Reimplemented by : datatypes::tests::TestSingleTimeSeriesStore::ReadAllCollection , datatypes::timeseries::NetCdfSingleSeriesStore::ReadAllCollection Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::SingleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleTimeSeriesStore/#datatypestimeseriessingletimeseriesstore","text":"Interface definition for storages of single, univariate time series. More... #include <time_series_store.hpp> Inherits from datatypes::timeseries::IdentifiersProvider , datatypes::timeseries::DataDescriptor Inherited by datatypes::timeseries::NetCdfSingleSeriesStore< T >","title":"datatypes::timeseries::SingleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleTimeSeriesStore/#public-functions","text":"Name virtual ~SingleTimeSeriesStore () virtual TTimeSeries < T > * Read () =0 virtual TTimeSeries < T > * Read (const string & collectionIdentifier) =0 virtual MultiTimeSeries < TTimeSeries < T > * > * ReadAllCollection () =0","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleTimeSeriesStore/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () virtual vector< string > GetIdentifiers () const =0 vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId) Public Functions inherited from datatypes::timeseries::DataDescriptor Name virtual string GetDataSummary () const =0 virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const =0","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleTimeSeriesStore/#detailed-description","text":"template < typename T > class datatypes :: timeseries :: SingleTimeSeriesStore ; Interface definition for storages of single, univariate time series. Template Parameters : T The element type of the time series dealt with, typically double or float.","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleTimeSeriesStore/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleTimeSeriesStore/#function-singletimeseriesstore","text":"inline virtual ~ SingleTimeSeriesStore ()","title":"function ~SingleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleTimeSeriesStore/#function-read","text":"virtual TTimeSeries < T > * Read () = 0 Reimplemented by : datatypes::tests::TestSingleTimeSeriesStore::Read , datatypes::timeseries::NetCdfSingleSeriesStore::Read","title":"function Read"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleTimeSeriesStore/#function-read_1","text":"virtual TTimeSeries < T > * Read ( const string & collectionIdentifier ) = 0 Reimplemented by : datatypes::tests::TestSingleTimeSeriesStore::Read , datatypes::timeseries::NetCdfSingleSeriesStore::Read","title":"function Read"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SingleTimeSeriesStore/#function-readallcollection","text":"virtual MultiTimeSeries < TTimeSeries < T > * > * ReadAllCollection () = 0 Reimplemented by : datatypes::tests::TestSingleTimeSeriesStore::ReadAllCollection , datatypes::timeseries::NetCdfSingleSeriesStore::ReadAllCollection Updated on 2022-08-20 at 19:28:22 +1000","title":"function ReadAllCollection"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/","text":"datatypes::timeseries::StdVectorEnsembleStoragePolicy \u00b6 More... #include <time_series_strategies.hpp> Inherits from datatypes::timeseries::EnsembleStoragePolicy< TsType > Public Types \u00b6 Name typedef std::remove_pointer< TsType >::type Type typedef std::add_pointer< Type >::type PtrType typedef Type::ElementType ElementType Public Functions \u00b6 Name virtual void Reset (const vector< PtrType > & values, const ptime & startDate, const TimeStep & timeStep) StdVectorEnsembleStoragePolicy (const StdVectorEnsembleStoragePolicy < TsType > & src) StdVectorEnsembleStoragePolicy () ~StdVectorEnsembleStoragePolicy () StdVectorEnsembleStoragePolicy & operator= ( StdVectorEnsembleStoragePolicy && src) virtual void ResetSeries (const size_t & numSeries, const size_t & lengthSeries, const ptime & startDate, const TimeStep & timeStep) virtual TsType Get (size_t i) Type Get (size_t i) const virtual ElementType Get (size_t i, size_t tsIndex) virtual void Set (size_t i, size_t tsIndex, ElementType val) virtual void Set (size_t i, const Type & val) virtual vector< ElementType * > * GetValues () const virtual void CopyTo ( ElementType ** dest) const virtual size_t Size () const virtual size_t GetLength (size_t i) const virtual void Clear () virtual const vector< PtrType > & AsReadonlyVector () const virtual EnsembleStoragePolicy < TsType > * Clone () const Protected Functions \u00b6 Name virtual void OperatorEqualImpl (const EnsembleStoragePolicy < TsType > & src) Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::EnsembleStoragePolicy< TsType > Name EnsembleStoragePolicy () virtual ~EnsembleStoragePolicy () Detailed Description \u00b6 template < typename TsType > class datatypes :: timeseries :: StdVectorEnsembleStoragePolicy ; Public Types Documentation \u00b6 typedef Type \u00b6 typedef std :: remove_pointer < TsType >:: type datatypes :: timeseries :: StdVectorEnsembleStoragePolicy < TsType >:: Type ; typedef PtrType \u00b6 typedef std :: add_pointer < Type >:: type datatypes :: timeseries :: StdVectorEnsembleStoragePolicy < TsType >:: PtrType ; typedef ElementType \u00b6 typedef Type :: ElementType datatypes :: timeseries :: StdVectorEnsembleStoragePolicy < TsType >:: ElementType ; Public Functions Documentation \u00b6 function Reset \u00b6 inline virtual void Reset ( const vector < PtrType > & values , const ptime & startDate , const TimeStep & timeStep ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Reset function StdVectorEnsembleStoragePolicy \u00b6 inline StdVectorEnsembleStoragePolicy ( const StdVectorEnsembleStoragePolicy < TsType > & src ) function StdVectorEnsembleStoragePolicy \u00b6 inline StdVectorEnsembleStoragePolicy () function ~StdVectorEnsembleStoragePolicy \u00b6 inline ~ StdVectorEnsembleStoragePolicy () function operator= \u00b6 inline StdVectorEnsembleStoragePolicy & operator = ( StdVectorEnsembleStoragePolicy && src ) function ResetSeries \u00b6 inline virtual void ResetSeries ( const size_t & numSeries , const size_t & lengthSeries , const ptime & startDate , const TimeStep & timeStep ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::ResetSeries function Get \u00b6 inline virtual TsType Get ( size_t i ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Get function Get \u00b6 inline Type Get ( size_t i ) const function Get \u00b6 inline virtual ElementType Get ( size_t i , size_t tsIndex ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Get function Set \u00b6 inline virtual void Set ( size_t i , size_t tsIndex , ElementType val ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Set function Set \u00b6 inline virtual void Set ( size_t i , const Type & val ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Set function GetValues \u00b6 inline virtual vector < ElementType * > * GetValues () const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::GetValues function CopyTo \u00b6 inline virtual void CopyTo ( ElementType ** dest ) const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::CopyTo function Size \u00b6 inline virtual size_t Size () const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Size function GetLength \u00b6 inline virtual size_t GetLength ( size_t i ) const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::GetLength function Clear \u00b6 inline virtual void Clear () Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Clear function AsReadonlyVector \u00b6 inline virtual const vector < PtrType > & AsReadonlyVector () const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::AsReadonlyVector function Clone \u00b6 inline virtual EnsembleStoragePolicy < TsType > * Clone () const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Clone Protected Functions Documentation \u00b6 function OperatorEqualImpl \u00b6 inline virtual void OperatorEqualImpl ( const EnsembleStoragePolicy < TsType > & src ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::OperatorEqualImpl Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::StdVectorEnsembleStoragePolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#datatypestimeseriesstdvectorensemblestoragepolicy","text":"More... #include <time_series_strategies.hpp> Inherits from datatypes::timeseries::EnsembleStoragePolicy< TsType >","title":"datatypes::timeseries::StdVectorEnsembleStoragePolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#public-types","text":"Name typedef std::remove_pointer< TsType >::type Type typedef std::add_pointer< Type >::type PtrType typedef Type::ElementType ElementType","title":"Public Types"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#public-functions","text":"Name virtual void Reset (const vector< PtrType > & values, const ptime & startDate, const TimeStep & timeStep) StdVectorEnsembleStoragePolicy (const StdVectorEnsembleStoragePolicy < TsType > & src) StdVectorEnsembleStoragePolicy () ~StdVectorEnsembleStoragePolicy () StdVectorEnsembleStoragePolicy & operator= ( StdVectorEnsembleStoragePolicy && src) virtual void ResetSeries (const size_t & numSeries, const size_t & lengthSeries, const ptime & startDate, const TimeStep & timeStep) virtual TsType Get (size_t i) Type Get (size_t i) const virtual ElementType Get (size_t i, size_t tsIndex) virtual void Set (size_t i, size_t tsIndex, ElementType val) virtual void Set (size_t i, const Type & val) virtual vector< ElementType * > * GetValues () const virtual void CopyTo ( ElementType ** dest) const virtual size_t Size () const virtual size_t GetLength (size_t i) const virtual void Clear () virtual const vector< PtrType > & AsReadonlyVector () const virtual EnsembleStoragePolicy < TsType > * Clone () const","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#protected-functions","text":"Name virtual void OperatorEqualImpl (const EnsembleStoragePolicy < TsType > & src)","title":"Protected Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::EnsembleStoragePolicy< TsType > Name EnsembleStoragePolicy () virtual ~EnsembleStoragePolicy ()","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#detailed-description","text":"template < typename TsType > class datatypes :: timeseries :: StdVectorEnsembleStoragePolicy ;","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#typedef-type","text":"typedef std :: remove_pointer < TsType >:: type datatypes :: timeseries :: StdVectorEnsembleStoragePolicy < TsType >:: Type ;","title":"typedef Type"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#typedef-ptrtype","text":"typedef std :: add_pointer < Type >:: type datatypes :: timeseries :: StdVectorEnsembleStoragePolicy < TsType >:: PtrType ;","title":"typedef PtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#typedef-elementtype","text":"typedef Type :: ElementType datatypes :: timeseries :: StdVectorEnsembleStoragePolicy < TsType >:: ElementType ;","title":"typedef ElementType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#function-reset","text":"inline virtual void Reset ( const vector < PtrType > & values , const ptime & startDate , const TimeStep & timeStep ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Reset","title":"function Reset"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#function-stdvectorensemblestoragepolicy","text":"inline StdVectorEnsembleStoragePolicy ( const StdVectorEnsembleStoragePolicy < TsType > & src )","title":"function StdVectorEnsembleStoragePolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#function-stdvectorensemblestoragepolicy_1","text":"inline StdVectorEnsembleStoragePolicy ()","title":"function StdVectorEnsembleStoragePolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#function-stdvectorensemblestoragepolicy_2","text":"inline ~ StdVectorEnsembleStoragePolicy ()","title":"function ~StdVectorEnsembleStoragePolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#function-operator","text":"inline StdVectorEnsembleStoragePolicy & operator = ( StdVectorEnsembleStoragePolicy && src )","title":"function operator="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#function-resetseries","text":"inline virtual void ResetSeries ( const size_t & numSeries , const size_t & lengthSeries , const ptime & startDate , const TimeStep & timeStep ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::ResetSeries","title":"function ResetSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#function-get","text":"inline virtual TsType Get ( size_t i ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Get","title":"function Get"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#function-get_1","text":"inline Type Get ( size_t i ) const","title":"function Get"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#function-get_2","text":"inline virtual ElementType Get ( size_t i , size_t tsIndex ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Get","title":"function Get"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#function-set","text":"inline virtual void Set ( size_t i , size_t tsIndex , ElementType val ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Set","title":"function Set"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#function-set_1","text":"inline virtual void Set ( size_t i , const Type & val ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Set","title":"function Set"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#function-getvalues","text":"inline virtual vector < ElementType * > * GetValues () const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::GetValues","title":"function GetValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#function-copyto","text":"inline virtual void CopyTo ( ElementType ** dest ) const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::CopyTo","title":"function CopyTo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#function-size","text":"inline virtual size_t Size () const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Size","title":"function Size"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#function-getlength","text":"inline virtual size_t GetLength ( size_t i ) const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::GetLength","title":"function GetLength"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#function-clear","text":"inline virtual void Clear () Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Clear","title":"function Clear"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#function-asreadonlyvector","text":"inline virtual const vector < PtrType > & AsReadonlyVector () const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::AsReadonlyVector","title":"function AsReadonlyVector"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#function-clone","text":"inline virtual EnsembleStoragePolicy < TsType > * Clone () const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Clone","title":"function Clone"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StdVectorEnsembleStoragePolicy/#function-operatorequalimpl","text":"inline virtual void OperatorEqualImpl ( const EnsembleStoragePolicy < TsType > & src ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::OperatorEqualImpl Updated on 2022-08-20 at 19:28:22 +1000","title":"function OperatorEqualImpl"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StlVectorStorage/","text":"datatypes::timeseries::StlVectorStorage \u00b6 More... #include <time_series_strategies.hpp> Inherits from datatypes::timeseries::StoragePolicy< double > , datatypes::timeseries::TimeSeriesInfoProvider Public Functions \u00b6 Name StlVectorStorage () virtual size_t Size () const virtual size_t GetLength () const void Allocate (size_t length, T value) void AllocateValues (size_t length, const T * values) void AllocateValues (const vector< T > & values) void CopyTo (vector< T > & dest, size_t from =0, size_t to =-1) const virtual T & operator[] (const size_t i) virtual const T & operator[] (const size_t i) const virtual StoragePolicy < T > * Clone () const virtual TimeStep GetTimeStep () const override virtual ptime GetStart () const override virtual void SetTimeStep (const TimeStep & tStep) override virtual void SetStart (const ptime & start) override Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::StoragePolicy< double > Name virtual ~StoragePolicy () virtual bool ReadOnly () Protected Functions inherited from datatypes::timeseries::StoragePolicy< double > Name StoragePolicy (const StoragePolicy & src) StoragePolicy () Public Functions inherited from datatypes::timeseries::TimeSeriesInfoProvider Name virtual ~TimeSeriesInfoProvider () Detailed Description \u00b6 template < typename T = double > class datatypes :: timeseries :: StlVectorStorage ; Public Functions Documentation \u00b6 function StlVectorStorage \u00b6 inline StlVectorStorage () function Size \u00b6 inline virtual size_t Size () const Reimplements : datatypes::timeseries::StoragePolicy::Size function GetLength \u00b6 inline virtual size_t GetLength () const Reimplements : datatypes::timeseries::TimeSeriesInfoProvider::GetLength function Allocate \u00b6 inline void Allocate ( size_t length , T value ) function AllocateValues \u00b6 inline void AllocateValues ( size_t length , const T * values ) function AllocateValues \u00b6 inline void AllocateValues ( const vector < T > & values ) function CopyTo \u00b6 inline void CopyTo ( vector < T > & dest , size_t from = 0 , size_t to = -1 ) const function operator[] \u00b6 inline virtual T & operator []( const size_t i ) Reimplements : datatypes::timeseries::StoragePolicy::operator[] function operator[] \u00b6 inline virtual const T & operator []( const size_t i ) const Reimplements : datatypes::timeseries::StoragePolicy::operator[] function Clone \u00b6 inline virtual StoragePolicy < T > * Clone () const Reimplements : datatypes::timeseries::StoragePolicy::Clone function GetTimeStep \u00b6 inline virtual TimeStep GetTimeStep () const override Reimplements : datatypes::timeseries::StoragePolicy::GetTimeStep function GetStart \u00b6 inline virtual ptime GetStart () const override Reimplements : datatypes::timeseries::StoragePolicy::GetStart function SetTimeStep \u00b6 inline virtual void SetTimeStep ( const TimeStep & tStep ) override Reimplements : datatypes::timeseries::StoragePolicy::SetTimeStep function SetStart \u00b6 inline virtual void SetStart ( const ptime & start ) override Reimplements : datatypes::timeseries::StoragePolicy::SetStart Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::StlVectorStorage"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StlVectorStorage/#datatypestimeseriesstlvectorstorage","text":"More... #include <time_series_strategies.hpp> Inherits from datatypes::timeseries::StoragePolicy< double > , datatypes::timeseries::TimeSeriesInfoProvider","title":"datatypes::timeseries::StlVectorStorage"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StlVectorStorage/#public-functions","text":"Name StlVectorStorage () virtual size_t Size () const virtual size_t GetLength () const void Allocate (size_t length, T value) void AllocateValues (size_t length, const T * values) void AllocateValues (const vector< T > & values) void CopyTo (vector< T > & dest, size_t from =0, size_t to =-1) const virtual T & operator[] (const size_t i) virtual const T & operator[] (const size_t i) const virtual StoragePolicy < T > * Clone () const virtual TimeStep GetTimeStep () const override virtual ptime GetStart () const override virtual void SetTimeStep (const TimeStep & tStep) override virtual void SetStart (const ptime & start) override","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StlVectorStorage/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::StoragePolicy< double > Name virtual ~StoragePolicy () virtual bool ReadOnly () Protected Functions inherited from datatypes::timeseries::StoragePolicy< double > Name StoragePolicy (const StoragePolicy & src) StoragePolicy () Public Functions inherited from datatypes::timeseries::TimeSeriesInfoProvider Name virtual ~TimeSeriesInfoProvider ()","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StlVectorStorage/#detailed-description","text":"template < typename T = double > class datatypes :: timeseries :: StlVectorStorage ;","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StlVectorStorage/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StlVectorStorage/#function-stlvectorstorage","text":"inline StlVectorStorage ()","title":"function StlVectorStorage"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StlVectorStorage/#function-size","text":"inline virtual size_t Size () const Reimplements : datatypes::timeseries::StoragePolicy::Size","title":"function Size"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StlVectorStorage/#function-getlength","text":"inline virtual size_t GetLength () const Reimplements : datatypes::timeseries::TimeSeriesInfoProvider::GetLength","title":"function GetLength"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StlVectorStorage/#function-allocate","text":"inline void Allocate ( size_t length , T value )","title":"function Allocate"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StlVectorStorage/#function-allocatevalues","text":"inline void AllocateValues ( size_t length , const T * values )","title":"function AllocateValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StlVectorStorage/#function-allocatevalues_1","text":"inline void AllocateValues ( const vector < T > & values )","title":"function AllocateValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StlVectorStorage/#function-copyto","text":"inline void CopyTo ( vector < T > & dest , size_t from = 0 , size_t to = -1 ) const","title":"function CopyTo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StlVectorStorage/#function-operator","text":"inline virtual T & operator []( const size_t i ) Reimplements : datatypes::timeseries::StoragePolicy::operator[]","title":"function operator[]"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StlVectorStorage/#function-operator_1","text":"inline virtual const T & operator []( const size_t i ) const Reimplements : datatypes::timeseries::StoragePolicy::operator[]","title":"function operator[]"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StlVectorStorage/#function-clone","text":"inline virtual StoragePolicy < T > * Clone () const Reimplements : datatypes::timeseries::StoragePolicy::Clone","title":"function Clone"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StlVectorStorage/#function-gettimestep","text":"inline virtual TimeStep GetTimeStep () const override Reimplements : datatypes::timeseries::StoragePolicy::GetTimeStep","title":"function GetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StlVectorStorage/#function-getstart","text":"inline virtual ptime GetStart () const override Reimplements : datatypes::timeseries::StoragePolicy::GetStart","title":"function GetStart"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StlVectorStorage/#function-settimestep","text":"inline virtual void SetTimeStep ( const TimeStep & tStep ) override Reimplements : datatypes::timeseries::StoragePolicy::SetTimeStep","title":"function SetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StlVectorStorage/#function-setstart","text":"inline virtual void SetStart ( const ptime & start ) override Reimplements : datatypes::timeseries::StoragePolicy::SetStart Updated on 2022-08-20 at 19:28:22 +1000","title":"function SetStart"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/","text":"datatypes::timeseries::StoragePolicy \u00b6 An interface for classes that can handle the storage of data for time series. More... #include <time_series_strategies.hpp> Inherits from datatypes::timeseries::TimeSeriesInfoProvider Inherited by datatypes::timeseries::MultiFileTsStorage< T > Public Functions \u00b6 Name virtual ~StoragePolicy () virtual void CopyTo (vector< T > & dest, size_t from =0, size_t to =-1) const =0 virtual size_t Size () const =0 virtual void Allocate (size_t length, T value) =0 virtual void AllocateValues (size_t length, const T * values) =0 virtual void AllocateValues (const vector< T > & values) =0 virtual const T & operator[] (const size_t i) const =0 virtual T & operator[] (const size_t i) =0 virtual StoragePolicy * Clone () const =0 virtual void CopyTo ( StoragePolicy < T > & dest) virtual bool ReadOnly () virtual TimeStep GetTimeStep () const =0 virtual ptime GetStart () const =0 virtual void SetTimeStep (const TimeStep & tStep) =0 virtual void SetStart (const ptime & start) =0 Protected Functions \u00b6 Name StoragePolicy (const StoragePolicy & src) StoragePolicy () Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::TimeSeriesInfoProvider Name virtual ~TimeSeriesInfoProvider () virtual size_t GetLength () const =0 Detailed Description \u00b6 template < typename T > class datatypes :: timeseries :: StoragePolicy ; An interface for classes that can handle the storage of data for time series. Template Parameters : T The type of each data item this can handle, e.g. a double, float, or even pointers. The storage of time series data is using a software pattern usually named Strategy, or Policy. The word \"policy\" is more of a legacy (time series storage used to be template-arguments for time series). The purpose is to delegate the details of the data handling (memory, file, and data caching between different types of storages.) out of TTimeSeries objects. Public Functions Documentation \u00b6 function ~StoragePolicy \u00b6 inline virtual ~ StoragePolicy () function CopyTo \u00b6 virtual void CopyTo ( vector < T > & dest , size_t from = 0 , size_t to = -1 ) const = 0 Reimplemented by : datatypes::timeseries::EagerWriter::CopyTo , datatypes::timeseries::MultiFileTsStorage::CopyTo function Size \u00b6 virtual size_t Size () const = 0 Reimplemented by : datatypes::timeseries::EagerWriter::Size , datatypes::timeseries::MultiFileTsStorage::Size , datatypes::timeseries::StlVectorStorage::Size , datatypes::timeseries::SharedVectorStorage::Size , datatypes::timeseries::MemoryCachingStorageWriter::Size function Allocate \u00b6 virtual void Allocate ( size_t length , T value ) = 0 Reimplemented by : datatypes::timeseries::EagerWriter::Allocate , datatypes::timeseries::MultiFileTsStorage::Allocate function AllocateValues \u00b6 virtual void AllocateValues ( size_t length , const T * values ) = 0 Reimplemented by : datatypes::timeseries::EagerWriter::AllocateValues , datatypes::timeseries::MultiFileTsStorage::AllocateValues function AllocateValues \u00b6 virtual void AllocateValues ( const vector < T > & values ) = 0 Reimplemented by : datatypes::timeseries::EagerWriter::AllocateValues , datatypes::timeseries::MultiFileTsStorage::AllocateValues function operator[] \u00b6 virtual const T & operator []( const size_t i ) const = 0 Reimplemented by : datatypes::timeseries::EagerWriter::operator[] , datatypes::timeseries::MultiFileTsStorage::operator[] , datatypes::timeseries::StlVectorStorage::operator[] , datatypes::timeseries::SharedVectorStorage::operator[] , datatypes::timeseries::MemoryCachingStorageWriter::operator[] function operator[] \u00b6 virtual T & operator []( const size_t i ) = 0 Reimplemented by : datatypes::timeseries::EagerWriter::operator[] , datatypes::timeseries::MultiFileTsStorage::operator[] , datatypes::timeseries::StlVectorStorage::operator[] , datatypes::timeseries::SharedVectorStorage::operator[] , datatypes::timeseries::MemoryCachingStorageWriter::operator[] function Clone \u00b6 virtual StoragePolicy * Clone () const = 0 Reimplemented by : datatypes::timeseries::EagerWriter::Clone , datatypes::timeseries::MultiFileTsStorage::Clone , datatypes::timeseries::StlVectorStorage::Clone , datatypes::timeseries::SharedVectorStorage::Clone , datatypes::timeseries::MemoryCachingStorageWriter::Clone function CopyTo \u00b6 inline virtual void CopyTo ( StoragePolicy < T > & dest ) function ReadOnly \u00b6 inline virtual bool ReadOnly () Reimplemented by : datatypes::timeseries::EagerWriter::ReadOnly , datatypes::timeseries::MultiFileTsStorage::ReadOnly function GetTimeStep \u00b6 virtual TimeStep GetTimeStep () const = 0 Reimplements : datatypes::timeseries::TimeSeriesInfoProvider::GetTimeStep Reimplemented by : datatypes::timeseries::EagerWriter::GetTimeStep , datatypes::timeseries::MultiFileTsStorage::GetTimeStep , datatypes::timeseries::StlVectorStorage::GetTimeStep , datatypes::timeseries::SharedVectorStorage::GetTimeStep , datatypes::timeseries::MemoryCachingStorageWriter::GetTimeStep function GetStart \u00b6 virtual ptime GetStart () const = 0 Reimplements : datatypes::timeseries::TimeSeriesInfoProvider::GetStart Reimplemented by : datatypes::timeseries::EagerWriter::GetStart , datatypes::timeseries::MultiFileTsStorage::GetStart , datatypes::timeseries::StlVectorStorage::GetStart , datatypes::timeseries::SharedVectorStorage::GetStart , datatypes::timeseries::MemoryCachingStorageWriter::GetStart function SetTimeStep \u00b6 virtual void SetTimeStep ( const TimeStep & tStep ) = 0 Reimplemented by : datatypes::timeseries::EagerWriter::SetTimeStep , datatypes::timeseries::MultiFileTsStorage::SetTimeStep , datatypes::timeseries::StlVectorStorage::SetTimeStep , datatypes::timeseries::SharedVectorStorage::SetTimeStep , datatypes::timeseries::MemoryCachingStorageWriter::SetTimeStep function SetStart \u00b6 virtual void SetStart ( const ptime & start ) = 0 Reimplemented by : datatypes::timeseries::EagerWriter::SetStart , datatypes::timeseries::MultiFileTsStorage::SetStart , datatypes::timeseries::StlVectorStorage::SetStart , datatypes::timeseries::SharedVectorStorage::SetStart , datatypes::timeseries::MemoryCachingStorageWriter::SetStart Protected Functions Documentation \u00b6 function StoragePolicy \u00b6 inline StoragePolicy ( const StoragePolicy & src ) function StoragePolicy \u00b6 inline StoragePolicy () Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::StoragePolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#datatypestimeseriesstoragepolicy","text":"An interface for classes that can handle the storage of data for time series. More... #include <time_series_strategies.hpp> Inherits from datatypes::timeseries::TimeSeriesInfoProvider Inherited by datatypes::timeseries::MultiFileTsStorage< T >","title":"datatypes::timeseries::StoragePolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#public-functions","text":"Name virtual ~StoragePolicy () virtual void CopyTo (vector< T > & dest, size_t from =0, size_t to =-1) const =0 virtual size_t Size () const =0 virtual void Allocate (size_t length, T value) =0 virtual void AllocateValues (size_t length, const T * values) =0 virtual void AllocateValues (const vector< T > & values) =0 virtual const T & operator[] (const size_t i) const =0 virtual T & operator[] (const size_t i) =0 virtual StoragePolicy * Clone () const =0 virtual void CopyTo ( StoragePolicy < T > & dest) virtual bool ReadOnly () virtual TimeStep GetTimeStep () const =0 virtual ptime GetStart () const =0 virtual void SetTimeStep (const TimeStep & tStep) =0 virtual void SetStart (const ptime & start) =0","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#protected-functions","text":"Name StoragePolicy (const StoragePolicy & src) StoragePolicy ()","title":"Protected Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::TimeSeriesInfoProvider Name virtual ~TimeSeriesInfoProvider () virtual size_t GetLength () const =0","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#detailed-description","text":"template < typename T > class datatypes :: timeseries :: StoragePolicy ; An interface for classes that can handle the storage of data for time series. Template Parameters : T The type of each data item this can handle, e.g. a double, float, or even pointers. The storage of time series data is using a software pattern usually named Strategy, or Policy. The word \"policy\" is more of a legacy (time series storage used to be template-arguments for time series). The purpose is to delegate the details of the data handling (memory, file, and data caching between different types of storages.) out of TTimeSeries objects.","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#function-storagepolicy","text":"inline virtual ~ StoragePolicy ()","title":"function ~StoragePolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#function-copyto","text":"virtual void CopyTo ( vector < T > & dest , size_t from = 0 , size_t to = -1 ) const = 0 Reimplemented by : datatypes::timeseries::EagerWriter::CopyTo , datatypes::timeseries::MultiFileTsStorage::CopyTo","title":"function CopyTo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#function-size","text":"virtual size_t Size () const = 0 Reimplemented by : datatypes::timeseries::EagerWriter::Size , datatypes::timeseries::MultiFileTsStorage::Size , datatypes::timeseries::StlVectorStorage::Size , datatypes::timeseries::SharedVectorStorage::Size , datatypes::timeseries::MemoryCachingStorageWriter::Size","title":"function Size"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#function-allocate","text":"virtual void Allocate ( size_t length , T value ) = 0 Reimplemented by : datatypes::timeseries::EagerWriter::Allocate , datatypes::timeseries::MultiFileTsStorage::Allocate","title":"function Allocate"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#function-allocatevalues","text":"virtual void AllocateValues ( size_t length , const T * values ) = 0 Reimplemented by : datatypes::timeseries::EagerWriter::AllocateValues , datatypes::timeseries::MultiFileTsStorage::AllocateValues","title":"function AllocateValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#function-allocatevalues_1","text":"virtual void AllocateValues ( const vector < T > & values ) = 0 Reimplemented by : datatypes::timeseries::EagerWriter::AllocateValues , datatypes::timeseries::MultiFileTsStorage::AllocateValues","title":"function AllocateValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#function-operator","text":"virtual const T & operator []( const size_t i ) const = 0 Reimplemented by : datatypes::timeseries::EagerWriter::operator[] , datatypes::timeseries::MultiFileTsStorage::operator[] , datatypes::timeseries::StlVectorStorage::operator[] , datatypes::timeseries::SharedVectorStorage::operator[] , datatypes::timeseries::MemoryCachingStorageWriter::operator[]","title":"function operator[]"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#function-operator_1","text":"virtual T & operator []( const size_t i ) = 0 Reimplemented by : datatypes::timeseries::EagerWriter::operator[] , datatypes::timeseries::MultiFileTsStorage::operator[] , datatypes::timeseries::StlVectorStorage::operator[] , datatypes::timeseries::SharedVectorStorage::operator[] , datatypes::timeseries::MemoryCachingStorageWriter::operator[]","title":"function operator[]"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#function-clone","text":"virtual StoragePolicy * Clone () const = 0 Reimplemented by : datatypes::timeseries::EagerWriter::Clone , datatypes::timeseries::MultiFileTsStorage::Clone , datatypes::timeseries::StlVectorStorage::Clone , datatypes::timeseries::SharedVectorStorage::Clone , datatypes::timeseries::MemoryCachingStorageWriter::Clone","title":"function Clone"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#function-copyto_1","text":"inline virtual void CopyTo ( StoragePolicy < T > & dest )","title":"function CopyTo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#function-readonly","text":"inline virtual bool ReadOnly () Reimplemented by : datatypes::timeseries::EagerWriter::ReadOnly , datatypes::timeseries::MultiFileTsStorage::ReadOnly","title":"function ReadOnly"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#function-gettimestep","text":"virtual TimeStep GetTimeStep () const = 0 Reimplements : datatypes::timeseries::TimeSeriesInfoProvider::GetTimeStep Reimplemented by : datatypes::timeseries::EagerWriter::GetTimeStep , datatypes::timeseries::MultiFileTsStorage::GetTimeStep , datatypes::timeseries::StlVectorStorage::GetTimeStep , datatypes::timeseries::SharedVectorStorage::GetTimeStep , datatypes::timeseries::MemoryCachingStorageWriter::GetTimeStep","title":"function GetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#function-getstart","text":"virtual ptime GetStart () const = 0 Reimplements : datatypes::timeseries::TimeSeriesInfoProvider::GetStart Reimplemented by : datatypes::timeseries::EagerWriter::GetStart , datatypes::timeseries::MultiFileTsStorage::GetStart , datatypes::timeseries::StlVectorStorage::GetStart , datatypes::timeseries::SharedVectorStorage::GetStart , datatypes::timeseries::MemoryCachingStorageWriter::GetStart","title":"function GetStart"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#function-settimestep","text":"virtual void SetTimeStep ( const TimeStep & tStep ) = 0 Reimplemented by : datatypes::timeseries::EagerWriter::SetTimeStep , datatypes::timeseries::MultiFileTsStorage::SetTimeStep , datatypes::timeseries::StlVectorStorage::SetTimeStep , datatypes::timeseries::SharedVectorStorage::SetTimeStep , datatypes::timeseries::MemoryCachingStorageWriter::SetTimeStep","title":"function SetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#function-setstart","text":"virtual void SetStart ( const ptime & start ) = 0 Reimplemented by : datatypes::timeseries::EagerWriter::SetStart , datatypes::timeseries::MultiFileTsStorage::SetStart , datatypes::timeseries::StlVectorStorage::SetStart , datatypes::timeseries::SharedVectorStorage::SetStart , datatypes::timeseries::MemoryCachingStorageWriter::SetStart","title":"function SetStart"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#function-storagepolicy_1","text":"inline StoragePolicy ( const StoragePolicy & src )","title":"function StoragePolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1StoragePolicy/#function-storagepolicy_2","text":"inline StoragePolicy () Updated on 2022-08-20 at 19:28:22 +1000","title":"function StoragePolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SwiftNetcdfStoreFactory/","text":"datatypes::timeseries::SwiftNetcdfStoreFactory \u00b6 #include <time_series_io.hpp> Inherits from datatypes::timeseries::TimeSeriesStoreFactory Public Functions \u00b6 Name SwiftNetcdfStoreFactory (const string & path, DataGeometryProvider * dgp) ~SwiftNetcdfStoreFactory () virtual TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore (const string & dataId) virtual bool CanCreateTimeSeriesEnsembleTimeSeriesStore (const string & dataId) Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::TimeSeriesStoreFactory Name virtual ~TimeSeriesStoreFactory () Protected Functions inherited from datatypes::timeseries::TimeSeriesStoreFactory Name TimeSeriesStoreFactory () Public Functions Documentation \u00b6 function SwiftNetcdfStoreFactory \u00b6 SwiftNetcdfStoreFactory ( const string & path , DataGeometryProvider * dgp ) function ~SwiftNetcdfStoreFactory \u00b6 ~ SwiftNetcdfStoreFactory () function CreateTimeSeriesEnsembleTimeSeriesStore \u00b6 virtual TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ) Reimplements : datatypes::timeseries::TimeSeriesStoreFactory::CreateTimeSeriesEnsembleTimeSeriesStore function CanCreateTimeSeriesEnsembleTimeSeriesStore \u00b6 virtual bool CanCreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ) Reimplements : datatypes::timeseries::TimeSeriesStoreFactory::CanCreateTimeSeriesEnsembleTimeSeriesStore Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::SwiftNetcdfStoreFactory"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SwiftNetcdfStoreFactory/#datatypestimeseriesswiftnetcdfstorefactory","text":"#include <time_series_io.hpp> Inherits from datatypes::timeseries::TimeSeriesStoreFactory","title":"datatypes::timeseries::SwiftNetcdfStoreFactory"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SwiftNetcdfStoreFactory/#public-functions","text":"Name SwiftNetcdfStoreFactory (const string & path, DataGeometryProvider * dgp) ~SwiftNetcdfStoreFactory () virtual TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore (const string & dataId) virtual bool CanCreateTimeSeriesEnsembleTimeSeriesStore (const string & dataId)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SwiftNetcdfStoreFactory/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::TimeSeriesStoreFactory Name virtual ~TimeSeriesStoreFactory () Protected Functions inherited from datatypes::timeseries::TimeSeriesStoreFactory Name TimeSeriesStoreFactory ()","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SwiftNetcdfStoreFactory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SwiftNetcdfStoreFactory/#function-swiftnetcdfstorefactory","text":"SwiftNetcdfStoreFactory ( const string & path , DataGeometryProvider * dgp )","title":"function SwiftNetcdfStoreFactory"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SwiftNetcdfStoreFactory/#function-swiftnetcdfstorefactory_1","text":"~ SwiftNetcdfStoreFactory ()","title":"function ~SwiftNetcdfStoreFactory"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SwiftNetcdfStoreFactory/#function-createtimeseriesensembletimeseriesstore","text":"virtual TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ) Reimplements : datatypes::timeseries::TimeSeriesStoreFactory::CreateTimeSeriesEnsembleTimeSeriesStore","title":"function CreateTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1SwiftNetcdfStoreFactory/#function-cancreatetimeseriesensembletimeseriesstore","text":"virtual bool CanCreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ) Reimplements : datatypes::timeseries::TimeSeriesStoreFactory::CanCreateTimeSeriesEnsembleTimeSeriesStore Updated on 2022-08-20 at 19:28:22 +1000","title":"function CanCreateTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/","text":"datatypes::timeseries::TTimeSeries \u00b6 A template for univariate, single realisasion time series. More... #include <time_series.hpp> Public Types \u00b6 Name using T ElementType The type of each element in this time series. Public Functions \u00b6 Name bool IsMissingValue (const T & value) const T GetMissingValue () const TTimeSeries ( StoragePolicy < T > * storage =nullptr, MissingValuePolicy < T > * mvp =nullptr) TTimeSeries (T default_value, size_t length, const ptime & startDate, const TimeStep & timeStep = TimeStep::GetHourly (), StoragePolicy < T > * storage =nullptr, MissingValuePolicy < T > * mvp =nullptr) TTimeSeries (size_t length, const ptime & startDate, const TimeStep & timeStep = TimeStep::GetHourly (), StoragePolicy < T > * storage =nullptr, MissingValuePolicy < T > * mvp =nullptr) TTimeSeries (const vector< T > & values, const ptime & startDate, const TimeStep & timeStep = TimeStep::GetHourly (), StoragePolicy < T > * storage =nullptr, MissingValuePolicy < T > * mvp =nullptr) TTimeSeries (const T * values, size_t length, const ptime & startDate, const TimeStep & timeStep = TimeStep::GetHourly (), StoragePolicy < T > * storage =nullptr, MissingValuePolicy < T > * mvp =nullptr) TTimeSeries (std::function< T(size_t)> & valueGen, size_t length, const ptime & startDate, const TimeStep & timeStep = TimeStep::GetHourly (), StoragePolicy < T > * storage =nullptr, MissingValuePolicy < T > * mvp =nullptr) TTimeSeries (const TTimeSeries < T > & src) TTimeSeries (const TTimeSeries < T > & src, StoragePolicy < T > * storage) TTimeSeries (const TTimeSeries < T > * src) TTimeSeries ( TTimeSeries < T > && src) Constructor using the move semantics. TTimeSeries < T > & operator= ( TTimeSeries < T > && src) TTimeSeries < T > & operator= (const TTimeSeries < T > & src) virtual ~TTimeSeries () T GetValueNoConst (const size_t & index) const T & GetValueConst (const size_t & index) const T GetValue (const size_t & index) const T & GetValue (const size_t & index) const T GetValueNoConst (const ptime & instant) T GetValue (const ptime & instant) const T & GetValue (const ptime & instant) const T GetLastValue () void CopyTo (T * dest, size_t from =0, size_t to =-1) const void CopyWithMissingValueTo (T * dest, const T & missingValueValue, size_t from =0, size_t to =-1) const void CopyValues (const TTimeSeries < T > & src) void CopyTo (vector< T > & dest, size_t from =0, size_t to =-1) const T * GetValues (size_t from =0, size_t to =std::numeric_limits< size_t >::max()) const vector< T > GetValuesVector (size_t from =0, size_t to =std::numeric_limits< size_t >::max()) const TTimeSeries < T > Subset (size_t from =0, size_t to =std::numeric_limits< size_t >::max()) const void SetValue (size_t index, T value) void SetValue (const ptime & instant, T value) void Reset (size_t length, const ptime & startDate, const TimeStep & timeStep) void Reset (size_t length, const ptime & startDate, const T * values =nullptr) void Reset (size_t length, const ptime & startDate, T value) void Reset (const vector< T > & values, const ptime & startDate) void Reset (const vector< T > & values, const ptime & startDate, const TimeStep & timeStep) size_t GetLength () const ptime GetStartDate () const ptime GetEndDate () const TimeStep GetTimeStep () const void SetTimeStep (const TimeStep & timeStep) void SetStartDate (const ptime & start) ptime TimeForIndex (size_t timeIndex) const vector< ptime > TimeIndices () const size_t IndexForTime (const ptime & instant) const size_t UpperIndexForTime (const ptime & instant) const size_t LowerIndexForTime (const ptime & instant) const string GetSummary () const T & operator[] (const ptime & instant) T & operator[] (const size_t i) const T & operator[] (const ptime & instant) const const T & operator[] (const size_t i) const TTimeSeries < T > operator+ (const TTimeSeries < T > & rhs) const TTimeSeries < T > operator+ (T value) const template <typename M > TTimeSeries < T > operator* (M multiplicator) const int NumInstances () Protected Functions \u00b6 Name T GetNACode () const Public Attributes \u00b6 Name string Tag Detailed Description \u00b6 template < typename T = double > class datatypes :: timeseries :: TTimeSeries ; A template for univariate, single realisasion time series. Template Parameters : T Element type, typically double or float, but possibly a more complicated type such as another TTimeSeries . Public Types Documentation \u00b6 using ElementType \u00b6 using datatypes :: timeseries :: TTimeSeries < T >:: ElementType = T ; The type of each element in this time series. Public Functions Documentation \u00b6 function IsMissingValue \u00b6 inline bool IsMissingValue ( const T & value ) const function GetMissingValue \u00b6 inline T GetMissingValue () const function TTimeSeries \u00b6 inline TTimeSeries ( StoragePolicy < T > * storage = nullptr , MissingValuePolicy < T > * mvp = nullptr ) function TTimeSeries \u00b6 inline TTimeSeries ( T default_value , size_t length , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly (), StoragePolicy < T > * storage = nullptr , MissingValuePolicy < T > * mvp = nullptr ) function TTimeSeries \u00b6 inline TTimeSeries ( size_t length , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly (), StoragePolicy < T > * storage = nullptr , MissingValuePolicy < T > * mvp = nullptr ) function TTimeSeries \u00b6 inline TTimeSeries ( const vector < T > & values , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly (), StoragePolicy < T > * storage = nullptr , MissingValuePolicy < T > * mvp = nullptr ) function TTimeSeries \u00b6 inline TTimeSeries ( const T * values , size_t length , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly (), StoragePolicy < T > * storage = nullptr , MissingValuePolicy < T > * mvp = nullptr ) function TTimeSeries \u00b6 inline TTimeSeries ( std :: function < T ( size_t ) > & valueGen , size_t length , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly (), StoragePolicy < T > * storage = nullptr , MissingValuePolicy < T > * mvp = nullptr ) function TTimeSeries \u00b6 inline TTimeSeries ( const TTimeSeries < T > & src ) function TTimeSeries \u00b6 inline TTimeSeries ( const TTimeSeries < T > & src , StoragePolicy < T > * storage ) function TTimeSeries \u00b6 inline TTimeSeries ( const TTimeSeries < T > * src ) function TTimeSeries \u00b6 inline TTimeSeries ( TTimeSeries < T > && src ) Constructor using the move semantics. Parameters : src time series from which to move data. Remark : C++ for the Impatient Appendix A. A Painless Introduction to Rvalue References (C++11) See also http://stackoverflow.com/a/3109981/2752565 for information on move semantic function operator= \u00b6 inline TTimeSeries < T > & operator = ( TTimeSeries < T > && src ) function operator= \u00b6 inline TTimeSeries < T > & operator = ( const TTimeSeries < T > & src ) function ~TTimeSeries \u00b6 inline virtual ~ TTimeSeries () function GetValueNoConst \u00b6 inline T GetValueNoConst ( const size_t & index ) function GetValueConst \u00b6 inline const T & GetValueConst ( const size_t & index ) const function GetValue \u00b6 inline T GetValue ( const size_t & index ) function GetValue \u00b6 inline const T & GetValue ( const size_t & index ) const function GetValueNoConst \u00b6 inline T GetValueNoConst ( const ptime & instant ) function GetValue \u00b6 inline T GetValue ( const ptime & instant ) function GetValue \u00b6 inline const T & GetValue ( const ptime & instant ) const function GetLastValue \u00b6 inline T GetLastValue () function CopyTo \u00b6 inline void CopyTo ( T * dest , size_t from = 0 , size_t to = -1 ) const function CopyWithMissingValueTo \u00b6 inline void CopyWithMissingValueTo ( T * dest , const T & missingValueValue , size_t from = 0 , size_t to = -1 ) const function CopyValues \u00b6 inline void CopyValues ( const TTimeSeries < T > & src ) function CopyTo \u00b6 inline void CopyTo ( vector < T > & dest , size_t from = 0 , size_t to = -1 ) const function GetValues \u00b6 inline T * GetValues ( size_t from = 0 , size_t to = std :: numeric_limits < size_t >:: max () ) const function GetValuesVector \u00b6 inline vector < T > GetValuesVector ( size_t from = 0 , size_t to = std :: numeric_limits < size_t >:: max () ) const function Subset \u00b6 inline TTimeSeries < T > Subset ( size_t from = 0 , size_t to = std :: numeric_limits < size_t >:: max () ) const function SetValue \u00b6 inline void SetValue ( size_t index , T value ) function SetValue \u00b6 inline void SetValue ( const ptime & instant , T value ) function Reset \u00b6 inline void Reset ( size_t length , const ptime & startDate , const TimeStep & timeStep ) function Reset \u00b6 inline void Reset ( size_t length , const ptime & startDate , const T * values = nullptr ) function Reset \u00b6 inline void Reset ( size_t length , const ptime & startDate , T value ) function Reset \u00b6 inline void Reset ( const vector < T > & values , const ptime & startDate ) function Reset \u00b6 inline void Reset ( const vector < T > & values , const ptime & startDate , const TimeStep & timeStep ) function GetLength \u00b6 inline size_t GetLength () const function GetStartDate \u00b6 inline ptime GetStartDate () const function GetEndDate \u00b6 inline ptime GetEndDate () const function GetTimeStep \u00b6 inline TimeStep GetTimeStep () const function SetTimeStep \u00b6 inline void SetTimeStep ( const TimeStep & timeStep ) function SetStartDate \u00b6 inline void SetStartDate ( const ptime & start ) function TimeForIndex \u00b6 inline ptime TimeForIndex ( size_t timeIndex ) const function TimeIndices \u00b6 inline vector < ptime > TimeIndices () const function IndexForTime \u00b6 inline size_t IndexForTime ( const ptime & instant ) const function UpperIndexForTime \u00b6 inline size_t UpperIndexForTime ( const ptime & instant ) const function LowerIndexForTime \u00b6 inline size_t LowerIndexForTime ( const ptime & instant ) const function GetSummary \u00b6 inline string GetSummary () const function operator[] \u00b6 inline T & operator []( const ptime & instant ) function operator[] \u00b6 inline T & operator []( const size_t i ) function operator[] \u00b6 inline const T & operator []( const ptime & instant ) const function operator[] \u00b6 inline const T & operator []( const size_t i ) const function operator+ \u00b6 inline TTimeSeries < T > operator + ( const TTimeSeries < T > & rhs ) const function operator+ \u00b6 inline TTimeSeries < T > operator + ( T value ) const function operator* \u00b6 template < typename M > inline TTimeSeries < T > operator * ( M multiplicator ) const function NumInstances \u00b6 static inline int NumInstances () Protected Functions Documentation \u00b6 function GetNACode \u00b6 inline T GetNACode () const Public Attributes Documentation \u00b6 variable Tag \u00b6 string Tag ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::TTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#datatypestimeseriesttimeseries","text":"A template for univariate, single realisasion time series. More... #include <time_series.hpp>","title":"datatypes::timeseries::TTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#public-types","text":"Name using T ElementType The type of each element in this time series.","title":"Public Types"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#public-functions","text":"Name bool IsMissingValue (const T & value) const T GetMissingValue () const TTimeSeries ( StoragePolicy < T > * storage =nullptr, MissingValuePolicy < T > * mvp =nullptr) TTimeSeries (T default_value, size_t length, const ptime & startDate, const TimeStep & timeStep = TimeStep::GetHourly (), StoragePolicy < T > * storage =nullptr, MissingValuePolicy < T > * mvp =nullptr) TTimeSeries (size_t length, const ptime & startDate, const TimeStep & timeStep = TimeStep::GetHourly (), StoragePolicy < T > * storage =nullptr, MissingValuePolicy < T > * mvp =nullptr) TTimeSeries (const vector< T > & values, const ptime & startDate, const TimeStep & timeStep = TimeStep::GetHourly (), StoragePolicy < T > * storage =nullptr, MissingValuePolicy < T > * mvp =nullptr) TTimeSeries (const T * values, size_t length, const ptime & startDate, const TimeStep & timeStep = TimeStep::GetHourly (), StoragePolicy < T > * storage =nullptr, MissingValuePolicy < T > * mvp =nullptr) TTimeSeries (std::function< T(size_t)> & valueGen, size_t length, const ptime & startDate, const TimeStep & timeStep = TimeStep::GetHourly (), StoragePolicy < T > * storage =nullptr, MissingValuePolicy < T > * mvp =nullptr) TTimeSeries (const TTimeSeries < T > & src) TTimeSeries (const TTimeSeries < T > & src, StoragePolicy < T > * storage) TTimeSeries (const TTimeSeries < T > * src) TTimeSeries ( TTimeSeries < T > && src) Constructor using the move semantics. TTimeSeries < T > & operator= ( TTimeSeries < T > && src) TTimeSeries < T > & operator= (const TTimeSeries < T > & src) virtual ~TTimeSeries () T GetValueNoConst (const size_t & index) const T & GetValueConst (const size_t & index) const T GetValue (const size_t & index) const T & GetValue (const size_t & index) const T GetValueNoConst (const ptime & instant) T GetValue (const ptime & instant) const T & GetValue (const ptime & instant) const T GetLastValue () void CopyTo (T * dest, size_t from =0, size_t to =-1) const void CopyWithMissingValueTo (T * dest, const T & missingValueValue, size_t from =0, size_t to =-1) const void CopyValues (const TTimeSeries < T > & src) void CopyTo (vector< T > & dest, size_t from =0, size_t to =-1) const T * GetValues (size_t from =0, size_t to =std::numeric_limits< size_t >::max()) const vector< T > GetValuesVector (size_t from =0, size_t to =std::numeric_limits< size_t >::max()) const TTimeSeries < T > Subset (size_t from =0, size_t to =std::numeric_limits< size_t >::max()) const void SetValue (size_t index, T value) void SetValue (const ptime & instant, T value) void Reset (size_t length, const ptime & startDate, const TimeStep & timeStep) void Reset (size_t length, const ptime & startDate, const T * values =nullptr) void Reset (size_t length, const ptime & startDate, T value) void Reset (const vector< T > & values, const ptime & startDate) void Reset (const vector< T > & values, const ptime & startDate, const TimeStep & timeStep) size_t GetLength () const ptime GetStartDate () const ptime GetEndDate () const TimeStep GetTimeStep () const void SetTimeStep (const TimeStep & timeStep) void SetStartDate (const ptime & start) ptime TimeForIndex (size_t timeIndex) const vector< ptime > TimeIndices () const size_t IndexForTime (const ptime & instant) const size_t UpperIndexForTime (const ptime & instant) const size_t LowerIndexForTime (const ptime & instant) const string GetSummary () const T & operator[] (const ptime & instant) T & operator[] (const size_t i) const T & operator[] (const ptime & instant) const const T & operator[] (const size_t i) const TTimeSeries < T > operator+ (const TTimeSeries < T > & rhs) const TTimeSeries < T > operator+ (T value) const template <typename M > TTimeSeries < T > operator* (M multiplicator) const int NumInstances ()","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#protected-functions","text":"Name T GetNACode () const","title":"Protected Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#public-attributes","text":"Name string Tag","title":"Public Attributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#detailed-description","text":"template < typename T = double > class datatypes :: timeseries :: TTimeSeries ; A template for univariate, single realisasion time series. Template Parameters : T Element type, typically double or float, but possibly a more complicated type such as another TTimeSeries .","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#using-elementtype","text":"using datatypes :: timeseries :: TTimeSeries < T >:: ElementType = T ; The type of each element in this time series.","title":"using ElementType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-ismissingvalue","text":"inline bool IsMissingValue ( const T & value ) const","title":"function IsMissingValue"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-getmissingvalue","text":"inline T GetMissingValue () const","title":"function GetMissingValue"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-ttimeseries","text":"inline TTimeSeries ( StoragePolicy < T > * storage = nullptr , MissingValuePolicy < T > * mvp = nullptr )","title":"function TTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-ttimeseries_1","text":"inline TTimeSeries ( T default_value , size_t length , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly (), StoragePolicy < T > * storage = nullptr , MissingValuePolicy < T > * mvp = nullptr )","title":"function TTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-ttimeseries_2","text":"inline TTimeSeries ( size_t length , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly (), StoragePolicy < T > * storage = nullptr , MissingValuePolicy < T > * mvp = nullptr )","title":"function TTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-ttimeseries_3","text":"inline TTimeSeries ( const vector < T > & values , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly (), StoragePolicy < T > * storage = nullptr , MissingValuePolicy < T > * mvp = nullptr )","title":"function TTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-ttimeseries_4","text":"inline TTimeSeries ( const T * values , size_t length , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly (), StoragePolicy < T > * storage = nullptr , MissingValuePolicy < T > * mvp = nullptr )","title":"function TTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-ttimeseries_5","text":"inline TTimeSeries ( std :: function < T ( size_t ) > & valueGen , size_t length , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly (), StoragePolicy < T > * storage = nullptr , MissingValuePolicy < T > * mvp = nullptr )","title":"function TTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-ttimeseries_6","text":"inline TTimeSeries ( const TTimeSeries < T > & src )","title":"function TTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-ttimeseries_7","text":"inline TTimeSeries ( const TTimeSeries < T > & src , StoragePolicy < T > * storage )","title":"function TTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-ttimeseries_8","text":"inline TTimeSeries ( const TTimeSeries < T > * src )","title":"function TTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-ttimeseries_9","text":"inline TTimeSeries ( TTimeSeries < T > && src ) Constructor using the move semantics. Parameters : src time series from which to move data. Remark : C++ for the Impatient Appendix A. A Painless Introduction to Rvalue References (C++11) See also http://stackoverflow.com/a/3109981/2752565 for information on move semantic","title":"function TTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-operator","text":"inline TTimeSeries < T > & operator = ( TTimeSeries < T > && src )","title":"function operator="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-operator_1","text":"inline TTimeSeries < T > & operator = ( const TTimeSeries < T > & src )","title":"function operator="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-ttimeseries_10","text":"inline virtual ~ TTimeSeries ()","title":"function ~TTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-getvaluenoconst","text":"inline T GetValueNoConst ( const size_t & index )","title":"function GetValueNoConst"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-getvalueconst","text":"inline const T & GetValueConst ( const size_t & index ) const","title":"function GetValueConst"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-getvalue","text":"inline T GetValue ( const size_t & index )","title":"function GetValue"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-getvalue_1","text":"inline const T & GetValue ( const size_t & index ) const","title":"function GetValue"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-getvaluenoconst_1","text":"inline T GetValueNoConst ( const ptime & instant )","title":"function GetValueNoConst"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-getvalue_2","text":"inline T GetValue ( const ptime & instant )","title":"function GetValue"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-getvalue_3","text":"inline const T & GetValue ( const ptime & instant ) const","title":"function GetValue"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-getlastvalue","text":"inline T GetLastValue ()","title":"function GetLastValue"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-copyto","text":"inline void CopyTo ( T * dest , size_t from = 0 , size_t to = -1 ) const","title":"function CopyTo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-copywithmissingvalueto","text":"inline void CopyWithMissingValueTo ( T * dest , const T & missingValueValue , size_t from = 0 , size_t to = -1 ) const","title":"function CopyWithMissingValueTo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-copyvalues","text":"inline void CopyValues ( const TTimeSeries < T > & src )","title":"function CopyValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-copyto_1","text":"inline void CopyTo ( vector < T > & dest , size_t from = 0 , size_t to = -1 ) const","title":"function CopyTo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-getvalues","text":"inline T * GetValues ( size_t from = 0 , size_t to = std :: numeric_limits < size_t >:: max () ) const","title":"function GetValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-getvaluesvector","text":"inline vector < T > GetValuesVector ( size_t from = 0 , size_t to = std :: numeric_limits < size_t >:: max () ) const","title":"function GetValuesVector"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-subset","text":"inline TTimeSeries < T > Subset ( size_t from = 0 , size_t to = std :: numeric_limits < size_t >:: max () ) const","title":"function Subset"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-setvalue","text":"inline void SetValue ( size_t index , T value )","title":"function SetValue"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-setvalue_1","text":"inline void SetValue ( const ptime & instant , T value )","title":"function SetValue"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-reset","text":"inline void Reset ( size_t length , const ptime & startDate , const TimeStep & timeStep )","title":"function Reset"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-reset_1","text":"inline void Reset ( size_t length , const ptime & startDate , const T * values = nullptr )","title":"function Reset"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-reset_2","text":"inline void Reset ( size_t length , const ptime & startDate , T value )","title":"function Reset"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-reset_3","text":"inline void Reset ( const vector < T > & values , const ptime & startDate )","title":"function Reset"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-reset_4","text":"inline void Reset ( const vector < T > & values , const ptime & startDate , const TimeStep & timeStep )","title":"function Reset"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-getlength","text":"inline size_t GetLength () const","title":"function GetLength"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-getstartdate","text":"inline ptime GetStartDate () const","title":"function GetStartDate"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-getenddate","text":"inline ptime GetEndDate () const","title":"function GetEndDate"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-gettimestep","text":"inline TimeStep GetTimeStep () const","title":"function GetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-settimestep","text":"inline void SetTimeStep ( const TimeStep & timeStep )","title":"function SetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-setstartdate","text":"inline void SetStartDate ( const ptime & start )","title":"function SetStartDate"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-timeforindex","text":"inline ptime TimeForIndex ( size_t timeIndex ) const","title":"function TimeForIndex"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-timeindices","text":"inline vector < ptime > TimeIndices () const","title":"function TimeIndices"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-indexfortime","text":"inline size_t IndexForTime ( const ptime & instant ) const","title":"function IndexForTime"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-upperindexfortime","text":"inline size_t UpperIndexForTime ( const ptime & instant ) const","title":"function UpperIndexForTime"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-lowerindexfortime","text":"inline size_t LowerIndexForTime ( const ptime & instant ) const","title":"function LowerIndexForTime"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-getsummary","text":"inline string GetSummary () const","title":"function GetSummary"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-operator_2","text":"inline T & operator []( const ptime & instant )","title":"function operator[]"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-operator_3","text":"inline T & operator []( const size_t i )","title":"function operator[]"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-operator_4","text":"inline const T & operator []( const ptime & instant ) const","title":"function operator[]"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-operator_5","text":"inline const T & operator []( const size_t i ) const","title":"function operator[]"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-operator_6","text":"inline TTimeSeries < T > operator + ( const TTimeSeries < T > & rhs ) const","title":"function operator+"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-operator_7","text":"inline TTimeSeries < T > operator + ( T value ) const","title":"function operator+"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-operator_8","text":"template < typename M > inline TTimeSeries < T > operator * ( M multiplicator ) const","title":"function operator*"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-numinstances","text":"static inline int NumInstances ()","title":"function NumInstances"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#function-getnacode","text":"inline T GetNACode () const","title":"function GetNACode"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeries/#variable-tag","text":"string Tag ; Updated on 2022-08-20 at 19:28:22 +1000","title":"variable Tag"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeriesLibrary/","text":"datatypes::timeseries::TTimeSeriesLibrary \u00b6 More... #include <time_series_store.hpp> Public Types \u00b6 Name typedef TTimeSeries < T > TS typedef MultiTimeSeries < TS * > MTS Public Functions \u00b6 Name virtual ~TTimeSeriesLibrary () virtual TS * GetSingle (const string & dataId) virtual TS * GetSingle (const string & dataId, const string & collectionIdentifier) virtual MTS * GetCollection (const string & dataId) virtual TimeSeriesProvider < T > * GetProvider (const string & dataId) virtual MultiTimeSeries < TS * > * GetEnsembleTimeSeries (const string & dataId) virtual MultiTimeSeries < TS * > * GetAllTimeSeries (const string & dataId) virtual EnsembleForecastTimeSeries < TS > * GetTimeSeriesEnsembleTimeSeries (const string & dataId) virtual vector< string > GetIdentifiers () const Detailed Description \u00b6 template < typename T > class datatypes :: timeseries :: TTimeSeriesLibrary ; Public Types Documentation \u00b6 typedef TS \u00b6 typedef TTimeSeries < T > datatypes :: timeseries :: TTimeSeriesLibrary < T >:: TS ; typedef MTS \u00b6 typedef MultiTimeSeries < TS *> datatypes :: timeseries :: TTimeSeriesLibrary < T >:: MTS ; Public Functions Documentation \u00b6 function ~TTimeSeriesLibrary \u00b6 inline virtual ~ TTimeSeriesLibrary () function GetSingle \u00b6 inline virtual TS * GetSingle ( const string & dataId ) Reimplemented by : datatypes::timeseries::TimeSeriesLibrary::GetSingle function GetSingle \u00b6 inline virtual TS * GetSingle ( const string & dataId , const string & collectionIdentifier ) Reimplemented by : datatypes::timeseries::TimeSeriesLibrary::GetSingle function GetCollection \u00b6 inline virtual MTS * GetCollection ( const string & dataId ) Reimplemented by : datatypes::timeseries::TimeSeriesLibrary::GetCollection function GetProvider \u00b6 inline virtual TimeSeriesProvider < T > * GetProvider ( const string & dataId ) function GetEnsembleTimeSeries \u00b6 inline virtual MultiTimeSeries < TS * > * GetEnsembleTimeSeries ( const string & dataId ) Reimplemented by : datatypes::timeseries::TimeSeriesLibrary::GetEnsembleTimeSeries function GetAllTimeSeries \u00b6 inline virtual MultiTimeSeries < TS * > * GetAllTimeSeries ( const string & dataId ) Reimplemented by : datatypes::timeseries::TimeSeriesLibrary::GetAllTimeSeries function GetTimeSeriesEnsembleTimeSeries \u00b6 inline virtual EnsembleForecastTimeSeries < TS > * GetTimeSeriesEnsembleTimeSeries ( const string & dataId ) Reimplemented by : datatypes::timeseries::TimeSeriesLibrary::GetTimeSeriesEnsembleTimeSeries function GetIdentifiers \u00b6 inline virtual vector < string > GetIdentifiers () const Reimplemented by : datatypes::timeseries::TimeSeriesLibrary::GetIdentifiers Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::TTimeSeriesLibrary"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeriesLibrary/#datatypestimeseriesttimeserieslibrary","text":"More... #include <time_series_store.hpp>","title":"datatypes::timeseries::TTimeSeriesLibrary"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeriesLibrary/#public-types","text":"Name typedef TTimeSeries < T > TS typedef MultiTimeSeries < TS * > MTS","title":"Public Types"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeriesLibrary/#public-functions","text":"Name virtual ~TTimeSeriesLibrary () virtual TS * GetSingle (const string & dataId) virtual TS * GetSingle (const string & dataId, const string & collectionIdentifier) virtual MTS * GetCollection (const string & dataId) virtual TimeSeriesProvider < T > * GetProvider (const string & dataId) virtual MultiTimeSeries < TS * > * GetEnsembleTimeSeries (const string & dataId) virtual MultiTimeSeries < TS * > * GetAllTimeSeries (const string & dataId) virtual EnsembleForecastTimeSeries < TS > * GetTimeSeriesEnsembleTimeSeries (const string & dataId) virtual vector< string > GetIdentifiers () const","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeriesLibrary/#detailed-description","text":"template < typename T > class datatypes :: timeseries :: TTimeSeriesLibrary ;","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeriesLibrary/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeriesLibrary/#typedef-ts","text":"typedef TTimeSeries < T > datatypes :: timeseries :: TTimeSeriesLibrary < T >:: TS ;","title":"typedef TS"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeriesLibrary/#typedef-mts","text":"typedef MultiTimeSeries < TS *> datatypes :: timeseries :: TTimeSeriesLibrary < T >:: MTS ;","title":"typedef MTS"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeriesLibrary/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeriesLibrary/#function-ttimeserieslibrary","text":"inline virtual ~ TTimeSeriesLibrary ()","title":"function ~TTimeSeriesLibrary"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeriesLibrary/#function-getsingle","text":"inline virtual TS * GetSingle ( const string & dataId ) Reimplemented by : datatypes::timeseries::TimeSeriesLibrary::GetSingle","title":"function GetSingle"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeriesLibrary/#function-getsingle_1","text":"inline virtual TS * GetSingle ( const string & dataId , const string & collectionIdentifier ) Reimplemented by : datatypes::timeseries::TimeSeriesLibrary::GetSingle","title":"function GetSingle"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeriesLibrary/#function-getcollection","text":"inline virtual MTS * GetCollection ( const string & dataId ) Reimplemented by : datatypes::timeseries::TimeSeriesLibrary::GetCollection","title":"function GetCollection"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeriesLibrary/#function-getprovider","text":"inline virtual TimeSeriesProvider < T > * GetProvider ( const string & dataId )","title":"function GetProvider"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeriesLibrary/#function-getensembletimeseries","text":"inline virtual MultiTimeSeries < TS * > * GetEnsembleTimeSeries ( const string & dataId ) Reimplemented by : datatypes::timeseries::TimeSeriesLibrary::GetEnsembleTimeSeries","title":"function GetEnsembleTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeriesLibrary/#function-getalltimeseries","text":"inline virtual MultiTimeSeries < TS * > * GetAllTimeSeries ( const string & dataId ) Reimplemented by : datatypes::timeseries::TimeSeriesLibrary::GetAllTimeSeries","title":"function GetAllTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeriesLibrary/#function-gettimeseriesensembletimeseries","text":"inline virtual EnsembleForecastTimeSeries < TS > * GetTimeSeriesEnsembleTimeSeries ( const string & dataId ) Reimplemented by : datatypes::timeseries::TimeSeriesLibrary::GetTimeSeriesEnsembleTimeSeries","title":"function GetTimeSeriesEnsembleTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TTimeSeriesLibrary/#function-getidentifiers","text":"inline virtual vector < string > GetIdentifiers () const Reimplemented by : datatypes::timeseries::TimeSeriesLibrary::GetIdentifiers Updated on 2022-08-20 at 19:28:22 +1000","title":"function GetIdentifiers"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/","text":"datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy \u00b6 More... #include <time_series_store.hpp> Inherits from datatypes::timeseries::EnsembleStoragePolicy< TsType > Public Types \u00b6 Name using double T typedef std::remove_pointer< TsType >::type Type typedef std::add_pointer< Type >::type PtrType typedef Type::ElementType ElementType Public Functions \u00b6 Name TimeSeriesEnsembleTimeSeriesStoragePolicy ( WritableTimeSeriesEnsembleTimeSeriesStore < T > * store, size_t index) virtual void Reset (const vector< PtrType > & values, const ptime & startDate, const TimeStep & timeStep) TimeSeriesEnsembleTimeSeriesStoragePolicy (const TimeSeriesEnsembleTimeSeriesStoragePolicy < TsType > & src) virtual EnsembleStoragePolicy < TsType > * Clone () const ~TimeSeriesEnsembleTimeSeriesStoragePolicy () TimeSeriesEnsembleTimeSeriesStoragePolicy & operator= ( TimeSeriesEnsembleTimeSeriesStoragePolicy && src) virtual void ResetSeries (const size_t & numSeries, const size_t & lengthSeries, const ptime & startDate, const TimeStep & timeStep) PtrType GetReplicate (size_t i) virtual TsType Get (size_t i) virtual ElementType Get (size_t i, size_t tsIndex) virtual void Set (size_t i, size_t tsIndex, ElementType val) virtual void Set (size_t i, const Type & val) virtual vector< ElementType * > * GetValues () const virtual void CopyTo ( ElementType ** dest) const virtual size_t Size () const virtual size_t GetLength (size_t i) const virtual void Clear () virtual const vector< PtrType > & AsReadonlyVector () const Protected Functions \u00b6 Name virtual void OperatorEqualImpl (const EnsembleStoragePolicy < TsType > & src) Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::EnsembleStoragePolicy< TsType > Name EnsembleStoragePolicy () virtual ~EnsembleStoragePolicy () Detailed Description \u00b6 template < typename TsType > class datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStoragePolicy ; Public Types Documentation \u00b6 using T \u00b6 using datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStoragePolicy < TsType >:: T = double ; typedef Type \u00b6 typedef std :: remove_pointer < TsType >:: type datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStoragePolicy < TsType >:: Type ; typedef PtrType \u00b6 typedef std :: add_pointer < Type >:: type datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStoragePolicy < TsType >:: PtrType ; typedef ElementType \u00b6 typedef Type :: ElementType datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStoragePolicy < TsType >:: ElementType ; Public Functions Documentation \u00b6 function TimeSeriesEnsembleTimeSeriesStoragePolicy \u00b6 inline TimeSeriesEnsembleTimeSeriesStoragePolicy ( WritableTimeSeriesEnsembleTimeSeriesStore < T > * store , size_t index ) function Reset \u00b6 inline virtual void Reset ( const vector < PtrType > & values , const ptime & startDate , const TimeStep & timeStep ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Reset function TimeSeriesEnsembleTimeSeriesStoragePolicy \u00b6 inline TimeSeriesEnsembleTimeSeriesStoragePolicy ( const TimeSeriesEnsembleTimeSeriesStoragePolicy < TsType > & src ) function Clone \u00b6 inline virtual EnsembleStoragePolicy < TsType > * Clone () const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Clone function ~TimeSeriesEnsembleTimeSeriesStoragePolicy \u00b6 inline ~ TimeSeriesEnsembleTimeSeriesStoragePolicy () function operator= \u00b6 inline TimeSeriesEnsembleTimeSeriesStoragePolicy & operator = ( TimeSeriesEnsembleTimeSeriesStoragePolicy && src ) function ResetSeries \u00b6 inline virtual void ResetSeries ( const size_t & numSeries , const size_t & lengthSeries , const ptime & startDate , const TimeStep & timeStep ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::ResetSeries function GetReplicate \u00b6 inline PtrType GetReplicate ( size_t i ) function Get \u00b6 inline virtual TsType Get ( size_t i ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Get function Get \u00b6 inline virtual ElementType Get ( size_t i , size_t tsIndex ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Get function Set \u00b6 inline virtual void Set ( size_t i , size_t tsIndex , ElementType val ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Set function Set \u00b6 inline virtual void Set ( size_t i , const Type & val ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Set function GetValues \u00b6 inline virtual vector < ElementType * > * GetValues () const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::GetValues function CopyTo \u00b6 inline virtual void CopyTo ( ElementType ** dest ) const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::CopyTo function Size \u00b6 inline virtual size_t Size () const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Size function GetLength \u00b6 inline virtual size_t GetLength ( size_t i ) const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::GetLength function Clear \u00b6 inline virtual void Clear () Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Clear function AsReadonlyVector \u00b6 inline virtual const vector < PtrType > & AsReadonlyVector () const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::AsReadonlyVector Protected Functions Documentation \u00b6 function OperatorEqualImpl \u00b6 inline virtual void OperatorEqualImpl ( const EnsembleStoragePolicy < TsType > & src ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::OperatorEqualImpl Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#datatypestimeseriestimeseriesensembletimeseriesstoragepolicy","text":"More... #include <time_series_store.hpp> Inherits from datatypes::timeseries::EnsembleStoragePolicy< TsType >","title":"datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#public-types","text":"Name using double T typedef std::remove_pointer< TsType >::type Type typedef std::add_pointer< Type >::type PtrType typedef Type::ElementType ElementType","title":"Public Types"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#public-functions","text":"Name TimeSeriesEnsembleTimeSeriesStoragePolicy ( WritableTimeSeriesEnsembleTimeSeriesStore < T > * store, size_t index) virtual void Reset (const vector< PtrType > & values, const ptime & startDate, const TimeStep & timeStep) TimeSeriesEnsembleTimeSeriesStoragePolicy (const TimeSeriesEnsembleTimeSeriesStoragePolicy < TsType > & src) virtual EnsembleStoragePolicy < TsType > * Clone () const ~TimeSeriesEnsembleTimeSeriesStoragePolicy () TimeSeriesEnsembleTimeSeriesStoragePolicy & operator= ( TimeSeriesEnsembleTimeSeriesStoragePolicy && src) virtual void ResetSeries (const size_t & numSeries, const size_t & lengthSeries, const ptime & startDate, const TimeStep & timeStep) PtrType GetReplicate (size_t i) virtual TsType Get (size_t i) virtual ElementType Get (size_t i, size_t tsIndex) virtual void Set (size_t i, size_t tsIndex, ElementType val) virtual void Set (size_t i, const Type & val) virtual vector< ElementType * > * GetValues () const virtual void CopyTo ( ElementType ** dest) const virtual size_t Size () const virtual size_t GetLength (size_t i) const virtual void Clear () virtual const vector< PtrType > & AsReadonlyVector () const","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#protected-functions","text":"Name virtual void OperatorEqualImpl (const EnsembleStoragePolicy < TsType > & src)","title":"Protected Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::EnsembleStoragePolicy< TsType > Name EnsembleStoragePolicy () virtual ~EnsembleStoragePolicy ()","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#detailed-description","text":"template < typename TsType > class datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStoragePolicy ;","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#using-t","text":"using datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStoragePolicy < TsType >:: T = double ;","title":"using T"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#typedef-type","text":"typedef std :: remove_pointer < TsType >:: type datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStoragePolicy < TsType >:: Type ;","title":"typedef Type"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#typedef-ptrtype","text":"typedef std :: add_pointer < Type >:: type datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStoragePolicy < TsType >:: PtrType ;","title":"typedef PtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#typedef-elementtype","text":"typedef Type :: ElementType datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStoragePolicy < TsType >:: ElementType ;","title":"typedef ElementType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#function-timeseriesensembletimeseriesstoragepolicy","text":"inline TimeSeriesEnsembleTimeSeriesStoragePolicy ( WritableTimeSeriesEnsembleTimeSeriesStore < T > * store , size_t index )","title":"function TimeSeriesEnsembleTimeSeriesStoragePolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#function-reset","text":"inline virtual void Reset ( const vector < PtrType > & values , const ptime & startDate , const TimeStep & timeStep ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Reset","title":"function Reset"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#function-timeseriesensembletimeseriesstoragepolicy_1","text":"inline TimeSeriesEnsembleTimeSeriesStoragePolicy ( const TimeSeriesEnsembleTimeSeriesStoragePolicy < TsType > & src )","title":"function TimeSeriesEnsembleTimeSeriesStoragePolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#function-clone","text":"inline virtual EnsembleStoragePolicy < TsType > * Clone () const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Clone","title":"function Clone"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#function-timeseriesensembletimeseriesstoragepolicy_2","text":"inline ~ TimeSeriesEnsembleTimeSeriesStoragePolicy ()","title":"function ~TimeSeriesEnsembleTimeSeriesStoragePolicy"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#function-operator","text":"inline TimeSeriesEnsembleTimeSeriesStoragePolicy & operator = ( TimeSeriesEnsembleTimeSeriesStoragePolicy && src )","title":"function operator="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#function-resetseries","text":"inline virtual void ResetSeries ( const size_t & numSeries , const size_t & lengthSeries , const ptime & startDate , const TimeStep & timeStep ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::ResetSeries","title":"function ResetSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#function-getreplicate","text":"inline PtrType GetReplicate ( size_t i )","title":"function GetReplicate"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#function-get","text":"inline virtual TsType Get ( size_t i ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Get","title":"function Get"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#function-get_1","text":"inline virtual ElementType Get ( size_t i , size_t tsIndex ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Get","title":"function Get"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#function-set","text":"inline virtual void Set ( size_t i , size_t tsIndex , ElementType val ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Set","title":"function Set"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#function-set_1","text":"inline virtual void Set ( size_t i , const Type & val ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Set","title":"function Set"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#function-getvalues","text":"inline virtual vector < ElementType * > * GetValues () const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::GetValues","title":"function GetValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#function-copyto","text":"inline virtual void CopyTo ( ElementType ** dest ) const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::CopyTo","title":"function CopyTo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#function-size","text":"inline virtual size_t Size () const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Size","title":"function Size"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#function-getlength","text":"inline virtual size_t GetLength ( size_t i ) const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::GetLength","title":"function GetLength"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#function-clear","text":"inline virtual void Clear () Reimplements : datatypes::timeseries::EnsembleStoragePolicy::Clear","title":"function Clear"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#function-asreadonlyvector","text":"inline virtual const vector < PtrType > & AsReadonlyVector () const Reimplements : datatypes::timeseries::EnsembleStoragePolicy::AsReadonlyVector","title":"function AsReadonlyVector"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStoragePolicy/#function-operatorequalimpl","text":"inline virtual void OperatorEqualImpl ( const EnsembleStoragePolicy < TsType > & src ) Reimplements : datatypes::timeseries::EnsembleStoragePolicy::OperatorEqualImpl Updated on 2022-08-20 at 19:28:22 +1000","title":"function OperatorEqualImpl"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/","text":"datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore \u00b6 Interface definition for storages of time series of ensembles of time series. More... #include <time_series_store.hpp> Inherits from datatypes::timeseries::IdentifiersProvider , datatypes::timeseries::TimeSeriesInfoProvider , datatypes::timeseries::DataDescriptor Inherited by datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore< ElementType > , datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore< double > , datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore< ElementType > , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore< T > , datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore< T > Public Types \u00b6 Name using typename CommonTypes < T >:: SeriesType SeriesType using typename CommonTypes < T >:: PtrSeriesType PtrSeriesType using typename CommonTypes < T >:: EnsemblePtrType EnsemblePtrType using typename CommonTypes < T >:: PtrEnsemblePtrType PtrEnsemblePtrType using typename CommonTypes < T >:: TSeriesEnsemblePtrType TSeriesEnsemblePtrType using typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType PtrTSeriesEnsemblePtrType Public Functions \u00b6 Name virtual ~TimeSeriesEnsembleTimeSeriesStore () virtual PtrTSeriesEnsemblePtrType GetSeries (const string & dataId) =0 virtual PtrEnsemblePtrType GetItem (const string & dataId, size_t fcastIndex) virtual PtrSeriesType GetItem (const string & dataId, size_t fcastIndex, size_t ensIndex) virtual size_t GetEnsembleSize (const string & dataId, size_t fcastIndex) const virtual PtrEnsemblePtrType Read (const string & ensembleIdentifier) =0 virtual size_t GetLength () const =0 virtual ptime GetStart () const =0 virtual TimeStep GetTimeStep () const =0 virtual vector< string > GetIdentifiers () const Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId) Public Functions inherited from datatypes::timeseries::TimeSeriesInfoProvider Name virtual ~TimeSeriesInfoProvider () Public Functions inherited from datatypes::timeseries::DataDescriptor Name virtual string GetDataSummary () const =0 virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const =0 Detailed Description \u00b6 template < typename T > class datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStore ; Interface definition for storages of time series of ensembles of time series. Template Parameters : T The element type of the time series dealt with, typically double or float. Public Types Documentation \u00b6 using SeriesType \u00b6 using datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStore < T >:: SeriesType = typename CommonTypes < T >:: SeriesType ; using PtrSeriesType \u00b6 using datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStore < T >:: PtrSeriesType = typename CommonTypes < T >:: PtrSeriesType ; using EnsemblePtrType \u00b6 using datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStore < T >:: EnsemblePtrType = typename CommonTypes < T >:: EnsemblePtrType ; using PtrEnsemblePtrType \u00b6 using datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStore < T >:: PtrEnsemblePtrType = typename CommonTypes < T >:: PtrEnsemblePtrType ; using TSeriesEnsemblePtrType \u00b6 using datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStore < T >:: TSeriesEnsemblePtrType = typename CommonTypes < T >:: TSeriesEnsemblePtrType ; using PtrTSeriesEnsemblePtrType \u00b6 using datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStore < T >:: PtrTSeriesEnsemblePtrType = typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType ; Public Functions Documentation \u00b6 function ~TimeSeriesEnsembleTimeSeriesStore \u00b6 inline virtual ~ TimeSeriesEnsembleTimeSeriesStore () function GetSeries \u00b6 virtual PtrTSeriesEnsemblePtrType GetSeries ( const string & dataId ) = 0 Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetSeries , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetSeries , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetSeries , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetSeries function GetItem \u00b6 inline virtual PtrEnsemblePtrType GetItem ( const string & dataId , size_t fcastIndex ) Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetItem function GetItem \u00b6 inline virtual PtrSeriesType GetItem ( const string & dataId , size_t fcastIndex , size_t ensIndex ) Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetItem function GetEnsembleSize \u00b6 inline virtual size_t GetEnsembleSize ( const string & dataId , size_t fcastIndex ) const Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetEnsembleSize function Read \u00b6 virtual PtrEnsemblePtrType Read ( const string & ensembleIdentifier ) = 0 Reimplemented by : datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::Read , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::Read , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::Read function GetLength \u00b6 virtual size_t GetLength () const = 0 Reimplements : datatypes::timeseries::TimeSeriesInfoProvider::GetLength Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetLength , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetLength , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetLength , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetLength function GetStart \u00b6 virtual ptime GetStart () const = 0 Reimplements : datatypes::timeseries::TimeSeriesInfoProvider::GetStart Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetStart , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetStart , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetStart , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetStart function GetTimeStep \u00b6 virtual TimeStep GetTimeStep () const = 0 Reimplements : datatypes::timeseries::TimeSeriesInfoProvider::GetTimeStep Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetTimeStep , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetTimeStep , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetTimeStep , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetTimeStep function GetIdentifiers \u00b6 inline virtual vector < string > GetIdentifiers () const Reimplements : datatypes::timeseries::IdentifiersProvider::GetIdentifiers Reimplemented by : datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetIdentifiers Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/#datatypestimeseriestimeseriesensembletimeseriesstore","text":"Interface definition for storages of time series of ensembles of time series. More... #include <time_series_store.hpp> Inherits from datatypes::timeseries::IdentifiersProvider , datatypes::timeseries::TimeSeriesInfoProvider , datatypes::timeseries::DataDescriptor Inherited by datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore< ElementType > , datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore< double > , datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore< ElementType > , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore< T > , datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore< T >","title":"datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/#public-types","text":"Name using typename CommonTypes < T >:: SeriesType SeriesType using typename CommonTypes < T >:: PtrSeriesType PtrSeriesType using typename CommonTypes < T >:: EnsemblePtrType EnsemblePtrType using typename CommonTypes < T >:: PtrEnsemblePtrType PtrEnsemblePtrType using typename CommonTypes < T >:: TSeriesEnsemblePtrType TSeriesEnsemblePtrType using typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType PtrTSeriesEnsemblePtrType","title":"Public Types"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/#public-functions","text":"Name virtual ~TimeSeriesEnsembleTimeSeriesStore () virtual PtrTSeriesEnsemblePtrType GetSeries (const string & dataId) =0 virtual PtrEnsemblePtrType GetItem (const string & dataId, size_t fcastIndex) virtual PtrSeriesType GetItem (const string & dataId, size_t fcastIndex, size_t ensIndex) virtual size_t GetEnsembleSize (const string & dataId, size_t fcastIndex) const virtual PtrEnsemblePtrType Read (const string & ensembleIdentifier) =0 virtual size_t GetLength () const =0 virtual ptime GetStart () const =0 virtual TimeStep GetTimeStep () const =0 virtual vector< string > GetIdentifiers () const","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId) Public Functions inherited from datatypes::timeseries::TimeSeriesInfoProvider Name virtual ~TimeSeriesInfoProvider () Public Functions inherited from datatypes::timeseries::DataDescriptor Name virtual string GetDataSummary () const =0 virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const =0","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/#detailed-description","text":"template < typename T > class datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStore ; Interface definition for storages of time series of ensembles of time series. Template Parameters : T The element type of the time series dealt with, typically double or float.","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/#using-seriestype","text":"using datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStore < T >:: SeriesType = typename CommonTypes < T >:: SeriesType ;","title":"using SeriesType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/#using-ptrseriestype","text":"using datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStore < T >:: PtrSeriesType = typename CommonTypes < T >:: PtrSeriesType ;","title":"using PtrSeriesType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/#using-ensembleptrtype","text":"using datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStore < T >:: EnsemblePtrType = typename CommonTypes < T >:: EnsemblePtrType ;","title":"using EnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/#using-ptrensembleptrtype","text":"using datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStore < T >:: PtrEnsemblePtrType = typename CommonTypes < T >:: PtrEnsemblePtrType ;","title":"using PtrEnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/#using-tseriesensembleptrtype","text":"using datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStore < T >:: TSeriesEnsemblePtrType = typename CommonTypes < T >:: TSeriesEnsemblePtrType ;","title":"using TSeriesEnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/#using-ptrtseriesensembleptrtype","text":"using datatypes :: timeseries :: TimeSeriesEnsembleTimeSeriesStore < T >:: PtrTSeriesEnsemblePtrType = typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType ;","title":"using PtrTSeriesEnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/#function-timeseriesensembletimeseriesstore","text":"inline virtual ~ TimeSeriesEnsembleTimeSeriesStore ()","title":"function ~TimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/#function-getseries","text":"virtual PtrTSeriesEnsemblePtrType GetSeries ( const string & dataId ) = 0 Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetSeries , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetSeries , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetSeries , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetSeries","title":"function GetSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/#function-getitem","text":"inline virtual PtrEnsemblePtrType GetItem ( const string & dataId , size_t fcastIndex ) Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetItem","title":"function GetItem"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/#function-getitem_1","text":"inline virtual PtrSeriesType GetItem ( const string & dataId , size_t fcastIndex , size_t ensIndex ) Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetItem","title":"function GetItem"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/#function-getensemblesize","text":"inline virtual size_t GetEnsembleSize ( const string & dataId , size_t fcastIndex ) const Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetEnsembleSize","title":"function GetEnsembleSize"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/#function-read","text":"virtual PtrEnsemblePtrType Read ( const string & ensembleIdentifier ) = 0 Reimplemented by : datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::Read , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::Read , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::Read","title":"function Read"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/#function-getlength","text":"virtual size_t GetLength () const = 0 Reimplements : datatypes::timeseries::TimeSeriesInfoProvider::GetLength Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetLength , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetLength , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetLength , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetLength","title":"function GetLength"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/#function-getstart","text":"virtual ptime GetStart () const = 0 Reimplements : datatypes::timeseries::TimeSeriesInfoProvider::GetStart Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetStart , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetStart , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetStart , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetStart","title":"function GetStart"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/#function-gettimestep","text":"virtual TimeStep GetTimeStep () const = 0 Reimplements : datatypes::timeseries::TimeSeriesInfoProvider::GetTimeStep Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetTimeStep , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetTimeStep , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetTimeStep , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetTimeStep","title":"function GetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesEnsembleTimeSeriesStore/#function-getidentifiers","text":"inline virtual vector < string > GetIdentifiers () const Reimplements : datatypes::timeseries::IdentifiersProvider::GetIdentifiers Reimplemented by : datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetIdentifiers Updated on 2022-08-20 at 19:28:22 +1000","title":"function GetIdentifiers"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesIOHelper/","text":"datatypes::timeseries::TimeSeriesIOHelper \u00b6 Representation of an univariate, ensemble time series with a SWIFT netCDF back end. More... #include <time_series_io.hpp> Public Types \u00b6 Name using typename CommonTypes < T >:: SeriesType SeriesType using typename CommonTypes < T >:: PtrSeriesType PtrSeriesType using typename CommonTypes < T >:: EnsemblePtrType EnsemblePtrType using typename CommonTypes < T >:: PtrEnsemblePtrType PtrEnsemblePtrType using typename CommonTypes < T >:: TSeriesEnsemblePtrType TSeriesEnsemblePtrType using typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType PtrTSeriesEnsemblePtrType Public Functions \u00b6 Name SeriesType * Read (const string & netCdfFilePath, const string & varName, const string & identifier) void Write (const string & varName, std::map< string, TTimeSeries < T > * > & recordedTimeSeries, const std::map< string, string > & idMap, const string & filePath) void Write ( DimensionsDefinitions & dimDefinitions, const map< std::string, VariableDefinition > & varDefinitions, const GlobalAttributes & GlobalAttributes, std::map< string, TTimeSeries < T > * > & recordedTimeSeries, const string & filePath) PtrEnsemblePtrType ReadForecastTimeSeries (const string & netCdfFilepath, const string & varName, const string & identifier, int index) PtrTSeriesEnsemblePtrType ReadForecastTimeSeries (const string & netCdfFilepath, const string & varName, const string & identifier) SeriesType * Read (const string & netCdfFilePath, const string & varName, const string & identifier, const TimeWindow < SeriesType > & window) SeriesType * ReadDailyToHourly (const string & netCdfFilePath, const string & varName, const string & identifier, const TimeWindow < SeriesType > & window) Detailed Description \u00b6 template < typename T > class datatypes :: timeseries :: TimeSeriesIOHelper ; Representation of an univariate, ensemble time series with a SWIFT netCDF back end. Template Parameters : T The type of the elements in the series; typically double or float. Public Types Documentation \u00b6 using SeriesType \u00b6 using datatypes :: timeseries :: TimeSeriesIOHelper < T >:: SeriesType = typename CommonTypes < T >:: SeriesType ; using PtrSeriesType \u00b6 using datatypes :: timeseries :: TimeSeriesIOHelper < T >:: PtrSeriesType = typename CommonTypes < T >:: PtrSeriesType ; using EnsemblePtrType \u00b6 using datatypes :: timeseries :: TimeSeriesIOHelper < T >:: EnsemblePtrType = typename CommonTypes < T >:: EnsemblePtrType ; using PtrEnsemblePtrType \u00b6 using datatypes :: timeseries :: TimeSeriesIOHelper < T >:: PtrEnsemblePtrType = typename CommonTypes < T >:: PtrEnsemblePtrType ; using TSeriesEnsemblePtrType \u00b6 using datatypes :: timeseries :: TimeSeriesIOHelper < T >:: TSeriesEnsemblePtrType = typename CommonTypes < T >:: TSeriesEnsemblePtrType ; using PtrTSeriesEnsemblePtrType \u00b6 using datatypes :: timeseries :: TimeSeriesIOHelper < T >:: PtrTSeriesEnsemblePtrType = typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType ; Public Functions Documentation \u00b6 function Read \u00b6 static SeriesType * Read ( const string & netCdfFilePath , const string & varName , const string & identifier ) function Write \u00b6 static void Write ( const string & varName , std :: map < string , TTimeSeries < T > * > & recordedTimeSeries , const std :: map < string , string > & idMap , const string & filePath ) function Write \u00b6 static void Write ( DimensionsDefinitions & dimDefinitions , const map < std :: string , VariableDefinition > & varDefinitions , const GlobalAttributes & GlobalAttributes , std :: map < string , TTimeSeries < T > * > & recordedTimeSeries , const string & filePath ) function ReadForecastTimeSeries \u00b6 static PtrEnsemblePtrType ReadForecastTimeSeries ( const string & netCdfFilepath , const string & varName , const string & identifier , int index ) function ReadForecastTimeSeries \u00b6 static PtrTSeriesEnsemblePtrType ReadForecastTimeSeries ( const string & netCdfFilepath , const string & varName , const string & identifier ) function Read \u00b6 static inline SeriesType * Read ( const string & netCdfFilePath , const string & varName , const string & identifier , const TimeWindow < SeriesType > & window ) function ReadDailyToHourly \u00b6 static inline SeriesType * ReadDailyToHourly ( const string & netCdfFilePath , const string & varName , const string & identifier , const TimeWindow < SeriesType > & window ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::TimeSeriesIOHelper"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesIOHelper/#datatypestimeseriestimeseriesiohelper","text":"Representation of an univariate, ensemble time series with a SWIFT netCDF back end. More... #include <time_series_io.hpp>","title":"datatypes::timeseries::TimeSeriesIOHelper"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesIOHelper/#public-types","text":"Name using typename CommonTypes < T >:: SeriesType SeriesType using typename CommonTypes < T >:: PtrSeriesType PtrSeriesType using typename CommonTypes < T >:: EnsemblePtrType EnsemblePtrType using typename CommonTypes < T >:: PtrEnsemblePtrType PtrEnsemblePtrType using typename CommonTypes < T >:: TSeriesEnsemblePtrType TSeriesEnsemblePtrType using typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType PtrTSeriesEnsemblePtrType","title":"Public Types"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesIOHelper/#public-functions","text":"Name SeriesType * Read (const string & netCdfFilePath, const string & varName, const string & identifier) void Write (const string & varName, std::map< string, TTimeSeries < T > * > & recordedTimeSeries, const std::map< string, string > & idMap, const string & filePath) void Write ( DimensionsDefinitions & dimDefinitions, const map< std::string, VariableDefinition > & varDefinitions, const GlobalAttributes & GlobalAttributes, std::map< string, TTimeSeries < T > * > & recordedTimeSeries, const string & filePath) PtrEnsemblePtrType ReadForecastTimeSeries (const string & netCdfFilepath, const string & varName, const string & identifier, int index) PtrTSeriesEnsemblePtrType ReadForecastTimeSeries (const string & netCdfFilepath, const string & varName, const string & identifier) SeriesType * Read (const string & netCdfFilePath, const string & varName, const string & identifier, const TimeWindow < SeriesType > & window) SeriesType * ReadDailyToHourly (const string & netCdfFilePath, const string & varName, const string & identifier, const TimeWindow < SeriesType > & window)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesIOHelper/#detailed-description","text":"template < typename T > class datatypes :: timeseries :: TimeSeriesIOHelper ; Representation of an univariate, ensemble time series with a SWIFT netCDF back end. Template Parameters : T The type of the elements in the series; typically double or float.","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesIOHelper/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesIOHelper/#using-seriestype","text":"using datatypes :: timeseries :: TimeSeriesIOHelper < T >:: SeriesType = typename CommonTypes < T >:: SeriesType ;","title":"using SeriesType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesIOHelper/#using-ptrseriestype","text":"using datatypes :: timeseries :: TimeSeriesIOHelper < T >:: PtrSeriesType = typename CommonTypes < T >:: PtrSeriesType ;","title":"using PtrSeriesType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesIOHelper/#using-ensembleptrtype","text":"using datatypes :: timeseries :: TimeSeriesIOHelper < T >:: EnsemblePtrType = typename CommonTypes < T >:: EnsemblePtrType ;","title":"using EnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesIOHelper/#using-ptrensembleptrtype","text":"using datatypes :: timeseries :: TimeSeriesIOHelper < T >:: PtrEnsemblePtrType = typename CommonTypes < T >:: PtrEnsemblePtrType ;","title":"using PtrEnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesIOHelper/#using-tseriesensembleptrtype","text":"using datatypes :: timeseries :: TimeSeriesIOHelper < T >:: TSeriesEnsemblePtrType = typename CommonTypes < T >:: TSeriesEnsemblePtrType ;","title":"using TSeriesEnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesIOHelper/#using-ptrtseriesensembleptrtype","text":"using datatypes :: timeseries :: TimeSeriesIOHelper < T >:: PtrTSeriesEnsemblePtrType = typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType ;","title":"using PtrTSeriesEnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesIOHelper/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesIOHelper/#function-read","text":"static SeriesType * Read ( const string & netCdfFilePath , const string & varName , const string & identifier )","title":"function Read"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesIOHelper/#function-write","text":"static void Write ( const string & varName , std :: map < string , TTimeSeries < T > * > & recordedTimeSeries , const std :: map < string , string > & idMap , const string & filePath )","title":"function Write"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesIOHelper/#function-write_1","text":"static void Write ( DimensionsDefinitions & dimDefinitions , const map < std :: string , VariableDefinition > & varDefinitions , const GlobalAttributes & GlobalAttributes , std :: map < string , TTimeSeries < T > * > & recordedTimeSeries , const string & filePath )","title":"function Write"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesIOHelper/#function-readforecasttimeseries","text":"static PtrEnsemblePtrType ReadForecastTimeSeries ( const string & netCdfFilepath , const string & varName , const string & identifier , int index )","title":"function ReadForecastTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesIOHelper/#function-readforecasttimeseries_1","text":"static PtrTSeriesEnsemblePtrType ReadForecastTimeSeries ( const string & netCdfFilepath , const string & varName , const string & identifier )","title":"function ReadForecastTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesIOHelper/#function-read_1","text":"static inline SeriesType * Read ( const string & netCdfFilePath , const string & varName , const string & identifier , const TimeWindow < SeriesType > & window )","title":"function Read"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesIOHelper/#function-readdailytohourly","text":"static inline SeriesType * ReadDailyToHourly ( const string & netCdfFilePath , const string & varName , const string & identifier , const TimeWindow < SeriesType > & window ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function ReadDailyToHourly"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesInfoProvider/","text":"datatypes::timeseries::TimeSeriesInfoProvider \u00b6 An interface definition for classes that can provide essential time series temporal characteristics. #include <time_step.h> Inherited by datatypes::timeseries::StoragePolicy< double > , datatypes::timeseries::StoragePolicy< StorageType > , datatypes::timeseries::StoragePolicy< T > , datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T > Public Functions \u00b6 Name virtual ~TimeSeriesInfoProvider () virtual size_t GetLength () const =0 virtual TimeStep GetTimeStep () const =0 virtual ptime GetStart () const =0 Public Functions Documentation \u00b6 function ~TimeSeriesInfoProvider \u00b6 virtual ~ TimeSeriesInfoProvider () function GetLength \u00b6 virtual size_t GetLength () const = 0 Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetLength , datatypes::timeseries::EagerWriter::GetLength , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetLength , datatypes::timeseries::MultiFileTsStorage::GetLength , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetLength , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetLength , datatypes::timeseries::StlVectorStorage::GetLength , datatypes::timeseries::SharedVectorStorage::GetLength , datatypes::timeseries::MemoryCachingStorageWriter::GetLength , datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetLength function GetTimeStep \u00b6 virtual TimeStep GetTimeStep () const = 0 Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetTimeStep , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetTimeStep , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetTimeStep , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetTimeStep , datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetTimeStep , datatypes::timeseries::StoragePolicy::GetTimeStep , datatypes::timeseries::EagerWriter::GetTimeStep , datatypes::timeseries::MultiFileTsStorage::GetTimeStep , datatypes::timeseries::StlVectorStorage::GetTimeStep , datatypes::timeseries::SharedVectorStorage::GetTimeStep , datatypes::timeseries::MemoryCachingStorageWriter::GetTimeStep , datatypes::timeseries::StoragePolicy::GetTimeStep , datatypes::timeseries::StoragePolicy::GetTimeStep function GetStart \u00b6 virtual ptime GetStart () const = 0 Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetStart , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetStart , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetStart , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetStart , datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetStart , datatypes::timeseries::StoragePolicy::GetStart , datatypes::timeseries::EagerWriter::GetStart , datatypes::timeseries::MultiFileTsStorage::GetStart , datatypes::timeseries::StlVectorStorage::GetStart , datatypes::timeseries::SharedVectorStorage::GetStart , datatypes::timeseries::MemoryCachingStorageWriter::GetStart , datatypes::timeseries::StoragePolicy::GetStart , datatypes::timeseries::StoragePolicy::GetStart Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::TimeSeriesInfoProvider"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesInfoProvider/#datatypestimeseriestimeseriesinfoprovider","text":"An interface definition for classes that can provide essential time series temporal characteristics. #include <time_step.h> Inherited by datatypes::timeseries::StoragePolicy< double > , datatypes::timeseries::StoragePolicy< StorageType > , datatypes::timeseries::StoragePolicy< T > , datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T >","title":"datatypes::timeseries::TimeSeriesInfoProvider"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesInfoProvider/#public-functions","text":"Name virtual ~TimeSeriesInfoProvider () virtual size_t GetLength () const =0 virtual TimeStep GetTimeStep () const =0 virtual ptime GetStart () const =0","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesInfoProvider/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesInfoProvider/#function-timeseriesinfoprovider","text":"virtual ~ TimeSeriesInfoProvider ()","title":"function ~TimeSeriesInfoProvider"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesInfoProvider/#function-getlength","text":"virtual size_t GetLength () const = 0 Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetLength , datatypes::timeseries::EagerWriter::GetLength , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetLength , datatypes::timeseries::MultiFileTsStorage::GetLength , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetLength , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetLength , datatypes::timeseries::StlVectorStorage::GetLength , datatypes::timeseries::SharedVectorStorage::GetLength , datatypes::timeseries::MemoryCachingStorageWriter::GetLength , datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetLength","title":"function GetLength"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesInfoProvider/#function-gettimestep","text":"virtual TimeStep GetTimeStep () const = 0 Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetTimeStep , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetTimeStep , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetTimeStep , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetTimeStep , datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetTimeStep , datatypes::timeseries::StoragePolicy::GetTimeStep , datatypes::timeseries::EagerWriter::GetTimeStep , datatypes::timeseries::MultiFileTsStorage::GetTimeStep , datatypes::timeseries::StlVectorStorage::GetTimeStep , datatypes::timeseries::SharedVectorStorage::GetTimeStep , datatypes::timeseries::MemoryCachingStorageWriter::GetTimeStep , datatypes::timeseries::StoragePolicy::GetTimeStep , datatypes::timeseries::StoragePolicy::GetTimeStep","title":"function GetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesInfoProvider/#function-getstart","text":"virtual ptime GetStart () const = 0 Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::GetStart , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::GetStart , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetStart , datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore::GetStart , datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore::GetStart , datatypes::timeseries::StoragePolicy::GetStart , datatypes::timeseries::EagerWriter::GetStart , datatypes::timeseries::MultiFileTsStorage::GetStart , datatypes::timeseries::StlVectorStorage::GetStart , datatypes::timeseries::SharedVectorStorage::GetStart , datatypes::timeseries::MemoryCachingStorageWriter::GetStart , datatypes::timeseries::StoragePolicy::GetStart , datatypes::timeseries::StoragePolicy::GetStart Updated on 2022-08-20 at 19:28:22 +1000","title":"function GetStart"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/","text":"datatypes::timeseries::TimeSeriesLibrary \u00b6 Library of time series, for high level access to sources of time series that nmay have varying on-disk representations. More... #include <time_series_store.hpp> Inherits from datatypes::timeseries::TimeSeriesProvider< double > , datatypes::timeseries::TTimeSeriesLibrary< double > , datatypes::timeseries::IdentifiersProvider Public Functions \u00b6 Name TimeSeriesLibrary ( TimeSeriesStoreFactory * storeCreator =nullptr) TimeSeriesLibrary (const TimeSeriesLibraryDescription & description) virtual ~TimeSeriesLibrary () void Close () TimeSeriesLibrary & operator= ( TimeSeriesLibrary && src) TimeSeriesLibrary ( TimeSeriesLibrary && src) Constructor using the move semantics. TTimeSeries < double > * GetSingle (const string & dataId, boost::function< TTimeSeries < double > *( TTimeSeries < double > *)> & tsTransform) Gets a single time series out of the library. virtual vector< string > GetIdentifiers () const vector< string > GetIdentifiers (const string & dataId) const string GetDataSummary (const string & dataId) vector< DataDimensionDescriptor > GetDataDimensionsDescription (const string & dataId) virtual TTimeSeries < double > * GetSingle (const string & dataId) Gets a single time series out of the library. virtual MultiTimeSeries < TTimeSeries < double > * > * GetCollection (const string & dataId) Gets a collection of time series out of the library, where each item is for a given station ID. virtual TTimeSeries < double > * GetSingle (const string & dataId, const string & collectionIdentifier) ** MultiTimeSeries < TTimeSeries < double > * > * GetEnsemble (const string & dataId, const string & dataItemIdentifier) virtual MultiTimeSeries < TTimeSeries < double > * > * GetEnsembleTimeSeries (const string & dataId) virtual MultiTimeSeries < TTimeSeries < double > * > * GetAllTimeSeries (const string & dataId) virtual EnsembleForecastTimeSeries < TTimeSeries < double > > * GetTimeSeriesEnsembleTimeSeries (const string & dataId) void AddSource (const string & dataId, SingleTimeSeriesStore < double > * store) void AddSource (const string & dataId, EnsembleTimeSeriesStore < double > * store) void AddSource (const string & dataId, TimeSeriesEnsembleTimeSeriesStore < double > * dataAccess) bool CanCreateTimeSeriesEnsembleSeriesStore (const string & dataId) void CreateTimeSeriesEnsembleSeriesStore (const string & dataId) Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::TimeSeriesProvider< double > Name virtual ~TimeSeriesProvider () Public Types inherited from datatypes::timeseries::TTimeSeriesLibrary< double > Name typedef TTimeSeries < T > TS typedef MultiTimeSeries < TS * > MTS Public Functions inherited from datatypes::timeseries::TTimeSeriesLibrary< double > Name virtual ~TTimeSeriesLibrary () virtual TimeSeriesProvider < T > * GetProvider (const string & dataId) Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId) Detailed Description \u00b6 class datatypes :: timeseries :: TimeSeriesLibrary ; Library of time series, for high level access to sources of time series that nmay have varying on-disk representations. Template Parameters : T The element type of the time series dealt with, typically double or float. Public Functions Documentation \u00b6 function TimeSeriesLibrary \u00b6 TimeSeriesLibrary ( TimeSeriesStoreFactory * storeCreator = nullptr ) function TimeSeriesLibrary \u00b6 TimeSeriesLibrary ( const TimeSeriesLibraryDescription & description ) function ~TimeSeriesLibrary \u00b6 virtual ~ TimeSeriesLibrary () function Close \u00b6 void Close () function operator= \u00b6 TimeSeriesLibrary & operator = ( TimeSeriesLibrary && src ) function TimeSeriesLibrary \u00b6 TimeSeriesLibrary ( TimeSeriesLibrary && src ) Constructor using the move semantics. Parameters : src time series library from which to move data. Remark : C++ for the Impatient Appendix A. A Painless Introduction to Rvalue References (C++11) See also http://stackoverflow.com/a/3109981/2752565 for information on move semantic function GetSingle \u00b6 TTimeSeries < double > * GetSingle ( const string & dataId , boost :: function < TTimeSeries < double > * ( TTimeSeries < double > * ) > & tsTransform ) Gets a single time series out of the library. Parameters : dataId Identifier for the time series tsTransform If non-null, a time series transformation to perform on the raw data retrieved for dataId. Return : The univariate, single realization time series function GetIdentifiers \u00b6 virtual vector < string > GetIdentifiers () const Reimplements : datatypes::timeseries::TTimeSeriesLibrary::GetIdentifiers function GetIdentifiers \u00b6 vector < string > GetIdentifiers ( const string & dataId ) const function GetDataSummary \u00b6 string GetDataSummary ( const string & dataId ) function GetDataDimensionsDescription \u00b6 vector < DataDimensionDescriptor > GetDataDimensionsDescription ( const string & dataId ) function GetSingle \u00b6 virtual TTimeSeries < double > * GetSingle ( const string & dataId ) Gets a single time series out of the library. Parameters : dataId Identifier for the time series Return : The univariate, single realization time series Reimplements : datatypes::timeseries::TimeSeriesProvider::GetSingle function GetCollection \u00b6 virtual MultiTimeSeries < TTimeSeries < double > * > * GetCollection ( const string & dataId ) Gets a collection of time series out of the library, where each item is for a given station ID. Parameters : dataId Identifier for the time series Return : The collection of univariate, single realization time series Reimplements : datatypes::timeseries::TTimeSeriesLibrary::GetCollection function GetSingle \u00b6 virtual TTimeSeries < double > * GetSingle ( const string & dataId , const string & collectionIdentifier ) ** Parameters : dataId Identifier for the collection of time series collectionIdentifier Identifier for the item to retrieve in the collection. Typically, a station identifier Return : The univariate, single realization time series Reimplements : datatypes::timeseries::TTimeSeriesLibrary::GetSingle Gets a single time series out of the library function GetEnsemble \u00b6 MultiTimeSeries < TTimeSeries < double > * > * GetEnsemble ( const string & dataId , const string & dataItemIdentifier ) function GetEnsembleTimeSeries \u00b6 virtual MultiTimeSeries < TTimeSeries < double > * > * GetEnsembleTimeSeries ( const string & dataId ) Reimplements : datatypes::timeseries::TTimeSeriesLibrary::GetEnsembleTimeSeries function GetAllTimeSeries \u00b6 virtual MultiTimeSeries < TTimeSeries < double > * > * GetAllTimeSeries ( const string & dataId ) Reimplements : datatypes::timeseries::TTimeSeriesLibrary::GetAllTimeSeries function GetTimeSeriesEnsembleTimeSeries \u00b6 virtual EnsembleForecastTimeSeries < TTimeSeries < double > > * GetTimeSeriesEnsembleTimeSeries ( const string & dataId ) Reimplements : datatypes::timeseries::TTimeSeriesLibrary::GetTimeSeriesEnsembleTimeSeries function AddSource \u00b6 void AddSource ( const string & dataId , SingleTimeSeriesStore < double > * store ) function AddSource \u00b6 void AddSource ( const string & dataId , EnsembleTimeSeriesStore < double > * store ) function AddSource \u00b6 void AddSource ( const string & dataId , TimeSeriesEnsembleTimeSeriesStore < double > * dataAccess ) function CanCreateTimeSeriesEnsembleSeriesStore \u00b6 bool CanCreateTimeSeriesEnsembleSeriesStore ( const string & dataId ) function CreateTimeSeriesEnsembleSeriesStore \u00b6 void CreateTimeSeriesEnsembleSeriesStore ( const string & dataId ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::TimeSeriesLibrary"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#datatypestimeseriestimeserieslibrary","text":"Library of time series, for high level access to sources of time series that nmay have varying on-disk representations. More... #include <time_series_store.hpp> Inherits from datatypes::timeseries::TimeSeriesProvider< double > , datatypes::timeseries::TTimeSeriesLibrary< double > , datatypes::timeseries::IdentifiersProvider","title":"datatypes::timeseries::TimeSeriesLibrary"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#public-functions","text":"Name TimeSeriesLibrary ( TimeSeriesStoreFactory * storeCreator =nullptr) TimeSeriesLibrary (const TimeSeriesLibraryDescription & description) virtual ~TimeSeriesLibrary () void Close () TimeSeriesLibrary & operator= ( TimeSeriesLibrary && src) TimeSeriesLibrary ( TimeSeriesLibrary && src) Constructor using the move semantics. TTimeSeries < double > * GetSingle (const string & dataId, boost::function< TTimeSeries < double > *( TTimeSeries < double > *)> & tsTransform) Gets a single time series out of the library. virtual vector< string > GetIdentifiers () const vector< string > GetIdentifiers (const string & dataId) const string GetDataSummary (const string & dataId) vector< DataDimensionDescriptor > GetDataDimensionsDescription (const string & dataId) virtual TTimeSeries < double > * GetSingle (const string & dataId) Gets a single time series out of the library. virtual MultiTimeSeries < TTimeSeries < double > * > * GetCollection (const string & dataId) Gets a collection of time series out of the library, where each item is for a given station ID. virtual TTimeSeries < double > * GetSingle (const string & dataId, const string & collectionIdentifier) ** MultiTimeSeries < TTimeSeries < double > * > * GetEnsemble (const string & dataId, const string & dataItemIdentifier) virtual MultiTimeSeries < TTimeSeries < double > * > * GetEnsembleTimeSeries (const string & dataId) virtual MultiTimeSeries < TTimeSeries < double > * > * GetAllTimeSeries (const string & dataId) virtual EnsembleForecastTimeSeries < TTimeSeries < double > > * GetTimeSeriesEnsembleTimeSeries (const string & dataId) void AddSource (const string & dataId, SingleTimeSeriesStore < double > * store) void AddSource (const string & dataId, EnsembleTimeSeriesStore < double > * store) void AddSource (const string & dataId, TimeSeriesEnsembleTimeSeriesStore < double > * dataAccess) bool CanCreateTimeSeriesEnsembleSeriesStore (const string & dataId) void CreateTimeSeriesEnsembleSeriesStore (const string & dataId)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::TimeSeriesProvider< double > Name virtual ~TimeSeriesProvider () Public Types inherited from datatypes::timeseries::TTimeSeriesLibrary< double > Name typedef TTimeSeries < T > TS typedef MultiTimeSeries < TS * > MTS Public Functions inherited from datatypes::timeseries::TTimeSeriesLibrary< double > Name virtual ~TTimeSeriesLibrary () virtual TimeSeriesProvider < T > * GetProvider (const string & dataId) Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId)","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#detailed-description","text":"class datatypes :: timeseries :: TimeSeriesLibrary ; Library of time series, for high level access to sources of time series that nmay have varying on-disk representations. Template Parameters : T The element type of the time series dealt with, typically double or float.","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#function-timeserieslibrary","text":"TimeSeriesLibrary ( TimeSeriesStoreFactory * storeCreator = nullptr )","title":"function TimeSeriesLibrary"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#function-timeserieslibrary_1","text":"TimeSeriesLibrary ( const TimeSeriesLibraryDescription & description )","title":"function TimeSeriesLibrary"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#function-timeserieslibrary_2","text":"virtual ~ TimeSeriesLibrary ()","title":"function ~TimeSeriesLibrary"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#function-close","text":"void Close ()","title":"function Close"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#function-operator","text":"TimeSeriesLibrary & operator = ( TimeSeriesLibrary && src )","title":"function operator="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#function-timeserieslibrary_3","text":"TimeSeriesLibrary ( TimeSeriesLibrary && src ) Constructor using the move semantics. Parameters : src time series library from which to move data. Remark : C++ for the Impatient Appendix A. A Painless Introduction to Rvalue References (C++11) See also http://stackoverflow.com/a/3109981/2752565 for information on move semantic","title":"function TimeSeriesLibrary"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#function-getsingle","text":"TTimeSeries < double > * GetSingle ( const string & dataId , boost :: function < TTimeSeries < double > * ( TTimeSeries < double > * ) > & tsTransform ) Gets a single time series out of the library. Parameters : dataId Identifier for the time series tsTransform If non-null, a time series transformation to perform on the raw data retrieved for dataId. Return : The univariate, single realization time series","title":"function GetSingle"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#function-getidentifiers","text":"virtual vector < string > GetIdentifiers () const Reimplements : datatypes::timeseries::TTimeSeriesLibrary::GetIdentifiers","title":"function GetIdentifiers"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#function-getidentifiers_1","text":"vector < string > GetIdentifiers ( const string & dataId ) const","title":"function GetIdentifiers"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#function-getdatasummary","text":"string GetDataSummary ( const string & dataId )","title":"function GetDataSummary"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#function-getdatadimensionsdescription","text":"vector < DataDimensionDescriptor > GetDataDimensionsDescription ( const string & dataId )","title":"function GetDataDimensionsDescription"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#function-getsingle_1","text":"virtual TTimeSeries < double > * GetSingle ( const string & dataId ) Gets a single time series out of the library. Parameters : dataId Identifier for the time series Return : The univariate, single realization time series Reimplements : datatypes::timeseries::TimeSeriesProvider::GetSingle","title":"function GetSingle"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#function-getcollection","text":"virtual MultiTimeSeries < TTimeSeries < double > * > * GetCollection ( const string & dataId ) Gets a collection of time series out of the library, where each item is for a given station ID. Parameters : dataId Identifier for the time series Return : The collection of univariate, single realization time series Reimplements : datatypes::timeseries::TTimeSeriesLibrary::GetCollection","title":"function GetCollection"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#function-getsingle_2","text":"virtual TTimeSeries < double > * GetSingle ( const string & dataId , const string & collectionIdentifier ) ** Parameters : dataId Identifier for the collection of time series collectionIdentifier Identifier for the item to retrieve in the collection. Typically, a station identifier Return : The univariate, single realization time series Reimplements : datatypes::timeseries::TTimeSeriesLibrary::GetSingle Gets a single time series out of the library","title":"function GetSingle"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#function-getensemble","text":"MultiTimeSeries < TTimeSeries < double > * > * GetEnsemble ( const string & dataId , const string & dataItemIdentifier )","title":"function GetEnsemble"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#function-getensembletimeseries","text":"virtual MultiTimeSeries < TTimeSeries < double > * > * GetEnsembleTimeSeries ( const string & dataId ) Reimplements : datatypes::timeseries::TTimeSeriesLibrary::GetEnsembleTimeSeries","title":"function GetEnsembleTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#function-getalltimeseries","text":"virtual MultiTimeSeries < TTimeSeries < double > * > * GetAllTimeSeries ( const string & dataId ) Reimplements : datatypes::timeseries::TTimeSeriesLibrary::GetAllTimeSeries","title":"function GetAllTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#function-gettimeseriesensembletimeseries","text":"virtual EnsembleForecastTimeSeries < TTimeSeries < double > > * GetTimeSeriesEnsembleTimeSeries ( const string & dataId ) Reimplements : datatypes::timeseries::TTimeSeriesLibrary::GetTimeSeriesEnsembleTimeSeries","title":"function GetTimeSeriesEnsembleTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#function-addsource","text":"void AddSource ( const string & dataId , SingleTimeSeriesStore < double > * store )","title":"function AddSource"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#function-addsource_1","text":"void AddSource ( const string & dataId , EnsembleTimeSeriesStore < double > * store )","title":"function AddSource"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#function-addsource_2","text":"void AddSource ( const string & dataId , TimeSeriesEnsembleTimeSeriesStore < double > * dataAccess )","title":"function AddSource"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#function-cancreatetimeseriesensembleseriesstore","text":"bool CanCreateTimeSeriesEnsembleSeriesStore ( const string & dataId )","title":"function CanCreateTimeSeriesEnsembleSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibrary/#function-createtimeseriesensembleseriesstore","text":"void CreateTimeSeriesEnsembleSeriesStore ( const string & dataId ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function CreateTimeSeriesEnsembleSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryDescription/","text":"datatypes::timeseries::TimeSeriesLibraryDescription \u00b6 #include <time_series_store.hpp> Public Functions \u00b6 Name void AddSingle (const string & dataId, const TimeSeriesSourceInfo & t) void AddEnsembleTs (const string & dataId, const TimeSeriesSourceInfo & t) void AddTsEnsembleTs (const string & dataId, const TimeSeriesSourceInfo & t) boost::filesystem::path GetFullPath (const string & relativePath) const string GetRootDirectory () const vector< string > GetDataIdSingle () const vector< string > GetDataIdEnsembleTs () const vector< string > GetDataIdTsEnsembleTs () const std::map< string, string > GetSerializableConfiguration (const string & dataId, const vector< string > & mandatoryKeys =vector< string >({})) const void SetLoadedFileName (const string & fileName) void SetDataPath (const string & dataPath) string GetDataPath () const SingleTimeSeriesStore < double > * CreateSingleTimeSeriesStore (const string & dataId) const EnsembleTimeSeriesStore < double > * CreateEnsembleTimeSeriesStore (const string & dataId) const TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore (const string & dataId) const Friends \u00b6 Name class TimeSeriesLibrary Public Functions Documentation \u00b6 function AddSingle \u00b6 void AddSingle ( const string & dataId , const TimeSeriesSourceInfo & t ) function AddEnsembleTs \u00b6 void AddEnsembleTs ( const string & dataId , const TimeSeriesSourceInfo & t ) function AddTsEnsembleTs \u00b6 void AddTsEnsembleTs ( const string & dataId , const TimeSeriesSourceInfo & t ) function GetFullPath \u00b6 boost :: filesystem :: path GetFullPath ( const string & relativePath ) const function GetRootDirectory \u00b6 string GetRootDirectory () const function GetDataIdSingle \u00b6 vector < string > GetDataIdSingle () const function GetDataIdEnsembleTs \u00b6 vector < string > GetDataIdEnsembleTs () const function GetDataIdTsEnsembleTs \u00b6 vector < string > GetDataIdTsEnsembleTs () const function GetSerializableConfiguration \u00b6 std :: map < string , string > GetSerializableConfiguration ( const string & dataId , const vector < string > & mandatoryKeys = vector < string > ({}) ) const function SetLoadedFileName \u00b6 void SetLoadedFileName ( const string & fileName ) function SetDataPath \u00b6 void SetDataPath ( const string & dataPath ) function GetDataPath \u00b6 string GetDataPath () const function CreateSingleTimeSeriesStore \u00b6 SingleTimeSeriesStore < double > * CreateSingleTimeSeriesStore ( const string & dataId ) const function CreateEnsembleTimeSeriesStore \u00b6 EnsembleTimeSeriesStore < double > * CreateEnsembleTimeSeriesStore ( const string & dataId ) const function CreateTimeSeriesEnsembleTimeSeriesStore \u00b6 TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ) const Friends \u00b6 friend TimeSeriesLibrary \u00b6 friend class TimeSeriesLibrary ( TimeSeriesLibrary ); Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::TimeSeriesLibraryDescription"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryDescription/#datatypestimeseriestimeserieslibrarydescription","text":"#include <time_series_store.hpp>","title":"datatypes::timeseries::TimeSeriesLibraryDescription"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryDescription/#public-functions","text":"Name void AddSingle (const string & dataId, const TimeSeriesSourceInfo & t) void AddEnsembleTs (const string & dataId, const TimeSeriesSourceInfo & t) void AddTsEnsembleTs (const string & dataId, const TimeSeriesSourceInfo & t) boost::filesystem::path GetFullPath (const string & relativePath) const string GetRootDirectory () const vector< string > GetDataIdSingle () const vector< string > GetDataIdEnsembleTs () const vector< string > GetDataIdTsEnsembleTs () const std::map< string, string > GetSerializableConfiguration (const string & dataId, const vector< string > & mandatoryKeys =vector< string >({})) const void SetLoadedFileName (const string & fileName) void SetDataPath (const string & dataPath) string GetDataPath () const SingleTimeSeriesStore < double > * CreateSingleTimeSeriesStore (const string & dataId) const EnsembleTimeSeriesStore < double > * CreateEnsembleTimeSeriesStore (const string & dataId) const TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore (const string & dataId) const","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryDescription/#friends","text":"Name class TimeSeriesLibrary","title":"Friends"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryDescription/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryDescription/#function-addsingle","text":"void AddSingle ( const string & dataId , const TimeSeriesSourceInfo & t )","title":"function AddSingle"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryDescription/#function-addensemblets","text":"void AddEnsembleTs ( const string & dataId , const TimeSeriesSourceInfo & t )","title":"function AddEnsembleTs"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryDescription/#function-addtsensemblets","text":"void AddTsEnsembleTs ( const string & dataId , const TimeSeriesSourceInfo & t )","title":"function AddTsEnsembleTs"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryDescription/#function-getfullpath","text":"boost :: filesystem :: path GetFullPath ( const string & relativePath ) const","title":"function GetFullPath"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryDescription/#function-getrootdirectory","text":"string GetRootDirectory () const","title":"function GetRootDirectory"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryDescription/#function-getdataidsingle","text":"vector < string > GetDataIdSingle () const","title":"function GetDataIdSingle"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryDescription/#function-getdataidensemblets","text":"vector < string > GetDataIdEnsembleTs () const","title":"function GetDataIdEnsembleTs"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryDescription/#function-getdataidtsensemblets","text":"vector < string > GetDataIdTsEnsembleTs () const","title":"function GetDataIdTsEnsembleTs"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryDescription/#function-getserializableconfiguration","text":"std :: map < string , string > GetSerializableConfiguration ( const string & dataId , const vector < string > & mandatoryKeys = vector < string > ({}) ) const","title":"function GetSerializableConfiguration"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryDescription/#function-setloadedfilename","text":"void SetLoadedFileName ( const string & fileName )","title":"function SetLoadedFileName"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryDescription/#function-setdatapath","text":"void SetDataPath ( const string & dataPath )","title":"function SetDataPath"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryDescription/#function-getdatapath","text":"string GetDataPath () const","title":"function GetDataPath"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryDescription/#function-createsingletimeseriesstore","text":"SingleTimeSeriesStore < double > * CreateSingleTimeSeriesStore ( const string & dataId ) const","title":"function CreateSingleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryDescription/#function-createensembletimeseriesstore","text":"EnsembleTimeSeriesStore < double > * CreateEnsembleTimeSeriesStore ( const string & dataId ) const","title":"function CreateEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryDescription/#function-createtimeseriesensembletimeseriesstore","text":"TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ) const","title":"function CreateTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryDescription/#friends_1","text":"","title":"Friends"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryDescription/#friend-timeserieslibrary","text":"friend class TimeSeriesLibrary ( TimeSeriesLibrary ); Updated on 2022-08-20 at 19:28:22 +1000","title":"friend TimeSeriesLibrary"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/","text":"datatypes::timeseries::TimeSeriesLibraryFactory \u00b6 #include <time_series_io.hpp> Public Types \u00b6 Name using TTimeSeries < double > * PtrSeriesType using TTimeSeries < double > SeriesType Public Functions \u00b6 Name TimeSeriesLibrary CreateLibrary (const TimeSeriesLibraryDescription & description) TimeSeriesLibrary * CreateLibraryPtr (const TimeSeriesLibraryDescription & description) TimeSeriesLibrary LoadTimeSeriesLibrary (const string & filepath, const string & dataPath =\"\") TimeSeriesLibrary * LoadTimeSeriesLibraryPtr (const string & filepath, const string & dataPath =\"\") TimeSeriesLibrary * CreateTimeSeriesLibraryPtr (const string & type) SingleTimeSeriesStore < double > * CreateTsSource (const string & ncFilename, const string & ncVarName, const string & ncIdentifier) EnsembleTimeSeriesStore < double > * CreateEnsTsSource (const string & ncFilename, const string & ncVarName, const string & ncIdentifier) TimeSeriesEnsembleTimeSeriesStore < double > * CreateTsEnsTsSource (const string & ncFilename, const string & ncVarName, const string & ncIdentifier) EnsembleForecastTimeSeries < SeriesType > * LoadTsEnsTs (const string & ncFilename, const string & ncVarName, const string & ncIdentifier, const string & dataId) TimeSeriesSourceInfo CreateNetcdfSourceInfo (const string & dataId, const string & storageType, const string & ncFilename, const string & ncVarName, const string & ncIdentifier) TimeSeriesSourceInfo CreateNetcdfSourceInfo (const string & dataId, const string & storageType, const string & ncFilename, const string & ncVarName, const string & ncIdentifier, int index, const string & timeStep, const string & start, int length, int ensembleSize) TimeSeriesSourceInfo CreateNetcdfSourceInfo (const string & dataId, const string & storageType, const string & ncFilename, const string & ncVarName, const string & ncIdentifier, int index, const string & timeStep, const string & start, int length, int ensembleSize, int ensembleLength, const string & ensembleTimeStep) bool HasTimeSeriesSourceInfoBuilderRegistered () void RegisterTimeSeriesSourceInfoBuilder ( TimeSeriesSourceInfoBuilder * srcBuilder) Public Attributes \u00b6 Name const string kTestRecorderKey const string kTimeSeriesEnsemblesKey Public Types Documentation \u00b6 using PtrSeriesType \u00b6 using datatypes :: timeseries :: TimeSeriesLibraryFactory :: PtrSeriesType = TTimeSeries < double >* ; using SeriesType \u00b6 using datatypes :: timeseries :: TimeSeriesLibraryFactory :: SeriesType = TTimeSeries < double > ; Public Functions Documentation \u00b6 function CreateLibrary \u00b6 static TimeSeriesLibrary CreateLibrary ( const TimeSeriesLibraryDescription & description ) function CreateLibraryPtr \u00b6 static TimeSeriesLibrary * CreateLibraryPtr ( const TimeSeriesLibraryDescription & description ) function LoadTimeSeriesLibrary \u00b6 static TimeSeriesLibrary LoadTimeSeriesLibrary ( const string & filepath , const string & dataPath = \"\" ) function LoadTimeSeriesLibraryPtr \u00b6 static TimeSeriesLibrary * LoadTimeSeriesLibraryPtr ( const string & filepath , const string & dataPath = \"\" ) function CreateTimeSeriesLibraryPtr \u00b6 static TimeSeriesLibrary * CreateTimeSeriesLibraryPtr ( const string & type ) function CreateTsSource \u00b6 static SingleTimeSeriesStore < double > * CreateTsSource ( const string & ncFilename , const string & ncVarName , const string & ncIdentifier ) function CreateEnsTsSource \u00b6 static EnsembleTimeSeriesStore < double > * CreateEnsTsSource ( const string & ncFilename , const string & ncVarName , const string & ncIdentifier ) function CreateTsEnsTsSource \u00b6 static TimeSeriesEnsembleTimeSeriesStore < double > * CreateTsEnsTsSource ( const string & ncFilename , const string & ncVarName , const string & ncIdentifier ) function LoadTsEnsTs \u00b6 static EnsembleForecastTimeSeries < SeriesType > * LoadTsEnsTs ( const string & ncFilename , const string & ncVarName , const string & ncIdentifier , const string & dataId ) function CreateNetcdfSourceInfo \u00b6 static TimeSeriesSourceInfo CreateNetcdfSourceInfo ( const string & dataId , const string & storageType , const string & ncFilename , const string & ncVarName , const string & ncIdentifier ) function CreateNetcdfSourceInfo \u00b6 static TimeSeriesSourceInfo CreateNetcdfSourceInfo ( const string & dataId , const string & storageType , const string & ncFilename , const string & ncVarName , const string & ncIdentifier , int index , const string & timeStep , const string & start , int length , int ensembleSize ) function CreateNetcdfSourceInfo \u00b6 static TimeSeriesSourceInfo CreateNetcdfSourceInfo ( const string & dataId , const string & storageType , const string & ncFilename , const string & ncVarName , const string & ncIdentifier , int index , const string & timeStep , const string & start , int length , int ensembleSize , int ensembleLength , const string & ensembleTimeStep ) function HasTimeSeriesSourceInfoBuilderRegistered \u00b6 static bool HasTimeSeriesSourceInfoBuilderRegistered () function RegisterTimeSeriesSourceInfoBuilder \u00b6 static void RegisterTimeSeriesSourceInfoBuilder ( TimeSeriesSourceInfoBuilder * srcBuilder ) Public Attributes Documentation \u00b6 variable kTestRecorderKey \u00b6 static const string kTestRecorderKey ; variable kTimeSeriesEnsemblesKey \u00b6 static const string kTimeSeriesEnsemblesKey ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::TimeSeriesLibraryFactory"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#datatypestimeseriestimeserieslibraryfactory","text":"#include <time_series_io.hpp>","title":"datatypes::timeseries::TimeSeriesLibraryFactory"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#public-types","text":"Name using TTimeSeries < double > * PtrSeriesType using TTimeSeries < double > SeriesType","title":"Public Types"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#public-functions","text":"Name TimeSeriesLibrary CreateLibrary (const TimeSeriesLibraryDescription & description) TimeSeriesLibrary * CreateLibraryPtr (const TimeSeriesLibraryDescription & description) TimeSeriesLibrary LoadTimeSeriesLibrary (const string & filepath, const string & dataPath =\"\") TimeSeriesLibrary * LoadTimeSeriesLibraryPtr (const string & filepath, const string & dataPath =\"\") TimeSeriesLibrary * CreateTimeSeriesLibraryPtr (const string & type) SingleTimeSeriesStore < double > * CreateTsSource (const string & ncFilename, const string & ncVarName, const string & ncIdentifier) EnsembleTimeSeriesStore < double > * CreateEnsTsSource (const string & ncFilename, const string & ncVarName, const string & ncIdentifier) TimeSeriesEnsembleTimeSeriesStore < double > * CreateTsEnsTsSource (const string & ncFilename, const string & ncVarName, const string & ncIdentifier) EnsembleForecastTimeSeries < SeriesType > * LoadTsEnsTs (const string & ncFilename, const string & ncVarName, const string & ncIdentifier, const string & dataId) TimeSeriesSourceInfo CreateNetcdfSourceInfo (const string & dataId, const string & storageType, const string & ncFilename, const string & ncVarName, const string & ncIdentifier) TimeSeriesSourceInfo CreateNetcdfSourceInfo (const string & dataId, const string & storageType, const string & ncFilename, const string & ncVarName, const string & ncIdentifier, int index, const string & timeStep, const string & start, int length, int ensembleSize) TimeSeriesSourceInfo CreateNetcdfSourceInfo (const string & dataId, const string & storageType, const string & ncFilename, const string & ncVarName, const string & ncIdentifier, int index, const string & timeStep, const string & start, int length, int ensembleSize, int ensembleLength, const string & ensembleTimeStep) bool HasTimeSeriesSourceInfoBuilderRegistered () void RegisterTimeSeriesSourceInfoBuilder ( TimeSeriesSourceInfoBuilder * srcBuilder)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#public-attributes","text":"Name const string kTestRecorderKey const string kTimeSeriesEnsemblesKey","title":"Public Attributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#using-ptrseriestype","text":"using datatypes :: timeseries :: TimeSeriesLibraryFactory :: PtrSeriesType = TTimeSeries < double >* ;","title":"using PtrSeriesType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#using-seriestype","text":"using datatypes :: timeseries :: TimeSeriesLibraryFactory :: SeriesType = TTimeSeries < double > ;","title":"using SeriesType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#function-createlibrary","text":"static TimeSeriesLibrary CreateLibrary ( const TimeSeriesLibraryDescription & description )","title":"function CreateLibrary"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#function-createlibraryptr","text":"static TimeSeriesLibrary * CreateLibraryPtr ( const TimeSeriesLibraryDescription & description )","title":"function CreateLibraryPtr"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#function-loadtimeserieslibrary","text":"static TimeSeriesLibrary LoadTimeSeriesLibrary ( const string & filepath , const string & dataPath = \"\" )","title":"function LoadTimeSeriesLibrary"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#function-loadtimeserieslibraryptr","text":"static TimeSeriesLibrary * LoadTimeSeriesLibraryPtr ( const string & filepath , const string & dataPath = \"\" )","title":"function LoadTimeSeriesLibraryPtr"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#function-createtimeserieslibraryptr","text":"static TimeSeriesLibrary * CreateTimeSeriesLibraryPtr ( const string & type )","title":"function CreateTimeSeriesLibraryPtr"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#function-createtssource","text":"static SingleTimeSeriesStore < double > * CreateTsSource ( const string & ncFilename , const string & ncVarName , const string & ncIdentifier )","title":"function CreateTsSource"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#function-createenstssource","text":"static EnsembleTimeSeriesStore < double > * CreateEnsTsSource ( const string & ncFilename , const string & ncVarName , const string & ncIdentifier )","title":"function CreateEnsTsSource"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#function-createtsenstssource","text":"static TimeSeriesEnsembleTimeSeriesStore < double > * CreateTsEnsTsSource ( const string & ncFilename , const string & ncVarName , const string & ncIdentifier )","title":"function CreateTsEnsTsSource"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#function-loadtsensts","text":"static EnsembleForecastTimeSeries < SeriesType > * LoadTsEnsTs ( const string & ncFilename , const string & ncVarName , const string & ncIdentifier , const string & dataId )","title":"function LoadTsEnsTs"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#function-createnetcdfsourceinfo","text":"static TimeSeriesSourceInfo CreateNetcdfSourceInfo ( const string & dataId , const string & storageType , const string & ncFilename , const string & ncVarName , const string & ncIdentifier )","title":"function CreateNetcdfSourceInfo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#function-createnetcdfsourceinfo_1","text":"static TimeSeriesSourceInfo CreateNetcdfSourceInfo ( const string & dataId , const string & storageType , const string & ncFilename , const string & ncVarName , const string & ncIdentifier , int index , const string & timeStep , const string & start , int length , int ensembleSize )","title":"function CreateNetcdfSourceInfo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#function-createnetcdfsourceinfo_2","text":"static TimeSeriesSourceInfo CreateNetcdfSourceInfo ( const string & dataId , const string & storageType , const string & ncFilename , const string & ncVarName , const string & ncIdentifier , int index , const string & timeStep , const string & start , int length , int ensembleSize , int ensembleLength , const string & ensembleTimeStep )","title":"function CreateNetcdfSourceInfo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#function-hastimeseriessourceinfobuilderregistered","text":"static bool HasTimeSeriesSourceInfoBuilderRegistered ()","title":"function HasTimeSeriesSourceInfoBuilderRegistered"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#function-registertimeseriessourceinfobuilder","text":"static void RegisterTimeSeriesSourceInfoBuilder ( TimeSeriesSourceInfoBuilder * srcBuilder )","title":"function RegisterTimeSeriesSourceInfoBuilder"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#variable-ktestrecorderkey","text":"static const string kTestRecorderKey ;","title":"variable kTestRecorderKey"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesLibraryFactory/#variable-ktimeseriesensembleskey","text":"static const string kTimeSeriesEnsemblesKey ; Updated on 2022-08-20 at 19:28:22 +1000","title":"variable kTimeSeriesEnsemblesKey"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/","text":"datatypes::timeseries::TimeSeriesOperations \u00b6 More... #include <time_series.hpp> Public Types \u00b6 Name using typename Tts::ElementType ElementType using typename CommonTypes < ElementType >:: SeriesType SeriesType using typename CommonTypes < ElementType >:: PtrSeriesType PtrSeriesType using typename CommonTypes < ElementType >:: EnsembleType EnsembleType using typename CommonTypes < ElementType >:: EnsemblePtrType EnsemblePtrType using typename CommonTypes < ElementType >:: PtrEnsemblePtrType PtrEnsemblePtrType using typename CommonTypes < ElementType >:: TSeriesEnsemblePtrType TSeriesEnsemblePtrType using typename CommonTypes < ElementType >:: PtrTSeriesEnsemblePtrType PtrTSeriesEnsemblePtrType Public Functions \u00b6 Name PtrSeriesType TrimTimeSeries (const SeriesType & timeSeries, const ptime & startDate, const ptime & endDate) PtrSeriesType Resample (const SeriesType & timeSeries, const string & method) PtrSeriesType DailyToHourly (const SeriesType & dailyTimeSeries) PtrSeriesType JoinTimeSeries (const SeriesType & head, const SeriesType & tail) SeriesType AggregateTimeStep (const SeriesType & series, const string & argument) SeriesType DisaggregateTimeStep (const SeriesType & series, const string & argument) void AggregateTimeStep ( SeriesType & series, const string & argument) void DisaggregateTimeStep ( SeriesType & series, const string & argument) void TransformEachItem ( TSeriesEnsemblePtrType & efts, const string & method, const string & methodArgument) ptime GetStart (const TSeriesEnsemblePtrType & ensTs, size_t index =0) ptime GetEnd (const TSeriesEnsemblePtrType & ensTs, size_t index =0) void CreateForecast ( TSeriesEnsemblePtrType & forecast, const SeriesType & observations, const ptime & start, size_t length, const TimeStep & issueTimeStep, size_t leadTime, size_t offsetForecasts) TSeriesEnsemblePtrType * CreateForecastPtr (const SeriesType & observations, const ptime & start, size_t length, const TimeStep & issueTimeStep, size_t leadTime, size_t offsetForecasts) TSeriesEnsemblePtrType CreateForecast (const SeriesType & observations, const ptime & start, size_t length, const TimeStep & issueTimeStep, size_t leadTime, size_t offsetForecasts) template <typename U > bool AreEqual (const SeriesType & a, const U & b, bool strict =false, double tolerance =1e-12) bool AreTimeSeriesEqual (const SeriesType & a, const SeriesType & b, bool strict =false, double tolerance =1e-12) bool AreTimeSeriesEqual (const SeriesType & a, const SeriesType & b, const ptime & from, const ptime & to, bool strict =false, double tolerance =1e-12) bool AreValueEqual (const SeriesType & a, const vector< ElementType > & b, size_t from =0, size_t to =std::numeric_limits< size_t >::max(), bool strict =false, double tolerance =1e-12) bool AreEnsembleTimeSeriesEqual ( EnsemblePtrType & a, EnsemblePtrType & b) bool AreEnsembleTimeSeriesEqual ( EnsembleType & a, EnsembleType & b) bool AreTimeSeriesEnsembleTimeSeriesEqual ( TSeriesEnsemblePtrType & a, TSeriesEnsemblePtrType & b) template <typename T =typename Tts::ElementType> PtrSeriesType MaskTimeSeries (const SeriesType & timeSeries, const ptime & start, const ptime & end, T maskValue) Detailed Description \u00b6 template < typename Tts = TimeSeries > class datatypes :: timeseries :: TimeSeriesOperations ; Public Types Documentation \u00b6 using ElementType \u00b6 using datatypes :: timeseries :: TimeSeriesOperations < Tts >:: ElementType = typename Tts :: ElementType ; using SeriesType \u00b6 using datatypes :: timeseries :: TimeSeriesOperations < Tts >:: SeriesType = typename CommonTypes < ElementType >:: SeriesType ; using PtrSeriesType \u00b6 using datatypes :: timeseries :: TimeSeriesOperations < Tts >:: PtrSeriesType = typename CommonTypes < ElementType >:: PtrSeriesType ; using EnsembleType \u00b6 using datatypes :: timeseries :: TimeSeriesOperations < Tts >:: EnsembleType = typename CommonTypes < ElementType >:: EnsembleType ; using EnsemblePtrType \u00b6 using datatypes :: timeseries :: TimeSeriesOperations < Tts >:: EnsemblePtrType = typename CommonTypes < ElementType >:: EnsemblePtrType ; using PtrEnsemblePtrType \u00b6 using datatypes :: timeseries :: TimeSeriesOperations < Tts >:: PtrEnsemblePtrType = typename CommonTypes < ElementType >:: PtrEnsemblePtrType ; using TSeriesEnsemblePtrType \u00b6 using datatypes :: timeseries :: TimeSeriesOperations < Tts >:: TSeriesEnsemblePtrType = typename CommonTypes < ElementType >:: TSeriesEnsemblePtrType ; using PtrTSeriesEnsemblePtrType \u00b6 using datatypes :: timeseries :: TimeSeriesOperations < Tts >:: PtrTSeriesEnsemblePtrType = typename CommonTypes < ElementType >:: PtrTSeriesEnsemblePtrType ; Public Functions Documentation \u00b6 function TrimTimeSeries \u00b6 static inline PtrSeriesType TrimTimeSeries ( const SeriesType & timeSeries , const ptime & startDate , const ptime & endDate ) function Resample \u00b6 static inline PtrSeriesType Resample ( const SeriesType & timeSeries , const string & method ) function DailyToHourly \u00b6 static inline PtrSeriesType DailyToHourly ( const SeriesType & dailyTimeSeries ) function JoinTimeSeries \u00b6 static inline PtrSeriesType JoinTimeSeries ( const SeriesType & head , const SeriesType & tail ) function AggregateTimeStep \u00b6 static inline SeriesType AggregateTimeStep ( const SeriesType & series , const string & argument ) function DisaggregateTimeStep \u00b6 static inline SeriesType DisaggregateTimeStep ( const SeriesType & series , const string & argument ) function AggregateTimeStep \u00b6 static inline void AggregateTimeStep ( SeriesType & series , const string & argument ) function DisaggregateTimeStep \u00b6 static inline void DisaggregateTimeStep ( SeriesType & series , const string & argument ) function TransformEachItem \u00b6 static inline void TransformEachItem ( TSeriesEnsemblePtrType & efts , const string & method , const string & methodArgument ) function GetStart \u00b6 static inline ptime GetStart ( const TSeriesEnsemblePtrType & ensTs , size_t index = 0 ) function GetEnd \u00b6 static inline ptime GetEnd ( const TSeriesEnsemblePtrType & ensTs , size_t index = 0 ) function CreateForecast \u00b6 static inline void CreateForecast ( TSeriesEnsemblePtrType & forecast , const SeriesType & observations , const ptime & start , size_t length , const TimeStep & issueTimeStep , size_t leadTime , size_t offsetForecasts ) function CreateForecastPtr \u00b6 static inline TSeriesEnsemblePtrType * CreateForecastPtr ( const SeriesType & observations , const ptime & start , size_t length , const TimeStep & issueTimeStep , size_t leadTime , size_t offsetForecasts ) function CreateForecast \u00b6 static inline TSeriesEnsemblePtrType CreateForecast ( const SeriesType & observations , const ptime & start , size_t length , const TimeStep & issueTimeStep , size_t leadTime , size_t offsetForecasts ) function AreEqual \u00b6 template < typename U > static inline bool AreEqual ( const SeriesType & a , const U & b , bool strict = false , double tolerance = 1e-12 ) function AreTimeSeriesEqual \u00b6 static inline bool AreTimeSeriesEqual ( const SeriesType & a , const SeriesType & b , bool strict = false , double tolerance = 1e-12 ) function AreTimeSeriesEqual \u00b6 static inline bool AreTimeSeriesEqual ( const SeriesType & a , const SeriesType & b , const ptime & from , const ptime & to , bool strict = false , double tolerance = 1e-12 ) function AreValueEqual \u00b6 static inline bool AreValueEqual ( const SeriesType & a , const vector < ElementType > & b , size_t from = 0 , size_t to = std :: numeric_limits < size_t >:: max (), bool strict = false , double tolerance = 1e-12 ) function AreEnsembleTimeSeriesEqual \u00b6 static inline bool AreEnsembleTimeSeriesEqual ( EnsemblePtrType & a , EnsemblePtrType & b ) function AreEnsembleTimeSeriesEqual \u00b6 static inline bool AreEnsembleTimeSeriesEqual ( EnsembleType & a , EnsembleType & b ) function AreTimeSeriesEnsembleTimeSeriesEqual \u00b6 static inline bool AreTimeSeriesEnsembleTimeSeriesEqual ( TSeriesEnsemblePtrType & a , TSeriesEnsemblePtrType & b ) function MaskTimeSeries \u00b6 template < typename T = typename Tts :: ElementType > static inline PtrSeriesType MaskTimeSeries ( const SeriesType & timeSeries , const ptime & start , const ptime & end , T maskValue ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::TimeSeriesOperations"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#datatypestimeseriestimeseriesoperations","text":"More... #include <time_series.hpp>","title":"datatypes::timeseries::TimeSeriesOperations"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#public-types","text":"Name using typename Tts::ElementType ElementType using typename CommonTypes < ElementType >:: SeriesType SeriesType using typename CommonTypes < ElementType >:: PtrSeriesType PtrSeriesType using typename CommonTypes < ElementType >:: EnsembleType EnsembleType using typename CommonTypes < ElementType >:: EnsemblePtrType EnsemblePtrType using typename CommonTypes < ElementType >:: PtrEnsemblePtrType PtrEnsemblePtrType using typename CommonTypes < ElementType >:: TSeriesEnsemblePtrType TSeriesEnsemblePtrType using typename CommonTypes < ElementType >:: PtrTSeriesEnsemblePtrType PtrTSeriesEnsemblePtrType","title":"Public Types"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#public-functions","text":"Name PtrSeriesType TrimTimeSeries (const SeriesType & timeSeries, const ptime & startDate, const ptime & endDate) PtrSeriesType Resample (const SeriesType & timeSeries, const string & method) PtrSeriesType DailyToHourly (const SeriesType & dailyTimeSeries) PtrSeriesType JoinTimeSeries (const SeriesType & head, const SeriesType & tail) SeriesType AggregateTimeStep (const SeriesType & series, const string & argument) SeriesType DisaggregateTimeStep (const SeriesType & series, const string & argument) void AggregateTimeStep ( SeriesType & series, const string & argument) void DisaggregateTimeStep ( SeriesType & series, const string & argument) void TransformEachItem ( TSeriesEnsemblePtrType & efts, const string & method, const string & methodArgument) ptime GetStart (const TSeriesEnsemblePtrType & ensTs, size_t index =0) ptime GetEnd (const TSeriesEnsemblePtrType & ensTs, size_t index =0) void CreateForecast ( TSeriesEnsemblePtrType & forecast, const SeriesType & observations, const ptime & start, size_t length, const TimeStep & issueTimeStep, size_t leadTime, size_t offsetForecasts) TSeriesEnsemblePtrType * CreateForecastPtr (const SeriesType & observations, const ptime & start, size_t length, const TimeStep & issueTimeStep, size_t leadTime, size_t offsetForecasts) TSeriesEnsemblePtrType CreateForecast (const SeriesType & observations, const ptime & start, size_t length, const TimeStep & issueTimeStep, size_t leadTime, size_t offsetForecasts) template <typename U > bool AreEqual (const SeriesType & a, const U & b, bool strict =false, double tolerance =1e-12) bool AreTimeSeriesEqual (const SeriesType & a, const SeriesType & b, bool strict =false, double tolerance =1e-12) bool AreTimeSeriesEqual (const SeriesType & a, const SeriesType & b, const ptime & from, const ptime & to, bool strict =false, double tolerance =1e-12) bool AreValueEqual (const SeriesType & a, const vector< ElementType > & b, size_t from =0, size_t to =std::numeric_limits< size_t >::max(), bool strict =false, double tolerance =1e-12) bool AreEnsembleTimeSeriesEqual ( EnsemblePtrType & a, EnsemblePtrType & b) bool AreEnsembleTimeSeriesEqual ( EnsembleType & a, EnsembleType & b) bool AreTimeSeriesEnsembleTimeSeriesEqual ( TSeriesEnsemblePtrType & a, TSeriesEnsemblePtrType & b) template <typename T =typename Tts::ElementType> PtrSeriesType MaskTimeSeries (const SeriesType & timeSeries, const ptime & start, const ptime & end, T maskValue)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#detailed-description","text":"template < typename Tts = TimeSeries > class datatypes :: timeseries :: TimeSeriesOperations ;","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#using-elementtype","text":"using datatypes :: timeseries :: TimeSeriesOperations < Tts >:: ElementType = typename Tts :: ElementType ;","title":"using ElementType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#using-seriestype","text":"using datatypes :: timeseries :: TimeSeriesOperations < Tts >:: SeriesType = typename CommonTypes < ElementType >:: SeriesType ;","title":"using SeriesType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#using-ptrseriestype","text":"using datatypes :: timeseries :: TimeSeriesOperations < Tts >:: PtrSeriesType = typename CommonTypes < ElementType >:: PtrSeriesType ;","title":"using PtrSeriesType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#using-ensembletype","text":"using datatypes :: timeseries :: TimeSeriesOperations < Tts >:: EnsembleType = typename CommonTypes < ElementType >:: EnsembleType ;","title":"using EnsembleType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#using-ensembleptrtype","text":"using datatypes :: timeseries :: TimeSeriesOperations < Tts >:: EnsemblePtrType = typename CommonTypes < ElementType >:: EnsemblePtrType ;","title":"using EnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#using-ptrensembleptrtype","text":"using datatypes :: timeseries :: TimeSeriesOperations < Tts >:: PtrEnsemblePtrType = typename CommonTypes < ElementType >:: PtrEnsemblePtrType ;","title":"using PtrEnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#using-tseriesensembleptrtype","text":"using datatypes :: timeseries :: TimeSeriesOperations < Tts >:: TSeriesEnsemblePtrType = typename CommonTypes < ElementType >:: TSeriesEnsemblePtrType ;","title":"using TSeriesEnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#using-ptrtseriesensembleptrtype","text":"using datatypes :: timeseries :: TimeSeriesOperations < Tts >:: PtrTSeriesEnsemblePtrType = typename CommonTypes < ElementType >:: PtrTSeriesEnsemblePtrType ;","title":"using PtrTSeriesEnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#function-trimtimeseries","text":"static inline PtrSeriesType TrimTimeSeries ( const SeriesType & timeSeries , const ptime & startDate , const ptime & endDate )","title":"function TrimTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#function-resample","text":"static inline PtrSeriesType Resample ( const SeriesType & timeSeries , const string & method )","title":"function Resample"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#function-dailytohourly","text":"static inline PtrSeriesType DailyToHourly ( const SeriesType & dailyTimeSeries )","title":"function DailyToHourly"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#function-jointimeseries","text":"static inline PtrSeriesType JoinTimeSeries ( const SeriesType & head , const SeriesType & tail )","title":"function JoinTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#function-aggregatetimestep","text":"static inline SeriesType AggregateTimeStep ( const SeriesType & series , const string & argument )","title":"function AggregateTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#function-disaggregatetimestep","text":"static inline SeriesType DisaggregateTimeStep ( const SeriesType & series , const string & argument )","title":"function DisaggregateTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#function-aggregatetimestep_1","text":"static inline void AggregateTimeStep ( SeriesType & series , const string & argument )","title":"function AggregateTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#function-disaggregatetimestep_1","text":"static inline void DisaggregateTimeStep ( SeriesType & series , const string & argument )","title":"function DisaggregateTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#function-transformeachitem","text":"static inline void TransformEachItem ( TSeriesEnsemblePtrType & efts , const string & method , const string & methodArgument )","title":"function TransformEachItem"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#function-getstart","text":"static inline ptime GetStart ( const TSeriesEnsemblePtrType & ensTs , size_t index = 0 )","title":"function GetStart"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#function-getend","text":"static inline ptime GetEnd ( const TSeriesEnsemblePtrType & ensTs , size_t index = 0 )","title":"function GetEnd"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#function-createforecast","text":"static inline void CreateForecast ( TSeriesEnsemblePtrType & forecast , const SeriesType & observations , const ptime & start , size_t length , const TimeStep & issueTimeStep , size_t leadTime , size_t offsetForecasts )","title":"function CreateForecast"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#function-createforecastptr","text":"static inline TSeriesEnsemblePtrType * CreateForecastPtr ( const SeriesType & observations , const ptime & start , size_t length , const TimeStep & issueTimeStep , size_t leadTime , size_t offsetForecasts )","title":"function CreateForecastPtr"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#function-createforecast_1","text":"static inline TSeriesEnsemblePtrType CreateForecast ( const SeriesType & observations , const ptime & start , size_t length , const TimeStep & issueTimeStep , size_t leadTime , size_t offsetForecasts )","title":"function CreateForecast"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#function-areequal","text":"template < typename U > static inline bool AreEqual ( const SeriesType & a , const U & b , bool strict = false , double tolerance = 1e-12 )","title":"function AreEqual"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#function-aretimeseriesequal","text":"static inline bool AreTimeSeriesEqual ( const SeriesType & a , const SeriesType & b , bool strict = false , double tolerance = 1e-12 )","title":"function AreTimeSeriesEqual"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#function-aretimeseriesequal_1","text":"static inline bool AreTimeSeriesEqual ( const SeriesType & a , const SeriesType & b , const ptime & from , const ptime & to , bool strict = false , double tolerance = 1e-12 )","title":"function AreTimeSeriesEqual"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#function-arevalueequal","text":"static inline bool AreValueEqual ( const SeriesType & a , const vector < ElementType > & b , size_t from = 0 , size_t to = std :: numeric_limits < size_t >:: max (), bool strict = false , double tolerance = 1e-12 )","title":"function AreValueEqual"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#function-areensembletimeseriesequal","text":"static inline bool AreEnsembleTimeSeriesEqual ( EnsemblePtrType & a , EnsemblePtrType & b )","title":"function AreEnsembleTimeSeriesEqual"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#function-areensembletimeseriesequal_1","text":"static inline bool AreEnsembleTimeSeriesEqual ( EnsembleType & a , EnsembleType & b )","title":"function AreEnsembleTimeSeriesEqual"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#function-aretimeseriesensembletimeseriesequal","text":"static inline bool AreTimeSeriesEnsembleTimeSeriesEqual ( TSeriesEnsemblePtrType & a , TSeriesEnsemblePtrType & b )","title":"function AreTimeSeriesEnsembleTimeSeriesEqual"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesOperations/#function-masktimeseries","text":"template < typename T = typename Tts :: ElementType > static inline PtrSeriesType MaskTimeSeries ( const SeriesType & timeSeries , const ptime & start , const ptime & end , T maskValue ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function MaskTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesProvider/","text":"datatypes::timeseries::TimeSeriesProvider \u00b6 Library of time series, for high level access to sources of univariate, single instance time series that may have varying on-disk representations. More... #include <time_series_store.hpp> Inherits from datatypes::timeseries::IdentifiersProvider Public Functions \u00b6 Name virtual ~TimeSeriesProvider () virtual TTimeSeries < T > * GetSingle (const string & dataId) =0 Gets a single time series out of the library. Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () virtual vector< string > GetIdentifiers () const =0 vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId) Detailed Description \u00b6 template < typename T > class datatypes :: timeseries :: TimeSeriesProvider ; Library of time series, for high level access to sources of univariate, single instance time series that may have varying on-disk representations. Template Parameters : T The element type of the time series dealt with, typically double or float. Public Functions Documentation \u00b6 function ~TimeSeriesProvider \u00b6 inline virtual ~ TimeSeriesProvider () function GetSingle \u00b6 virtual TTimeSeries < T > * GetSingle ( const string & dataId ) = 0 Gets a single time series out of the library. Parameters : dataId Identifier for the time series Return : The univariate, single realization time series Reimplemented by : datatypes::timeseries::TimeSeriesLibrary::GetSingle Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::TimeSeriesProvider"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesProvider/#datatypestimeseriestimeseriesprovider","text":"Library of time series, for high level access to sources of univariate, single instance time series that may have varying on-disk representations. More... #include <time_series_store.hpp> Inherits from datatypes::timeseries::IdentifiersProvider","title":"datatypes::timeseries::TimeSeriesProvider"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesProvider/#public-functions","text":"Name virtual ~TimeSeriesProvider () virtual TTimeSeries < T > * GetSingle (const string & dataId) =0 Gets a single time series out of the library.","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesProvider/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () virtual vector< string > GetIdentifiers () const =0 vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId)","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesProvider/#detailed-description","text":"template < typename T > class datatypes :: timeseries :: TimeSeriesProvider ; Library of time series, for high level access to sources of univariate, single instance time series that may have varying on-disk representations. Template Parameters : T The element type of the time series dealt with, typically double or float.","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesProvider/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesProvider/#function-timeseriesprovider","text":"inline virtual ~ TimeSeriesProvider ()","title":"function ~TimeSeriesProvider"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesProvider/#function-getsingle","text":"virtual TTimeSeries < T > * GetSingle ( const string & dataId ) = 0 Gets a single time series out of the library. Parameters : dataId Identifier for the time series Return : The univariate, single realization time series Reimplemented by : datatypes::timeseries::TimeSeriesLibrary::GetSingle Updated on 2022-08-20 at 19:28:22 +1000","title":"function GetSingle"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfo/","text":"datatypes::timeseries::TimeSeriesSourceInfo \u00b6 #include <time_series_store.hpp> Public Functions \u00b6 Name TimeSeriesSourceInfo (const TimeSeriesSourceInfoImpl & t) TimeSeriesSourceInfo (const TimeSeriesSourceInfo & src) TimeSeriesSourceInfo () virtual ~TimeSeriesSourceInfo () TimeSeriesSourceInfo ( TimeSeriesSourceInfo && src) TimeSeriesSourceInfo & operator= (const TimeSeriesSourceInfo & src) TimeSeriesSourceInfo & operator= ( TimeSeriesSourceInfo && src) SingleTimeSeriesStore < double > * CreateSingleTimeSeriesStore () const EnsembleTimeSeriesStore < double > * CreateEnsembleTimeSeriesStore () const TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore () const bool ApplyRootDir (const string & rootDir) std::map< string, string > GetSerializableConfiguration () const Public Attributes \u00b6 Name const string IdDataKey const string SingleSeriesTypeId const string EnsembleSeriesTypeId const string TimeSeriesEnsemblesTypeId const string SingleSeriesCollectionTypeId Public Functions Documentation \u00b6 function TimeSeriesSourceInfo \u00b6 TimeSeriesSourceInfo ( const TimeSeriesSourceInfoImpl & t ) function TimeSeriesSourceInfo \u00b6 TimeSeriesSourceInfo ( const TimeSeriesSourceInfo & src ) function TimeSeriesSourceInfo \u00b6 TimeSeriesSourceInfo () function ~TimeSeriesSourceInfo \u00b6 virtual ~ TimeSeriesSourceInfo () function TimeSeriesSourceInfo \u00b6 TimeSeriesSourceInfo ( TimeSeriesSourceInfo && src ) function operator= \u00b6 TimeSeriesSourceInfo & operator = ( const TimeSeriesSourceInfo & src ) function operator= \u00b6 TimeSeriesSourceInfo & operator = ( TimeSeriesSourceInfo && src ) function CreateSingleTimeSeriesStore \u00b6 SingleTimeSeriesStore < double > * CreateSingleTimeSeriesStore () const function CreateEnsembleTimeSeriesStore \u00b6 EnsembleTimeSeriesStore < double > * CreateEnsembleTimeSeriesStore () const function CreateTimeSeriesEnsembleTimeSeriesStore \u00b6 TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore () const function ApplyRootDir \u00b6 bool ApplyRootDir ( const string & rootDir ) function GetSerializableConfiguration \u00b6 std :: map < string , string > GetSerializableConfiguration () const Public Attributes Documentation \u00b6 variable IdDataKey \u00b6 static const string IdDataKey ; variable SingleSeriesTypeId \u00b6 static const string SingleSeriesTypeId ; variable EnsembleSeriesTypeId \u00b6 static const string EnsembleSeriesTypeId ; variable TimeSeriesEnsemblesTypeId \u00b6 static const string TimeSeriesEnsemblesTypeId ; variable SingleSeriesCollectionTypeId \u00b6 static const string SingleSeriesCollectionTypeId ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::TimeSeriesSourceInfo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfo/#datatypestimeseriestimeseriessourceinfo","text":"#include <time_series_store.hpp>","title":"datatypes::timeseries::TimeSeriesSourceInfo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfo/#public-functions","text":"Name TimeSeriesSourceInfo (const TimeSeriesSourceInfoImpl & t) TimeSeriesSourceInfo (const TimeSeriesSourceInfo & src) TimeSeriesSourceInfo () virtual ~TimeSeriesSourceInfo () TimeSeriesSourceInfo ( TimeSeriesSourceInfo && src) TimeSeriesSourceInfo & operator= (const TimeSeriesSourceInfo & src) TimeSeriesSourceInfo & operator= ( TimeSeriesSourceInfo && src) SingleTimeSeriesStore < double > * CreateSingleTimeSeriesStore () const EnsembleTimeSeriesStore < double > * CreateEnsembleTimeSeriesStore () const TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore () const bool ApplyRootDir (const string & rootDir) std::map< string, string > GetSerializableConfiguration () const","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfo/#public-attributes","text":"Name const string IdDataKey const string SingleSeriesTypeId const string EnsembleSeriesTypeId const string TimeSeriesEnsemblesTypeId const string SingleSeriesCollectionTypeId","title":"Public Attributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfo/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfo/#function-timeseriessourceinfo","text":"TimeSeriesSourceInfo ( const TimeSeriesSourceInfoImpl & t )","title":"function TimeSeriesSourceInfo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfo/#function-timeseriessourceinfo_1","text":"TimeSeriesSourceInfo ( const TimeSeriesSourceInfo & src )","title":"function TimeSeriesSourceInfo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfo/#function-timeseriessourceinfo_2","text":"TimeSeriesSourceInfo ()","title":"function TimeSeriesSourceInfo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfo/#function-timeseriessourceinfo_3","text":"virtual ~ TimeSeriesSourceInfo ()","title":"function ~TimeSeriesSourceInfo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfo/#function-timeseriessourceinfo_4","text":"TimeSeriesSourceInfo ( TimeSeriesSourceInfo && src )","title":"function TimeSeriesSourceInfo"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfo/#function-operator","text":"TimeSeriesSourceInfo & operator = ( const TimeSeriesSourceInfo & src )","title":"function operator="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfo/#function-operator_1","text":"TimeSeriesSourceInfo & operator = ( TimeSeriesSourceInfo && src )","title":"function operator="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfo/#function-createsingletimeseriesstore","text":"SingleTimeSeriesStore < double > * CreateSingleTimeSeriesStore () const","title":"function CreateSingleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfo/#function-createensembletimeseriesstore","text":"EnsembleTimeSeriesStore < double > * CreateEnsembleTimeSeriesStore () const","title":"function CreateEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfo/#function-createtimeseriesensembletimeseriesstore","text":"TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore () const","title":"function CreateTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfo/#function-applyrootdir","text":"bool ApplyRootDir ( const string & rootDir )","title":"function ApplyRootDir"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfo/#function-getserializableconfiguration","text":"std :: map < string , string > GetSerializableConfiguration () const","title":"function GetSerializableConfiguration"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfo/#variable-iddatakey","text":"static const string IdDataKey ;","title":"variable IdDataKey"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfo/#variable-singleseriestypeid","text":"static const string SingleSeriesTypeId ;","title":"variable SingleSeriesTypeId"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfo/#variable-ensembleseriestypeid","text":"static const string EnsembleSeriesTypeId ;","title":"variable EnsembleSeriesTypeId"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfo/#variable-timeseriesensemblestypeid","text":"static const string TimeSeriesEnsemblesTypeId ;","title":"variable TimeSeriesEnsemblesTypeId"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfo/#variable-singleseriescollectiontypeid","text":"static const string SingleSeriesCollectionTypeId ; Updated on 2022-08-20 at 19:28:22 +1000","title":"variable SingleSeriesCollectionTypeId"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfoBuilder/","text":"datatypes::timeseries::TimeSeriesSourceInfoBuilder \u00b6 An abstract class to allow callers to inject custom time series data sources into a time series library. #include <time_series_store.hpp> Public Functions \u00b6 Name virtual bool HandlesStorageType (const string storageType) const =0 virtual void BuildTimeSeriesSource (const string & storageType, const string & dataId, const YAML::Node & storage, TimeSeriesLibraryDescription & targetContainer) const =0 Public Functions Documentation \u00b6 function HandlesStorageType \u00b6 virtual bool HandlesStorageType ( const string storageType ) const = 0 function BuildTimeSeriesSource \u00b6 virtual void BuildTimeSeriesSource ( const string & storageType , const string & dataId , const YAML :: Node & storage , TimeSeriesLibraryDescription & targetContainer ) const = 0 Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::TimeSeriesSourceInfoBuilder"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfoBuilder/#datatypestimeseriestimeseriessourceinfobuilder","text":"An abstract class to allow callers to inject custom time series data sources into a time series library. #include <time_series_store.hpp>","title":"datatypes::timeseries::TimeSeriesSourceInfoBuilder"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfoBuilder/#public-functions","text":"Name virtual bool HandlesStorageType (const string storageType) const =0 virtual void BuildTimeSeriesSource (const string & storageType, const string & dataId, const YAML::Node & storage, TimeSeriesLibraryDescription & targetContainer) const =0","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfoBuilder/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfoBuilder/#function-handlesstoragetype","text":"virtual bool HandlesStorageType ( const string storageType ) const = 0","title":"function HandlesStorageType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfoBuilder/#function-buildtimeseriessource","text":"virtual void BuildTimeSeriesSource ( const string & storageType , const string & dataId , const YAML :: Node & storage , TimeSeriesLibraryDescription & targetContainer ) const = 0 Updated on 2022-08-20 at 19:28:22 +1000","title":"function BuildTimeSeriesSource"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfoImpl/","text":"datatypes::timeseries::TimeSeriesSourceInfoImpl \u00b6 #include <time_series_store.hpp> Inherited by datatypes::timeseries::NetCdfSourceInfo Public Functions \u00b6 Name virtual ~TimeSeriesSourceInfoImpl () virtual TimeSeriesSourceInfoImpl * Clone () const =0 virtual bool ApplyRootDir (const string & rootDir) virtual SingleTimeSeriesStore < double > * CreateSingleTimeSeriesStore () const virtual EnsembleTimeSeriesStore < double > * CreateEnsembleTimeSeriesStore () const virtual TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore () const virtual std::map< string, string > GetSerializableConfiguration () const string OptionalApplyRootDir (const std::string & rootDir, const std::string & filename, bool checkDirExists =true) Protected Functions \u00b6 Name TimeSeriesSourceInfoImpl () TimeSeriesSourceInfoImpl (const TimeSeriesSourceInfoImpl & src) Public Functions Documentation \u00b6 function ~TimeSeriesSourceInfoImpl \u00b6 virtual ~ TimeSeriesSourceInfoImpl () function Clone \u00b6 virtual TimeSeriesSourceInfoImpl * Clone () const = 0 Reimplemented by : datatypes::timeseries::NetCdfSourceInfo::Clone function ApplyRootDir \u00b6 virtual bool ApplyRootDir ( const string & rootDir ) Reimplemented by : datatypes::timeseries::NetCdfSourceInfo::ApplyRootDir function CreateSingleTimeSeriesStore \u00b6 virtual SingleTimeSeriesStore < double > * CreateSingleTimeSeriesStore () const Reimplemented by : datatypes::timeseries::NetCdfSourceInfo::CreateSingleTimeSeriesStore function CreateEnsembleTimeSeriesStore \u00b6 virtual EnsembleTimeSeriesStore < double > * CreateEnsembleTimeSeriesStore () const Reimplemented by : datatypes::timeseries::NetCdfSourceInfo::CreateEnsembleTimeSeriesStore function CreateTimeSeriesEnsembleTimeSeriesStore \u00b6 virtual TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore () const Reimplemented by : datatypes::timeseries::NetCdfSourceInfo::CreateTimeSeriesEnsembleTimeSeriesStore function GetSerializableConfiguration \u00b6 virtual std :: map < string , string > GetSerializableConfiguration () const Reimplemented by : datatypes::timeseries::NetCdfSourceInfo::GetSerializableConfiguration function OptionalApplyRootDir \u00b6 static string OptionalApplyRootDir ( const std :: string & rootDir , const std :: string & filename , bool checkDirExists = true ) Protected Functions Documentation \u00b6 function TimeSeriesSourceInfoImpl \u00b6 TimeSeriesSourceInfoImpl () function TimeSeriesSourceInfoImpl \u00b6 TimeSeriesSourceInfoImpl ( const TimeSeriesSourceInfoImpl & src ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::TimeSeriesSourceInfoImpl"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfoImpl/#datatypestimeseriestimeseriessourceinfoimpl","text":"#include <time_series_store.hpp> Inherited by datatypes::timeseries::NetCdfSourceInfo","title":"datatypes::timeseries::TimeSeriesSourceInfoImpl"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfoImpl/#public-functions","text":"Name virtual ~TimeSeriesSourceInfoImpl () virtual TimeSeriesSourceInfoImpl * Clone () const =0 virtual bool ApplyRootDir (const string & rootDir) virtual SingleTimeSeriesStore < double > * CreateSingleTimeSeriesStore () const virtual EnsembleTimeSeriesStore < double > * CreateEnsembleTimeSeriesStore () const virtual TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore () const virtual std::map< string, string > GetSerializableConfiguration () const string OptionalApplyRootDir (const std::string & rootDir, const std::string & filename, bool checkDirExists =true)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfoImpl/#protected-functions","text":"Name TimeSeriesSourceInfoImpl () TimeSeriesSourceInfoImpl (const TimeSeriesSourceInfoImpl & src)","title":"Protected Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfoImpl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfoImpl/#function-timeseriessourceinfoimpl","text":"virtual ~ TimeSeriesSourceInfoImpl ()","title":"function ~TimeSeriesSourceInfoImpl"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfoImpl/#function-clone","text":"virtual TimeSeriesSourceInfoImpl * Clone () const = 0 Reimplemented by : datatypes::timeseries::NetCdfSourceInfo::Clone","title":"function Clone"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfoImpl/#function-applyrootdir","text":"virtual bool ApplyRootDir ( const string & rootDir ) Reimplemented by : datatypes::timeseries::NetCdfSourceInfo::ApplyRootDir","title":"function ApplyRootDir"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfoImpl/#function-createsingletimeseriesstore","text":"virtual SingleTimeSeriesStore < double > * CreateSingleTimeSeriesStore () const Reimplemented by : datatypes::timeseries::NetCdfSourceInfo::CreateSingleTimeSeriesStore","title":"function CreateSingleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfoImpl/#function-createensembletimeseriesstore","text":"virtual EnsembleTimeSeriesStore < double > * CreateEnsembleTimeSeriesStore () const Reimplemented by : datatypes::timeseries::NetCdfSourceInfo::CreateEnsembleTimeSeriesStore","title":"function CreateEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfoImpl/#function-createtimeseriesensembletimeseriesstore","text":"virtual TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore () const Reimplemented by : datatypes::timeseries::NetCdfSourceInfo::CreateTimeSeriesEnsembleTimeSeriesStore","title":"function CreateTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfoImpl/#function-getserializableconfiguration","text":"virtual std :: map < string , string > GetSerializableConfiguration () const Reimplemented by : datatypes::timeseries::NetCdfSourceInfo::GetSerializableConfiguration","title":"function GetSerializableConfiguration"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfoImpl/#function-optionalapplyrootdir","text":"static string OptionalApplyRootDir ( const std :: string & rootDir , const std :: string & filename , bool checkDirExists = true )","title":"function OptionalApplyRootDir"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfoImpl/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfoImpl/#function-timeseriessourceinfoimpl_1","text":"TimeSeriesSourceInfoImpl ()","title":"function TimeSeriesSourceInfoImpl"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesSourceInfoImpl/#function-timeseriessourceinfoimpl_2","text":"TimeSeriesSourceInfoImpl ( const TimeSeriesSourceInfoImpl & src ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function TimeSeriesSourceInfoImpl"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesStoreFactory/","text":"datatypes::timeseries::TimeSeriesStoreFactory \u00b6 #include <time_series_store.hpp> Inherited by datatypes::tests::TestTimeSeriesStoreFactory , datatypes::timeseries::SwiftNetcdfStoreFactory Public Functions \u00b6 Name virtual ~TimeSeriesStoreFactory () virtual TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore (const string & dataId) =0 virtual bool CanCreateTimeSeriesEnsembleTimeSeriesStore (const string & dataId) =0 Protected Functions \u00b6 Name TimeSeriesStoreFactory () Public Functions Documentation \u00b6 function ~TimeSeriesStoreFactory \u00b6 virtual ~ TimeSeriesStoreFactory () function CreateTimeSeriesEnsembleTimeSeriesStore \u00b6 virtual TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ) = 0 Reimplemented by : datatypes::tests::TestTimeSeriesStoreFactory::CreateTimeSeriesEnsembleTimeSeriesStore , datatypes::timeseries::SwiftNetcdfStoreFactory::CreateTimeSeriesEnsembleTimeSeriesStore function CanCreateTimeSeriesEnsembleTimeSeriesStore \u00b6 virtual bool CanCreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ) = 0 Reimplemented by : datatypes::tests::TestTimeSeriesStoreFactory::CanCreateTimeSeriesEnsembleTimeSeriesStore , datatypes::timeseries::SwiftNetcdfStoreFactory::CanCreateTimeSeriesEnsembleTimeSeriesStore Protected Functions Documentation \u00b6 function TimeSeriesStoreFactory \u00b6 TimeSeriesStoreFactory () Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::TimeSeriesStoreFactory"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesStoreFactory/#datatypestimeseriestimeseriesstorefactory","text":"#include <time_series_store.hpp> Inherited by datatypes::tests::TestTimeSeriesStoreFactory , datatypes::timeseries::SwiftNetcdfStoreFactory","title":"datatypes::timeseries::TimeSeriesStoreFactory"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesStoreFactory/#public-functions","text":"Name virtual ~TimeSeriesStoreFactory () virtual TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore (const string & dataId) =0 virtual bool CanCreateTimeSeriesEnsembleTimeSeriesStore (const string & dataId) =0","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesStoreFactory/#protected-functions","text":"Name TimeSeriesStoreFactory ()","title":"Protected Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesStoreFactory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesStoreFactory/#function-timeseriesstorefactory","text":"virtual ~ TimeSeriesStoreFactory ()","title":"function ~TimeSeriesStoreFactory"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesStoreFactory/#function-createtimeseriesensembletimeseriesstore","text":"virtual TimeSeriesEnsembleTimeSeriesStore < double > * CreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ) = 0 Reimplemented by : datatypes::tests::TestTimeSeriesStoreFactory::CreateTimeSeriesEnsembleTimeSeriesStore , datatypes::timeseries::SwiftNetcdfStoreFactory::CreateTimeSeriesEnsembleTimeSeriesStore","title":"function CreateTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesStoreFactory/#function-cancreatetimeseriesensembletimeseriesstore","text":"virtual bool CanCreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ) = 0 Reimplemented by : datatypes::tests::TestTimeSeriesStoreFactory::CanCreateTimeSeriesEnsembleTimeSeriesStore , datatypes::timeseries::SwiftNetcdfStoreFactory::CanCreateTimeSeriesEnsembleTimeSeriesStore","title":"function CanCreateTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesStoreFactory/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeSeriesStoreFactory/#function-timeseriesstorefactory_1","text":"TimeSeriesStoreFactory () Updated on 2022-08-20 at 19:28:22 +1000","title":"function TimeSeriesStoreFactory"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/","text":"datatypes::timeseries::TimeStep \u00b6 Time step handling for time series. More... #include <time_step.h> Public Functions \u00b6 Name TimeStep (const time_duration & stepDuration) Define a time step where every step is a fixed time duration. TimeStep ( TimeStepImplementation * tsi) TimeStep (const TimeStep & src) Copy constructor. TimeStep () ~TimeStep () TimeStep & operator= (const TimeStep & rhs) TimeStep & operator= (const time_duration & stepDuration) Assignment operator. TimeStep & operator= (const string & stepDuration) bool operator== (const TimeStep & rhs) const bool operator!= (const TimeStep & rhs) const TimeStep operator* (int mult) const Multiplication operator, using the time_duration multiplication operator. TimeStep operator* (double mult) const int operator/ (const TimeStep & divisor) const TimeStep operator/ (int divisor) const time_duration operator% (const TimeStep & other) const bool IsRegular () const Query if this time step is defined by a time duration in the true sense (day, week). Monthly time step would return false;. time_duration GetRegularStepDuration () const Gets the underlying time_duration for this time step. Exception thrown if not a regular time step. const ptime AddSteps (const ptime & startTimeStep, size_t n) const const ptime AddSteps (const ptime & startTimeStep, int n) const const ptime AddSteps (const ptime & startTimeStep, double mult) const Adds a number of steps to an instant, which can be non-integer for regular time steps. Behavior TBC for irregular time steps. vector< ptime > AddSteps (const ptime & startTimeStep, const vector< double > timeSteps) const Vectorized version of shifting time steps. Adds a number of steps to an instant, which can be non-integer for regular time steps. Behavior TBC for irregular time steps. vector< ptime > AddSteps (const vector< ptime > & times, double mult) const const time_duration GetTimeStepDuration (const ptime & startTimeStep) const Given an instant, what is the next time instant according to this present Time step. const ptrdiff_t GetUpperNumSteps (const ptime & start, const ptime & end) const Gets the minimum number of time steps covering a time interval. const ptrdiff_t GetNumSteps (const ptime & start, const ptime & end) const Gets the maximum number of time steps from a starting instant to not get beyond an instant in time, 'end'. const ptrdiff_t GetOffset (const ptime & start, const ptime & end) const const void Increment (ptime * t) const Increments an instant by one time step. bool IsUnknown () const Query if this object is the time step value \"unknown\". string GetName () const TimeStep Parse (const string & name) TimeStep FromSeconds (unsigned int seconds) TimeStep GetDaily () TimeStep GetHourly () TimeStep GetMonthlyQpp () TimeStep GetUnknown () Gets an instance of time step that is unknown. This value is indented for use in methods as a default parameter value. ptime CreatePtime (int year, int month, int day, int hour =0, int minute =0, int second =0) ptime PtimeFromIsoString (const string & t) string ToString (const ptime & dt, const string & format =\"YYYYMMDDThhmmss\") Detailed Description \u00b6 class datatypes :: timeseries :: TimeStep ; Time step handling for time series. A TimeStep is responsible for the definition of time steps in time series and the associated calculations for determining time instants and durations Public Functions Documentation \u00b6 function TimeStep \u00b6 TimeStep ( const time_duration & stepDuration ) Define a time step where every step is a fixed time duration. Parameters : stepDuration Duration of the step. function TimeStep \u00b6 TimeStep ( TimeStepImplementation * tsi ) function TimeStep \u00b6 TimeStep ( const TimeStep & src ) Copy constructor. Parameters : src TimeStep to copy. function TimeStep \u00b6 TimeStep () function ~TimeStep \u00b6 ~ TimeStep () function operator= \u00b6 TimeStep & operator = ( const TimeStep & rhs ) function operator= \u00b6 TimeStep & operator = ( const time_duration & stepDuration ) Assignment operator. Parameters : stepDuration Duration of the step. Return : A reference to this object. function operator= \u00b6 TimeStep & operator = ( const string & stepDuration ) function operator== \u00b6 bool operator == ( const TimeStep & rhs ) const function operator!= \u00b6 bool operator != ( const TimeStep & rhs ) const function operator* \u00b6 TimeStep operator * ( int mult ) const Multiplication operator, using the time_duration multiplication operator. Parameters : mult The multiplier. Return : The result of the operation. Multiplication operator, using the time_duration multiplication operator if the argument is an integer. function operator* \u00b6 TimeStep operator * ( double mult ) const function operator/ \u00b6 int operator / ( const TimeStep & divisor ) const function operator/ \u00b6 TimeStep operator / ( int divisor ) const function operator% \u00b6 time_duration operator % ( const TimeStep & other ) const function IsRegular \u00b6 bool IsRegular () const Query if this time step is defined by a time duration in the true sense (day, week). Monthly time step would return false;. Return : true if regular, false if not. function GetRegularStepDuration \u00b6 time_duration GetRegularStepDuration () const Gets the underlying time_duration for this time step. Exception thrown if not a regular time step. Return : The regular step duration. function AddSteps \u00b6 const ptime AddSteps ( const ptime & startTimeStep , size_t n ) const function AddSteps \u00b6 const ptime AddSteps ( const ptime & startTimeStep , int n ) const function AddSteps \u00b6 const ptime AddSteps ( const ptime & startTimeStep , double mult ) const Adds a number of steps to an instant, which can be non-integer for regular time steps. Behavior TBC for irregular time steps. Parameters : startTimeStep The start time step. mult The number of steps added. Return : A ptime. function AddSteps \u00b6 vector < ptime > AddSteps ( const ptime & startTimeStep , const vector < double > timeSteps ) const Vectorized version of shifting time steps. Adds a number of steps to an instant, which can be non-integer for regular time steps. Behavior TBC for irregular time steps. Parameters : startTimeStep The start time step. timeSteps The time steps. Return : A vector function AddSteps \u00b6 vector < ptime > AddSteps ( const vector < ptime > & times , double mult ) const function GetTimeStepDuration \u00b6 const time_duration GetTimeStepDuration ( const ptime & startTimeStep ) const Given an instant, what is the next time instant according to this present Time step. Parameters : startTimeStep The start time step. Return : The time step duration. function GetUpperNumSteps \u00b6 const ptrdiff_t GetUpperNumSteps ( const ptime & start , const ptime & end ) const Gets the minimum number of time steps covering a time interval. Parameters : start The start of the time interval end The end of the time interval Return : the number of steps needed to get beyond 'end' function GetNumSteps \u00b6 const ptrdiff_t GetNumSteps ( const ptime & start , const ptime & end ) const Gets the maximum number of time steps from a starting instant to not get beyond an instant in time, 'end'. Parameters : start The start of the time interval end The end of the time interval Return : the number of steps needed to not get beyond 'end' function GetOffset \u00b6 const ptrdiff_t GetOffset ( const ptime & start , const ptime & end ) const function Increment \u00b6 const void Increment ( ptime * t ) const Increments an instant by one time step. Parameters : t If non-null, the ptime to process. function IsUnknown \u00b6 bool IsUnknown () const Query if this object is the time step value \"unknown\". Return : true if unknown, false if not. function GetName \u00b6 string GetName () const function Parse \u00b6 static TimeStep Parse ( const string & name ) function FromSeconds \u00b6 static TimeStep FromSeconds ( unsigned int seconds ) function GetDaily \u00b6 static TimeStep GetDaily () function GetHourly \u00b6 static TimeStep GetHourly () function GetMonthlyQpp \u00b6 static TimeStep GetMonthlyQpp () function GetUnknown \u00b6 static TimeStep GetUnknown () Gets an instance of time step that is unknown. This value is indented for use in methods as a default parameter value. Return : The \"unknown\" value of the time step function CreatePtime \u00b6 static ptime CreatePtime ( int year , int month , int day , int hour = 0 , int minute = 0 , int second = 0 ) function PtimeFromIsoString \u00b6 static ptime PtimeFromIsoString ( const string & t ) function ToString \u00b6 static string ToString ( const ptime & dt , const string & format = \"YYYYMMDDThhmmss\" ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::TimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#datatypestimeseriestimestep","text":"Time step handling for time series. More... #include <time_step.h>","title":"datatypes::timeseries::TimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#public-functions","text":"Name TimeStep (const time_duration & stepDuration) Define a time step where every step is a fixed time duration. TimeStep ( TimeStepImplementation * tsi) TimeStep (const TimeStep & src) Copy constructor. TimeStep () ~TimeStep () TimeStep & operator= (const TimeStep & rhs) TimeStep & operator= (const time_duration & stepDuration) Assignment operator. TimeStep & operator= (const string & stepDuration) bool operator== (const TimeStep & rhs) const bool operator!= (const TimeStep & rhs) const TimeStep operator* (int mult) const Multiplication operator, using the time_duration multiplication operator. TimeStep operator* (double mult) const int operator/ (const TimeStep & divisor) const TimeStep operator/ (int divisor) const time_duration operator% (const TimeStep & other) const bool IsRegular () const Query if this time step is defined by a time duration in the true sense (day, week). Monthly time step would return false;. time_duration GetRegularStepDuration () const Gets the underlying time_duration for this time step. Exception thrown if not a regular time step. const ptime AddSteps (const ptime & startTimeStep, size_t n) const const ptime AddSteps (const ptime & startTimeStep, int n) const const ptime AddSteps (const ptime & startTimeStep, double mult) const Adds a number of steps to an instant, which can be non-integer for regular time steps. Behavior TBC for irregular time steps. vector< ptime > AddSteps (const ptime & startTimeStep, const vector< double > timeSteps) const Vectorized version of shifting time steps. Adds a number of steps to an instant, which can be non-integer for regular time steps. Behavior TBC for irregular time steps. vector< ptime > AddSteps (const vector< ptime > & times, double mult) const const time_duration GetTimeStepDuration (const ptime & startTimeStep) const Given an instant, what is the next time instant according to this present Time step. const ptrdiff_t GetUpperNumSteps (const ptime & start, const ptime & end) const Gets the minimum number of time steps covering a time interval. const ptrdiff_t GetNumSteps (const ptime & start, const ptime & end) const Gets the maximum number of time steps from a starting instant to not get beyond an instant in time, 'end'. const ptrdiff_t GetOffset (const ptime & start, const ptime & end) const const void Increment (ptime * t) const Increments an instant by one time step. bool IsUnknown () const Query if this object is the time step value \"unknown\". string GetName () const TimeStep Parse (const string & name) TimeStep FromSeconds (unsigned int seconds) TimeStep GetDaily () TimeStep GetHourly () TimeStep GetMonthlyQpp () TimeStep GetUnknown () Gets an instance of time step that is unknown. This value is indented for use in methods as a default parameter value. ptime CreatePtime (int year, int month, int day, int hour =0, int minute =0, int second =0) ptime PtimeFromIsoString (const string & t) string ToString (const ptime & dt, const string & format =\"YYYYMMDDThhmmss\")","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#detailed-description","text":"class datatypes :: timeseries :: TimeStep ; Time step handling for time series. A TimeStep is responsible for the definition of time steps in time series and the associated calculations for determining time instants and durations","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-timestep","text":"TimeStep ( const time_duration & stepDuration ) Define a time step where every step is a fixed time duration. Parameters : stepDuration Duration of the step.","title":"function TimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-timestep_1","text":"TimeStep ( TimeStepImplementation * tsi )","title":"function TimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-timestep_2","text":"TimeStep ( const TimeStep & src ) Copy constructor. Parameters : src TimeStep to copy.","title":"function TimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-timestep_3","text":"TimeStep ()","title":"function TimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-timestep_4","text":"~ TimeStep ()","title":"function ~TimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-operator","text":"TimeStep & operator = ( const TimeStep & rhs )","title":"function operator="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-operator_1","text":"TimeStep & operator = ( const time_duration & stepDuration ) Assignment operator. Parameters : stepDuration Duration of the step. Return : A reference to this object.","title":"function operator="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-operator_2","text":"TimeStep & operator = ( const string & stepDuration )","title":"function operator="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-operator_3","text":"bool operator == ( const TimeStep & rhs ) const","title":"function operator=="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-operator_4","text":"bool operator != ( const TimeStep & rhs ) const","title":"function operator!="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-operator_5","text":"TimeStep operator * ( int mult ) const Multiplication operator, using the time_duration multiplication operator. Parameters : mult The multiplier. Return : The result of the operation. Multiplication operator, using the time_duration multiplication operator if the argument is an integer.","title":"function operator*"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-operator_6","text":"TimeStep operator * ( double mult ) const","title":"function operator*"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-operator_7","text":"int operator / ( const TimeStep & divisor ) const","title":"function operator/"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-operator_8","text":"TimeStep operator / ( int divisor ) const","title":"function operator/"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-operator_9","text":"time_duration operator % ( const TimeStep & other ) const","title":"function operator%"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-isregular","text":"bool IsRegular () const Query if this time step is defined by a time duration in the true sense (day, week). Monthly time step would return false;. Return : true if regular, false if not.","title":"function IsRegular"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-getregularstepduration","text":"time_duration GetRegularStepDuration () const Gets the underlying time_duration for this time step. Exception thrown if not a regular time step. Return : The regular step duration.","title":"function GetRegularStepDuration"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-addsteps","text":"const ptime AddSteps ( const ptime & startTimeStep , size_t n ) const","title":"function AddSteps"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-addsteps_1","text":"const ptime AddSteps ( const ptime & startTimeStep , int n ) const","title":"function AddSteps"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-addsteps_2","text":"const ptime AddSteps ( const ptime & startTimeStep , double mult ) const Adds a number of steps to an instant, which can be non-integer for regular time steps. Behavior TBC for irregular time steps. Parameters : startTimeStep The start time step. mult The number of steps added. Return : A ptime.","title":"function AddSteps"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-addsteps_3","text":"vector < ptime > AddSteps ( const ptime & startTimeStep , const vector < double > timeSteps ) const Vectorized version of shifting time steps. Adds a number of steps to an instant, which can be non-integer for regular time steps. Behavior TBC for irregular time steps. Parameters : startTimeStep The start time step. timeSteps The time steps. Return : A vector","title":"function AddSteps"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-addsteps_4","text":"vector < ptime > AddSteps ( const vector < ptime > & times , double mult ) const","title":"function AddSteps"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-gettimestepduration","text":"const time_duration GetTimeStepDuration ( const ptime & startTimeStep ) const Given an instant, what is the next time instant according to this present Time step. Parameters : startTimeStep The start time step. Return : The time step duration.","title":"function GetTimeStepDuration"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-getuppernumsteps","text":"const ptrdiff_t GetUpperNumSteps ( const ptime & start , const ptime & end ) const Gets the minimum number of time steps covering a time interval. Parameters : start The start of the time interval end The end of the time interval Return : the number of steps needed to get beyond 'end'","title":"function GetUpperNumSteps"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-getnumsteps","text":"const ptrdiff_t GetNumSteps ( const ptime & start , const ptime & end ) const Gets the maximum number of time steps from a starting instant to not get beyond an instant in time, 'end'. Parameters : start The start of the time interval end The end of the time interval Return : the number of steps needed to not get beyond 'end'","title":"function GetNumSteps"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-getoffset","text":"const ptrdiff_t GetOffset ( const ptime & start , const ptime & end ) const","title":"function GetOffset"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-increment","text":"const void Increment ( ptime * t ) const Increments an instant by one time step. Parameters : t If non-null, the ptime to process.","title":"function Increment"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-isunknown","text":"bool IsUnknown () const Query if this object is the time step value \"unknown\". Return : true if unknown, false if not.","title":"function IsUnknown"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-getname","text":"string GetName () const","title":"function GetName"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-parse","text":"static TimeStep Parse ( const string & name )","title":"function Parse"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-fromseconds","text":"static TimeStep FromSeconds ( unsigned int seconds )","title":"function FromSeconds"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-getdaily","text":"static TimeStep GetDaily ()","title":"function GetDaily"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-gethourly","text":"static TimeStep GetHourly ()","title":"function GetHourly"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-getmonthlyqpp","text":"static TimeStep GetMonthlyQpp ()","title":"function GetMonthlyQpp"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-getunknown","text":"static TimeStep GetUnknown () Gets an instance of time step that is unknown. This value is indented for use in methods as a default parameter value. Return : The \"unknown\" value of the time step","title":"function GetUnknown"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-createptime","text":"static ptime CreatePtime ( int year , int month , int day , int hour = 0 , int minute = 0 , int second = 0 )","title":"function CreatePtime"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-ptimefromisostring","text":"static ptime PtimeFromIsoString ( const string & t )","title":"function PtimeFromIsoString"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStep/#function-tostring","text":"static string ToString ( const ptime & dt , const string & format = \"YYYYMMDDThhmmss\" ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function ToString"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/","text":"datatypes::timeseries::TimeStepImplementation \u00b6 #include <time_step_implementation.h> Inherited by datatypes::timeseries::IrregularTimeStepImplementation , datatypes::timeseries::RegularTimeStepImplementation Public Functions \u00b6 Name virtual ~TimeStepImplementation () virtual TimeStepImplementation * Clone () =0 virtual TimeStepImplementation * Multiply (int mult) const =0 virtual TimeStepImplementation * Divide (int divisor) const =0 virtual TimeStepImplementation * Multiply (double mult) const =0 virtual bool Equals ( TimeStepImplementation * tsImpl) const =0 virtual const ptime AddIntSteps (const ptime & startTimeStep, int n) const =0 virtual const ptime AddSteps (const ptime & startTimeStep, double mult) const =0 virtual const time_duration GetTimeStepDuration (const ptime & startTimeStep) const =0 virtual const void Increment (ptime * t) const =0 virtual const ptrdiff_t GetUpperNumSteps (const ptime & start, const ptime & end) const virtual const ptrdiff_t GetNumSteps (const ptime & start, const ptime & end) const virtual const ptrdiff_t GetOffset (const ptime & start, const ptime & end) const virtual bool IsRegular () const =0 virtual time_duration GetRegularStepDuration () const =0 virtual std::string GetName () const =0 void CheckIsDateTime (const ptime & instant) Protected Functions \u00b6 Name virtual const double GetLinearIndexing (const ptime & start, const ptime & end) const =0 Public Functions Documentation \u00b6 function ~TimeStepImplementation \u00b6 virtual ~ TimeStepImplementation () function Clone \u00b6 virtual TimeStepImplementation * Clone () = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::Clone , datatypes::timeseries::MonthlyQppTimeStepImplementation::Clone , datatypes::timeseries::IrregularTimeStepImplementation::Clone function Multiply \u00b6 virtual TimeStepImplementation * Multiply ( int mult ) const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::Multiply , datatypes::timeseries::IrregularTimeStepImplementation::Multiply function Divide \u00b6 virtual TimeStepImplementation * Divide ( int divisor ) const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::Divide , datatypes::timeseries::IrregularTimeStepImplementation::Divide function Multiply \u00b6 virtual TimeStepImplementation * Multiply ( double mult ) const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::Multiply , datatypes::timeseries::IrregularTimeStepImplementation::Multiply function Equals \u00b6 virtual bool Equals ( TimeStepImplementation * tsImpl ) const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::Equals , datatypes::timeseries::MonthlyQppTimeStepImplementation::Equals , datatypes::timeseries::IrregularTimeStepImplementation::Equals function AddIntSteps \u00b6 virtual const ptime AddIntSteps ( const ptime & startTimeStep , int n ) const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::AddIntSteps , datatypes::timeseries::MonthlyQppTimeStepImplementation::AddIntSteps , datatypes::timeseries::IrregularTimeStepImplementation::AddIntSteps function AddSteps \u00b6 virtual const ptime AddSteps ( const ptime & startTimeStep , double mult ) const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::AddSteps , datatypes::timeseries::MonthlyQppTimeStepImplementation::AddSteps , datatypes::timeseries::IrregularTimeStepImplementation::AddSteps function GetTimeStepDuration \u00b6 virtual const time_duration GetTimeStepDuration ( const ptime & startTimeStep ) const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::GetTimeStepDuration , datatypes::timeseries::IrregularTimeStepImplementation::GetTimeStepDuration , datatypes::timeseries::MonthlyQppTimeStepImplementation::GetTimeStepDuration function Increment \u00b6 virtual const void Increment ( ptime * t ) const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::Increment , datatypes::timeseries::MonthlyQppTimeStepImplementation::Increment , datatypes::timeseries::IrregularTimeStepImplementation::Increment function GetUpperNumSteps \u00b6 virtual const ptrdiff_t GetUpperNumSteps ( const ptime & start , const ptime & end ) const function GetNumSteps \u00b6 virtual const ptrdiff_t GetNumSteps ( const ptime & start , const ptime & end ) const function GetOffset \u00b6 virtual const ptrdiff_t GetOffset ( const ptime & start , const ptime & end ) const function IsRegular \u00b6 virtual bool IsRegular () const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::IsRegular , datatypes::timeseries::IrregularTimeStepImplementation::IsRegular function GetRegularStepDuration \u00b6 virtual time_duration GetRegularStepDuration () const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::GetRegularStepDuration , datatypes::timeseries::IrregularTimeStepImplementation::GetRegularStepDuration function GetName \u00b6 virtual std :: string GetName () const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::GetName , datatypes::timeseries::MonthlyQppTimeStepImplementation::GetName , datatypes::timeseries::IrregularTimeStepImplementation::GetName function CheckIsDateTime \u00b6 static void CheckIsDateTime ( const ptime & instant ) Protected Functions Documentation \u00b6 function GetLinearIndexing \u00b6 virtual const double GetLinearIndexing ( const ptime & start , const ptime & end ) const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::GetLinearIndexing , datatypes::timeseries::MonthlyQppTimeStepImplementation::GetLinearIndexing , datatypes::timeseries::IrregularTimeStepImplementation::GetLinearIndexing Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::TimeStepImplementation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/#datatypestimeseriestimestepimplementation","text":"#include <time_step_implementation.h> Inherited by datatypes::timeseries::IrregularTimeStepImplementation , datatypes::timeseries::RegularTimeStepImplementation","title":"datatypes::timeseries::TimeStepImplementation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/#public-functions","text":"Name virtual ~TimeStepImplementation () virtual TimeStepImplementation * Clone () =0 virtual TimeStepImplementation * Multiply (int mult) const =0 virtual TimeStepImplementation * Divide (int divisor) const =0 virtual TimeStepImplementation * Multiply (double mult) const =0 virtual bool Equals ( TimeStepImplementation * tsImpl) const =0 virtual const ptime AddIntSteps (const ptime & startTimeStep, int n) const =0 virtual const ptime AddSteps (const ptime & startTimeStep, double mult) const =0 virtual const time_duration GetTimeStepDuration (const ptime & startTimeStep) const =0 virtual const void Increment (ptime * t) const =0 virtual const ptrdiff_t GetUpperNumSteps (const ptime & start, const ptime & end) const virtual const ptrdiff_t GetNumSteps (const ptime & start, const ptime & end) const virtual const ptrdiff_t GetOffset (const ptime & start, const ptime & end) const virtual bool IsRegular () const =0 virtual time_duration GetRegularStepDuration () const =0 virtual std::string GetName () const =0 void CheckIsDateTime (const ptime & instant)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/#protected-functions","text":"Name virtual const double GetLinearIndexing (const ptime & start, const ptime & end) const =0","title":"Protected Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/#function-timestepimplementation","text":"virtual ~ TimeStepImplementation ()","title":"function ~TimeStepImplementation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/#function-clone","text":"virtual TimeStepImplementation * Clone () = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::Clone , datatypes::timeseries::MonthlyQppTimeStepImplementation::Clone , datatypes::timeseries::IrregularTimeStepImplementation::Clone","title":"function Clone"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/#function-multiply","text":"virtual TimeStepImplementation * Multiply ( int mult ) const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::Multiply , datatypes::timeseries::IrregularTimeStepImplementation::Multiply","title":"function Multiply"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/#function-divide","text":"virtual TimeStepImplementation * Divide ( int divisor ) const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::Divide , datatypes::timeseries::IrregularTimeStepImplementation::Divide","title":"function Divide"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/#function-multiply_1","text":"virtual TimeStepImplementation * Multiply ( double mult ) const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::Multiply , datatypes::timeseries::IrregularTimeStepImplementation::Multiply","title":"function Multiply"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/#function-equals","text":"virtual bool Equals ( TimeStepImplementation * tsImpl ) const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::Equals , datatypes::timeseries::MonthlyQppTimeStepImplementation::Equals , datatypes::timeseries::IrregularTimeStepImplementation::Equals","title":"function Equals"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/#function-addintsteps","text":"virtual const ptime AddIntSteps ( const ptime & startTimeStep , int n ) const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::AddIntSteps , datatypes::timeseries::MonthlyQppTimeStepImplementation::AddIntSteps , datatypes::timeseries::IrregularTimeStepImplementation::AddIntSteps","title":"function AddIntSteps"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/#function-addsteps","text":"virtual const ptime AddSteps ( const ptime & startTimeStep , double mult ) const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::AddSteps , datatypes::timeseries::MonthlyQppTimeStepImplementation::AddSteps , datatypes::timeseries::IrregularTimeStepImplementation::AddSteps","title":"function AddSteps"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/#function-gettimestepduration","text":"virtual const time_duration GetTimeStepDuration ( const ptime & startTimeStep ) const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::GetTimeStepDuration , datatypes::timeseries::IrregularTimeStepImplementation::GetTimeStepDuration , datatypes::timeseries::MonthlyQppTimeStepImplementation::GetTimeStepDuration","title":"function GetTimeStepDuration"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/#function-increment","text":"virtual const void Increment ( ptime * t ) const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::Increment , datatypes::timeseries::MonthlyQppTimeStepImplementation::Increment , datatypes::timeseries::IrregularTimeStepImplementation::Increment","title":"function Increment"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/#function-getuppernumsteps","text":"virtual const ptrdiff_t GetUpperNumSteps ( const ptime & start , const ptime & end ) const","title":"function GetUpperNumSteps"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/#function-getnumsteps","text":"virtual const ptrdiff_t GetNumSteps ( const ptime & start , const ptime & end ) const","title":"function GetNumSteps"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/#function-getoffset","text":"virtual const ptrdiff_t GetOffset ( const ptime & start , const ptime & end ) const","title":"function GetOffset"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/#function-isregular","text":"virtual bool IsRegular () const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::IsRegular , datatypes::timeseries::IrregularTimeStepImplementation::IsRegular","title":"function IsRegular"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/#function-getregularstepduration","text":"virtual time_duration GetRegularStepDuration () const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::GetRegularStepDuration , datatypes::timeseries::IrregularTimeStepImplementation::GetRegularStepDuration","title":"function GetRegularStepDuration"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/#function-getname","text":"virtual std :: string GetName () const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::GetName , datatypes::timeseries::MonthlyQppTimeStepImplementation::GetName , datatypes::timeseries::IrregularTimeStepImplementation::GetName","title":"function GetName"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/#function-checkisdatetime","text":"static void CheckIsDateTime ( const ptime & instant )","title":"function CheckIsDateTime"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeStepImplementation/#function-getlinearindexing","text":"virtual const double GetLinearIndexing ( const ptime & start , const ptime & end ) const = 0 Reimplemented by : datatypes::timeseries::RegularTimeStepImplementation::GetLinearIndexing , datatypes::timeseries::MonthlyQppTimeStepImplementation::GetLinearIndexing , datatypes::timeseries::IrregularTimeStepImplementation::GetLinearIndexing Updated on 2022-08-20 at 19:28:22 +1000","title":"function GetLinearIndexing"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeWindow/","text":"datatypes::timeseries::TimeWindow \u00b6 An object that represents a time window, defining subset/trim operations on time series. More... #include <time_series.hpp> Public Functions \u00b6 Name TimeWindow (const ptime & startDate, const ptime & endDate) Tts * Trim (const Tts & timeSeries) const Detailed Description \u00b6 template < typename Tts = TimeSeries > class datatypes :: timeseries :: TimeWindow ; An object that represents a time window, defining subset/trim operations on time series. Template Parameters : T Generic type parameter, element type of the time series Public Functions Documentation \u00b6 function TimeWindow \u00b6 inline TimeWindow ( const ptime & startDate , const ptime & endDate ) function Trim \u00b6 inline Tts * Trim ( const Tts & timeSeries ) const Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::TimeWindow"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeWindow/#datatypestimeseriestimewindow","text":"An object that represents a time window, defining subset/trim operations on time series. More... #include <time_series.hpp>","title":"datatypes::timeseries::TimeWindow"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeWindow/#public-functions","text":"Name TimeWindow (const ptime & startDate, const ptime & endDate) Tts * Trim (const Tts & timeSeries) const","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeWindow/#detailed-description","text":"template < typename Tts = TimeSeries > class datatypes :: timeseries :: TimeWindow ; An object that represents a time window, defining subset/trim operations on time series. Template Parameters : T Generic type parameter, element type of the time series","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeWindow/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeWindow/#function-timewindow","text":"inline TimeWindow ( const ptime & startDate , const ptime & endDate )","title":"function TimeWindow"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1TimeWindow/#function-trim","text":"inline Tts * Trim ( const Tts & timeSeries ) const Updated on 2022-08-20 at 19:28:22 +1000","title":"function Trim"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableAttributes/","text":"datatypes::timeseries::VariableAttributes \u00b6 A class to hold the attributes of a netCDF variable stored in the SWIFT netCDF format. #include <time_series_io.hpp> Public Functions \u00b6 Name const double DefaultFillValue () VariableAttributes () VariableAttributes (const string & longName, const string & units, int type, const string & typeDescription, const string & datType, const string & datDescription, const string & locationType, double fillValue) VariableAttributes ( VariableAttributes && src) VariableAttributes (const VariableAttributes & src) VariableAttributes & operator= (const VariableAttributes & src) Public Attributes \u00b6 Name string LongName string Units int Type string TypeDescription string LocationType string DatType string DatDescription double FillValue Public Functions Documentation \u00b6 function DefaultFillValue \u00b6 static const double DefaultFillValue () function VariableAttributes \u00b6 VariableAttributes () function VariableAttributes \u00b6 VariableAttributes ( const string & longName , const string & units , int type , const string & typeDescription , const string & datType , const string & datDescription , const string & locationType , double fillValue ) function VariableAttributes \u00b6 VariableAttributes ( VariableAttributes && src ) function VariableAttributes \u00b6 VariableAttributes ( const VariableAttributes & src ) function operator= \u00b6 VariableAttributes & operator = ( const VariableAttributes & src ) Public Attributes Documentation \u00b6 variable LongName \u00b6 string LongName ; variable Units \u00b6 string Units ; variable Type \u00b6 int Type = 0 ; variable TypeDescription \u00b6 string TypeDescription ; variable LocationType \u00b6 string LocationType ; variable DatType \u00b6 string DatType ; variable DatDescription \u00b6 string DatDescription ; variable FillValue \u00b6 double FillValue ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::VariableAttributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableAttributes/#datatypestimeseriesvariableattributes","text":"A class to hold the attributes of a netCDF variable stored in the SWIFT netCDF format. #include <time_series_io.hpp>","title":"datatypes::timeseries::VariableAttributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableAttributes/#public-functions","text":"Name const double DefaultFillValue () VariableAttributes () VariableAttributes (const string & longName, const string & units, int type, const string & typeDescription, const string & datType, const string & datDescription, const string & locationType, double fillValue) VariableAttributes ( VariableAttributes && src) VariableAttributes (const VariableAttributes & src) VariableAttributes & operator= (const VariableAttributes & src)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableAttributes/#public-attributes","text":"Name string LongName string Units int Type string TypeDescription string LocationType string DatType string DatDescription double FillValue","title":"Public Attributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableAttributes/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableAttributes/#function-defaultfillvalue","text":"static const double DefaultFillValue ()","title":"function DefaultFillValue"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableAttributes/#function-variableattributes","text":"VariableAttributes ()","title":"function VariableAttributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableAttributes/#function-variableattributes_1","text":"VariableAttributes ( const string & longName , const string & units , int type , const string & typeDescription , const string & datType , const string & datDescription , const string & locationType , double fillValue )","title":"function VariableAttributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableAttributes/#function-variableattributes_2","text":"VariableAttributes ( VariableAttributes && src )","title":"function VariableAttributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableAttributes/#function-variableattributes_3","text":"VariableAttributes ( const VariableAttributes & src )","title":"function VariableAttributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableAttributes/#function-operator","text":"VariableAttributes & operator = ( const VariableAttributes & src )","title":"function operator="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableAttributes/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableAttributes/#variable-longname","text":"string LongName ;","title":"variable LongName"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableAttributes/#variable-units","text":"string Units ;","title":"variable Units"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableAttributes/#variable-type","text":"int Type = 0 ;","title":"variable Type"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableAttributes/#variable-typedescription","text":"string TypeDescription ;","title":"variable TypeDescription"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableAttributes/#variable-locationtype","text":"string LocationType ;","title":"variable LocationType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableAttributes/#variable-dattype","text":"string DatType ;","title":"variable DatType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableAttributes/#variable-datdescription","text":"string DatDescription ;","title":"variable DatDescription"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableAttributes/#variable-fillvalue","text":"double FillValue ; Updated on 2022-08-20 at 19:28:22 +1000","title":"variable FillValue"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableDefinition/","text":"datatypes::timeseries::VariableDefinition \u00b6 #include <time_series_io.hpp> Public Functions \u00b6 Name VariableDefinition (const string & name, const string & precision, const string & dimensions, const string & longName, const string & units, double fillValue, int type, const string & typeDescription, const string & datType, const string & datDescription, const string & locationType) VariableDefinition (const string & name, const VariableAttributes & attribs, const string & dimensions, const string & precision = DATATYPES_DOUBLE_PRECISION_ID ) int GetPrecision () const VariableDefinition () VariableDefinition ( VariableDefinition && src) VariableDefinition (const VariableDefinition & src) VariableDefinition & operator= ( VariableDefinition && src) VariableDefinition & operator= (const VariableDefinition & src) void Split (const std::map< string, VariableDefinition > & varDefinitions, vector< string > & varNames, std::map< string, VariableAttributes > & varAttributes) VariableDefinition PointTimeSeries (const string & name, const string & units, const string & longName, int type =0, const string & typeDescription =\" \", const string & datType =\" \", const string & datDescription =\" \", const string & precision = DATATYPES_DOUBLE_PRECISION_ID , double fillValue = DEFAULT_MISSING_DATA_VALUE , const string & locationType =\"Point\") VariableDefinition TimeSeriesEnsembleTimeSeries (const string & name, const string & units, const string & longName, int type =0, const string & typeDescription =\" \", const string & datType =\" \", const string & datDescription =\" \", const string & precision = DATATYPES_DOUBLE_PRECISION_ID , double fillValue = DEFAULT_MISSING_DATA_VALUE , const string & locationType =\"Point\") Public Attributes \u00b6 Name VariableAttributes attributes string Name string Precision string Dimensions Public Functions Documentation \u00b6 function VariableDefinition \u00b6 VariableDefinition ( const string & name , const string & precision , const string & dimensions , const string & longName , const string & units , double fillValue , int type , const string & typeDescription , const string & datType , const string & datDescription , const string & locationType ) function VariableDefinition \u00b6 VariableDefinition ( const string & name , const VariableAttributes & attribs , const string & dimensions , const string & precision = DATATYPES_DOUBLE_PRECISION_ID ) function GetPrecision \u00b6 int GetPrecision () const function VariableDefinition \u00b6 VariableDefinition () function VariableDefinition \u00b6 VariableDefinition ( VariableDefinition && src ) function VariableDefinition \u00b6 VariableDefinition ( const VariableDefinition & src ) function operator= \u00b6 VariableDefinition & operator = ( VariableDefinition && src ) function operator= \u00b6 VariableDefinition & operator = ( const VariableDefinition & src ) function Split \u00b6 static void Split ( const std :: map < string , VariableDefinition > & varDefinitions , vector < string > & varNames , std :: map < string , VariableAttributes > & varAttributes ) function PointTimeSeries \u00b6 static VariableDefinition PointTimeSeries ( const string & name , const string & units , const string & longName , int type = 0 , const string & typeDescription = \"<NA>\" , const string & datType = \"<NA>\" , const string & datDescription = \"<NA>\" , const string & precision = DATATYPES_DOUBLE_PRECISION_ID , double fillValue = DEFAULT_MISSING_DATA_VALUE , const string & locationType = \"Point\" ) function TimeSeriesEnsembleTimeSeries \u00b6 static VariableDefinition TimeSeriesEnsembleTimeSeries ( const string & name , const string & units , const string & longName , int type = 0 , const string & typeDescription = \"<NA>\" , const string & datType = \"<NA>\" , const string & datDescription = \"<NA>\" , const string & precision = DATATYPES_DOUBLE_PRECISION_ID , double fillValue = DEFAULT_MISSING_DATA_VALUE , const string & locationType = \"Point\" ) Public Attributes Documentation \u00b6 variable attributes \u00b6 VariableAttributes attributes ; variable Name \u00b6 string Name ; variable Precision \u00b6 string Precision ; variable Dimensions \u00b6 string Dimensions ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::VariableDefinition"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableDefinition/#datatypestimeseriesvariabledefinition","text":"#include <time_series_io.hpp>","title":"datatypes::timeseries::VariableDefinition"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableDefinition/#public-functions","text":"Name VariableDefinition (const string & name, const string & precision, const string & dimensions, const string & longName, const string & units, double fillValue, int type, const string & typeDescription, const string & datType, const string & datDescription, const string & locationType) VariableDefinition (const string & name, const VariableAttributes & attribs, const string & dimensions, const string & precision = DATATYPES_DOUBLE_PRECISION_ID ) int GetPrecision () const VariableDefinition () VariableDefinition ( VariableDefinition && src) VariableDefinition (const VariableDefinition & src) VariableDefinition & operator= ( VariableDefinition && src) VariableDefinition & operator= (const VariableDefinition & src) void Split (const std::map< string, VariableDefinition > & varDefinitions, vector< string > & varNames, std::map< string, VariableAttributes > & varAttributes) VariableDefinition PointTimeSeries (const string & name, const string & units, const string & longName, int type =0, const string & typeDescription =\" \", const string & datType =\" \", const string & datDescription =\" \", const string & precision = DATATYPES_DOUBLE_PRECISION_ID , double fillValue = DEFAULT_MISSING_DATA_VALUE , const string & locationType =\"Point\") VariableDefinition TimeSeriesEnsembleTimeSeries (const string & name, const string & units, const string & longName, int type =0, const string & typeDescription =\" \", const string & datType =\" \", const string & datDescription =\" \", const string & precision = DATATYPES_DOUBLE_PRECISION_ID , double fillValue = DEFAULT_MISSING_DATA_VALUE , const string & locationType =\"Point\")","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableDefinition/#public-attributes","text":"Name VariableAttributes attributes string Name string Precision string Dimensions","title":"Public Attributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableDefinition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableDefinition/#function-variabledefinition","text":"VariableDefinition ( const string & name , const string & precision , const string & dimensions , const string & longName , const string & units , double fillValue , int type , const string & typeDescription , const string & datType , const string & datDescription , const string & locationType )","title":"function VariableDefinition"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableDefinition/#function-variabledefinition_1","text":"VariableDefinition ( const string & name , const VariableAttributes & attribs , const string & dimensions , const string & precision = DATATYPES_DOUBLE_PRECISION_ID )","title":"function VariableDefinition"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableDefinition/#function-getprecision","text":"int GetPrecision () const","title":"function GetPrecision"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableDefinition/#function-variabledefinition_2","text":"VariableDefinition ()","title":"function VariableDefinition"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableDefinition/#function-variabledefinition_3","text":"VariableDefinition ( VariableDefinition && src )","title":"function VariableDefinition"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableDefinition/#function-variabledefinition_4","text":"VariableDefinition ( const VariableDefinition & src )","title":"function VariableDefinition"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableDefinition/#function-operator","text":"VariableDefinition & operator = ( VariableDefinition && src )","title":"function operator="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableDefinition/#function-operator_1","text":"VariableDefinition & operator = ( const VariableDefinition & src )","title":"function operator="},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableDefinition/#function-split","text":"static void Split ( const std :: map < string , VariableDefinition > & varDefinitions , vector < string > & varNames , std :: map < string , VariableAttributes > & varAttributes )","title":"function Split"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableDefinition/#function-pointtimeseries","text":"static VariableDefinition PointTimeSeries ( const string & name , const string & units , const string & longName , int type = 0 , const string & typeDescription = \"<NA>\" , const string & datType = \"<NA>\" , const string & datDescription = \"<NA>\" , const string & precision = DATATYPES_DOUBLE_PRECISION_ID , double fillValue = DEFAULT_MISSING_DATA_VALUE , const string & locationType = \"Point\" )","title":"function PointTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableDefinition/#function-timeseriesensembletimeseries","text":"static VariableDefinition TimeSeriesEnsembleTimeSeries ( const string & name , const string & units , const string & longName , int type = 0 , const string & typeDescription = \"<NA>\" , const string & datType = \"<NA>\" , const string & datDescription = \"<NA>\" , const string & precision = DATATYPES_DOUBLE_PRECISION_ID , double fillValue = DEFAULT_MISSING_DATA_VALUE , const string & locationType = \"Point\" )","title":"function TimeSeriesEnsembleTimeSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableDefinition/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableDefinition/#variable-attributes","text":"VariableAttributes attributes ;","title":"variable attributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableDefinition/#variable-name","text":"string Name ;","title":"variable Name"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableDefinition/#variable-precision","text":"string Precision ;","title":"variable Precision"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1VariableDefinition/#variable-dimensions","text":"string Dimensions ; Updated on 2022-08-20 at 19:28:22 +1000","title":"variable Dimensions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/","text":"datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore \u00b6 More... #include <time_series_store.hpp> Inherits from datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T > , datatypes::timeseries::IdentifiersProvider , datatypes::timeseries::TimeSeriesInfoProvider , datatypes::timeseries::DataDescriptor Public Types \u00b6 Name using typename CommonTypes < T >:: SeriesType SeriesType using typename CommonTypes < T >:: PtrSeriesType PtrSeriesType using typename CommonTypes < T >:: EnsemblePtrType EnsemblePtrType using typename CommonTypes < T >:: PtrEnsemblePtrType PtrEnsemblePtrType using typename CommonTypes < T >:: TSeriesEnsemblePtrType TSeriesEnsemblePtrType using typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType PtrTSeriesEnsemblePtrType Public Functions \u00b6 Name virtual ~WritableTimeSeriesEnsembleTimeSeriesStore () virtual bool IsActive () =0 virtual void Allocate (size_t length, PtrEnsemblePtrType value) =0 void AllocateValues (size_t length, const PtrEnsemblePtrType * values) virtual void AllocateValues (const vector< PtrEnsemblePtrType > & values) virtual void SetSeries (const string & dataId, PtrTSeriesEnsemblePtrType value) =0 virtual void SetItem (const string & dataId, size_t index, PtrEnsemblePtrType value) =0 virtual void SetItem (const string & dataId, size_t index, const EnsemblePtrType & value) =0 virtual void SetLength (size_t ) =0 virtual void SetStart (ptime ) =0 virtual void SetTimeStep (const TimeStep & ) =0 Additional inherited members \u00b6 Public Functions inherited from datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T > Name virtual ~TimeSeriesEnsembleTimeSeriesStore () virtual PtrTSeriesEnsemblePtrType GetSeries (const string & dataId) =0 virtual PtrEnsemblePtrType GetItem (const string & dataId, size_t fcastIndex) virtual PtrSeriesType GetItem (const string & dataId, size_t fcastIndex, size_t ensIndex) virtual size_t GetEnsembleSize (const string & dataId, size_t fcastIndex) const virtual PtrEnsemblePtrType Read (const string & ensembleIdentifier) =0 virtual size_t GetLength () const =0 virtual ptime GetStart () const =0 virtual TimeStep GetTimeStep () const =0 virtual vector< string > GetIdentifiers () const Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () virtual vector< string > GetIdentifiers () const =0 vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId) Public Functions inherited from datatypes::timeseries::TimeSeriesInfoProvider Name virtual ~TimeSeriesInfoProvider () virtual size_t GetLength () const =0 virtual TimeStep GetTimeStep () const =0 virtual ptime GetStart () const =0 Public Functions inherited from datatypes::timeseries::DataDescriptor Name virtual string GetDataSummary () const =0 virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const =0 Detailed Description \u00b6 template < typename T > class datatypes :: timeseries :: WritableTimeSeriesEnsembleTimeSeriesStore ; Public Types Documentation \u00b6 using SeriesType \u00b6 using datatypes :: timeseries :: WritableTimeSeriesEnsembleTimeSeriesStore < T >:: SeriesType = typename CommonTypes < T >:: SeriesType ; using PtrSeriesType \u00b6 using datatypes :: timeseries :: WritableTimeSeriesEnsembleTimeSeriesStore < T >:: PtrSeriesType = typename CommonTypes < T >:: PtrSeriesType ; using EnsemblePtrType \u00b6 using datatypes :: timeseries :: WritableTimeSeriesEnsembleTimeSeriesStore < T >:: EnsemblePtrType = typename CommonTypes < T >:: EnsemblePtrType ; using PtrEnsemblePtrType \u00b6 using datatypes :: timeseries :: WritableTimeSeriesEnsembleTimeSeriesStore < T >:: PtrEnsemblePtrType = typename CommonTypes < T >:: PtrEnsemblePtrType ; using TSeriesEnsemblePtrType \u00b6 using datatypes :: timeseries :: WritableTimeSeriesEnsembleTimeSeriesStore < T >:: TSeriesEnsemblePtrType = typename CommonTypes < T >:: TSeriesEnsemblePtrType ; using PtrTSeriesEnsemblePtrType \u00b6 using datatypes :: timeseries :: WritableTimeSeriesEnsembleTimeSeriesStore < T >:: PtrTSeriesEnsemblePtrType = typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType ; Public Functions Documentation \u00b6 function ~WritableTimeSeriesEnsembleTimeSeriesStore \u00b6 inline virtual ~ WritableTimeSeriesEnsembleTimeSeriesStore () function IsActive \u00b6 virtual bool IsActive () = 0 Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::IsActive , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::IsActive function Allocate \u00b6 virtual void Allocate ( size_t length , PtrEnsemblePtrType value ) = 0 Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::Allocate , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::Allocate function AllocateValues \u00b6 inline void AllocateValues ( size_t length , const PtrEnsemblePtrType * values ) function AllocateValues \u00b6 inline virtual void AllocateValues ( const vector < PtrEnsemblePtrType > & values ) Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::AllocateValues , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::AllocateValues function SetSeries \u00b6 virtual void SetSeries ( const string & dataId , PtrTSeriesEnsemblePtrType value ) = 0 Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::SetSeries , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::SetSeries function SetItem \u00b6 virtual void SetItem ( const string & dataId , size_t index , PtrEnsemblePtrType value ) = 0 Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::SetItem , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::SetItem function SetItem \u00b6 virtual void SetItem ( const string & dataId , size_t index , const EnsemblePtrType & value ) = 0 Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::SetItem , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::SetItem function SetLength \u00b6 virtual void SetLength ( size_t ) = 0 Reimplemented by : datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::SetLength , datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::SetLength function SetStart \u00b6 virtual void SetStart ( ptime ) = 0 Reimplemented by : datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::SetStart , datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::SetStart function SetTimeStep \u00b6 virtual void SetTimeStep ( const TimeStep & ) = 0 Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::SetTimeStep , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::SetTimeStep Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#datatypestimeserieswritabletimeseriesensembletimeseriesstore","text":"More... #include <time_series_store.hpp> Inherits from datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T > , datatypes::timeseries::IdentifiersProvider , datatypes::timeseries::TimeSeriesInfoProvider , datatypes::timeseries::DataDescriptor","title":"datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#public-types","text":"Name using typename CommonTypes < T >:: SeriesType SeriesType using typename CommonTypes < T >:: PtrSeriesType PtrSeriesType using typename CommonTypes < T >:: EnsemblePtrType EnsemblePtrType using typename CommonTypes < T >:: PtrEnsemblePtrType PtrEnsemblePtrType using typename CommonTypes < T >:: TSeriesEnsemblePtrType TSeriesEnsemblePtrType using typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType PtrTSeriesEnsemblePtrType","title":"Public Types"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#public-functions","text":"Name virtual ~WritableTimeSeriesEnsembleTimeSeriesStore () virtual bool IsActive () =0 virtual void Allocate (size_t length, PtrEnsemblePtrType value) =0 void AllocateValues (size_t length, const PtrEnsemblePtrType * values) virtual void AllocateValues (const vector< PtrEnsemblePtrType > & values) virtual void SetSeries (const string & dataId, PtrTSeriesEnsemblePtrType value) =0 virtual void SetItem (const string & dataId, size_t index, PtrEnsemblePtrType value) =0 virtual void SetItem (const string & dataId, size_t index, const EnsemblePtrType & value) =0 virtual void SetLength (size_t ) =0 virtual void SetStart (ptime ) =0 virtual void SetTimeStep (const TimeStep & ) =0","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#additional-inherited-members","text":"Public Functions inherited from datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore< T > Name virtual ~TimeSeriesEnsembleTimeSeriesStore () virtual PtrTSeriesEnsemblePtrType GetSeries (const string & dataId) =0 virtual PtrEnsemblePtrType GetItem (const string & dataId, size_t fcastIndex) virtual PtrSeriesType GetItem (const string & dataId, size_t fcastIndex, size_t ensIndex) virtual size_t GetEnsembleSize (const string & dataId, size_t fcastIndex) const virtual PtrEnsemblePtrType Read (const string & ensembleIdentifier) =0 virtual size_t GetLength () const =0 virtual ptime GetStart () const =0 virtual TimeStep GetTimeStep () const =0 virtual vector< string > GetIdentifiers () const Public Functions inherited from datatypes::timeseries::IdentifiersProvider Name virtual ~IdentifiersProvider () virtual vector< string > GetIdentifiers () const =0 vector< string > SplitHierarchicalIdentifier (const string & longId) string GetTopmostIdentifier (const string & longId) void CheckNotEmpty (const string & longId) Public Functions inherited from datatypes::timeseries::TimeSeriesInfoProvider Name virtual ~TimeSeriesInfoProvider () virtual size_t GetLength () const =0 virtual TimeStep GetTimeStep () const =0 virtual ptime GetStart () const =0 Public Functions inherited from datatypes::timeseries::DataDescriptor Name virtual string GetDataSummary () const =0 virtual vector< DataDimensionDescriptor > GetDataDimensionsDescription () const =0","title":"Additional inherited members"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#detailed-description","text":"template < typename T > class datatypes :: timeseries :: WritableTimeSeriesEnsembleTimeSeriesStore ;","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#using-seriestype","text":"using datatypes :: timeseries :: WritableTimeSeriesEnsembleTimeSeriesStore < T >:: SeriesType = typename CommonTypes < T >:: SeriesType ;","title":"using SeriesType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#using-ptrseriestype","text":"using datatypes :: timeseries :: WritableTimeSeriesEnsembleTimeSeriesStore < T >:: PtrSeriesType = typename CommonTypes < T >:: PtrSeriesType ;","title":"using PtrSeriesType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#using-ensembleptrtype","text":"using datatypes :: timeseries :: WritableTimeSeriesEnsembleTimeSeriesStore < T >:: EnsemblePtrType = typename CommonTypes < T >:: EnsemblePtrType ;","title":"using EnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#using-ptrensembleptrtype","text":"using datatypes :: timeseries :: WritableTimeSeriesEnsembleTimeSeriesStore < T >:: PtrEnsemblePtrType = typename CommonTypes < T >:: PtrEnsemblePtrType ;","title":"using PtrEnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#using-tseriesensembleptrtype","text":"using datatypes :: timeseries :: WritableTimeSeriesEnsembleTimeSeriesStore < T >:: TSeriesEnsemblePtrType = typename CommonTypes < T >:: TSeriesEnsemblePtrType ;","title":"using TSeriesEnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#using-ptrtseriesensembleptrtype","text":"using datatypes :: timeseries :: WritableTimeSeriesEnsembleTimeSeriesStore < T >:: PtrTSeriesEnsemblePtrType = typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType ;","title":"using PtrTSeriesEnsemblePtrType"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#function-writabletimeseriesensembletimeseriesstore","text":"inline virtual ~ WritableTimeSeriesEnsembleTimeSeriesStore ()","title":"function ~WritableTimeSeriesEnsembleTimeSeriesStore"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#function-isactive","text":"virtual bool IsActive () = 0 Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::IsActive , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::IsActive","title":"function IsActive"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#function-allocate","text":"virtual void Allocate ( size_t length , PtrEnsemblePtrType value ) = 0 Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::Allocate , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::Allocate","title":"function Allocate"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#function-allocatevalues","text":"inline void AllocateValues ( size_t length , const PtrEnsemblePtrType * values )","title":"function AllocateValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#function-allocatevalues_1","text":"inline virtual void AllocateValues ( const vector < PtrEnsemblePtrType > & values ) Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::AllocateValues , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::AllocateValues","title":"function AllocateValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#function-setseries","text":"virtual void SetSeries ( const string & dataId , PtrTSeriesEnsemblePtrType value ) = 0 Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::SetSeries , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::SetSeries","title":"function SetSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#function-setitem","text":"virtual void SetItem ( const string & dataId , size_t index , PtrEnsemblePtrType value ) = 0 Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::SetItem , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::SetItem","title":"function SetItem"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#function-setitem_1","text":"virtual void SetItem ( const string & dataId , size_t index , const EnsemblePtrType & value ) = 0 Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::SetItem , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::SetItem","title":"function SetItem"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#function-setlength","text":"virtual void SetLength ( size_t ) = 0 Reimplemented by : datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::SetLength , datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::SetLength","title":"function SetLength"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#function-setstart","text":"virtual void SetStart ( ptime ) = 0 Reimplemented by : datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::SetStart , datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::SetStart","title":"function SetStart"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1WritableTimeSeriesEnsembleTimeSeriesStore/#function-settimestep","text":"virtual void SetTimeStep ( const TimeStep & ) = 0 Reimplemented by : datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore::SetTimeStep , datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore::SetTimeStep Updated on 2022-08-20 at 19:28:22 +1000","title":"function SetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/","text":"datatypes::timeseries::io::ConfigFileHelper \u00b6 #include <time_series_io.hpp> Public Functions \u00b6 Name TimeSeriesLibraryDescription LoadTimeSeriesLibraryDescription (const string & filename, const string & dataPath =\"\", TimeSeriesSourceInfoBuilder * srcBuilder =nullptr) void SaveTimeSeriesLibraryDescription (const TimeSeriesLibraryDescription & config, const string & filename) string FileName (const YAML::Node & storage) string FullFileName (const YAML::Node & storage, const TimeSeriesLibraryDescription & tsl) Public Attributes \u00b6 Name const string FileKey const string VarKey const string IdentifierKey const string IdDataKey const string IndexKey const string TypeKey const string TimeStepKey const string StartKey const string LengthKey const string EnsembleSizeKey const string EnsembleLengthKey const string EnsembleTimeStepKey const string FilePatternKey const string MappingKey const string StorageKey const string SingleSeriesTypeId const string EnsembleSeriesTypeId const string TimeSeriesEnsemblesTypeId const string SingleSeriesCollectionTypeId const string StorageTypeSingleNetcdfFile const string StorageTypeMultipleNetcdfFiles Public Functions Documentation \u00b6 function LoadTimeSeriesLibraryDescription \u00b6 static TimeSeriesLibraryDescription LoadTimeSeriesLibraryDescription ( const string & filename , const string & dataPath = \"\" , TimeSeriesSourceInfoBuilder * srcBuilder = nullptr ) function SaveTimeSeriesLibraryDescription \u00b6 static void SaveTimeSeriesLibraryDescription ( const TimeSeriesLibraryDescription & config , const string & filename ) function FileName \u00b6 static string FileName ( const YAML :: Node & storage ) function FullFileName \u00b6 static string FullFileName ( const YAML :: Node & storage , const TimeSeriesLibraryDescription & tsl ) Public Attributes Documentation \u00b6 variable FileKey \u00b6 static const string FileKey ; variable VarKey \u00b6 static const string VarKey ; variable IdentifierKey \u00b6 static const string IdentifierKey ; variable IdDataKey \u00b6 static const string IdDataKey ; variable IndexKey \u00b6 static const string IndexKey ; variable TypeKey \u00b6 static const string TypeKey ; variable TimeStepKey \u00b6 static const string TimeStepKey ; variable StartKey \u00b6 static const string StartKey ; variable LengthKey \u00b6 static const string LengthKey ; variable EnsembleSizeKey \u00b6 static const string EnsembleSizeKey ; variable EnsembleLengthKey \u00b6 static const string EnsembleLengthKey ; variable EnsembleTimeStepKey \u00b6 static const string EnsembleTimeStepKey ; variable FilePatternKey \u00b6 static const string FilePatternKey ; variable MappingKey \u00b6 static const string MappingKey ; variable StorageKey \u00b6 static const string StorageKey ; variable SingleSeriesTypeId \u00b6 static const string SingleSeriesTypeId ; variable EnsembleSeriesTypeId \u00b6 static const string EnsembleSeriesTypeId ; variable TimeSeriesEnsemblesTypeId \u00b6 static const string TimeSeriesEnsemblesTypeId ; variable SingleSeriesCollectionTypeId \u00b6 static const string SingleSeriesCollectionTypeId ; variable StorageTypeSingleNetcdfFile \u00b6 static const string StorageTypeSingleNetcdfFile ; variable StorageTypeMultipleNetcdfFiles \u00b6 static const string StorageTypeMultipleNetcdfFiles ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::io::ConfigFileHelper"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#datatypestimeseriesioconfigfilehelper","text":"#include <time_series_io.hpp>","title":"datatypes::timeseries::io::ConfigFileHelper"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#public-functions","text":"Name TimeSeriesLibraryDescription LoadTimeSeriesLibraryDescription (const string & filename, const string & dataPath =\"\", TimeSeriesSourceInfoBuilder * srcBuilder =nullptr) void SaveTimeSeriesLibraryDescription (const TimeSeriesLibraryDescription & config, const string & filename) string FileName (const YAML::Node & storage) string FullFileName (const YAML::Node & storage, const TimeSeriesLibraryDescription & tsl)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#public-attributes","text":"Name const string FileKey const string VarKey const string IdentifierKey const string IdDataKey const string IndexKey const string TypeKey const string TimeStepKey const string StartKey const string LengthKey const string EnsembleSizeKey const string EnsembleLengthKey const string EnsembleTimeStepKey const string FilePatternKey const string MappingKey const string StorageKey const string SingleSeriesTypeId const string EnsembleSeriesTypeId const string TimeSeriesEnsemblesTypeId const string SingleSeriesCollectionTypeId const string StorageTypeSingleNetcdfFile const string StorageTypeMultipleNetcdfFiles","title":"Public Attributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#function-loadtimeserieslibrarydescription","text":"static TimeSeriesLibraryDescription LoadTimeSeriesLibraryDescription ( const string & filename , const string & dataPath = \"\" , TimeSeriesSourceInfoBuilder * srcBuilder = nullptr )","title":"function LoadTimeSeriesLibraryDescription"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#function-savetimeserieslibrarydescription","text":"static void SaveTimeSeriesLibraryDescription ( const TimeSeriesLibraryDescription & config , const string & filename )","title":"function SaveTimeSeriesLibraryDescription"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#function-filename","text":"static string FileName ( const YAML :: Node & storage )","title":"function FileName"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#function-fullfilename","text":"static string FullFileName ( const YAML :: Node & storage , const TimeSeriesLibraryDescription & tsl )","title":"function FullFileName"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#variable-filekey","text":"static const string FileKey ;","title":"variable FileKey"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#variable-varkey","text":"static const string VarKey ;","title":"variable VarKey"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#variable-identifierkey","text":"static const string IdentifierKey ;","title":"variable IdentifierKey"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#variable-iddatakey","text":"static const string IdDataKey ;","title":"variable IdDataKey"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#variable-indexkey","text":"static const string IndexKey ;","title":"variable IndexKey"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#variable-typekey","text":"static const string TypeKey ;","title":"variable TypeKey"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#variable-timestepkey","text":"static const string TimeStepKey ;","title":"variable TimeStepKey"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#variable-startkey","text":"static const string StartKey ;","title":"variable StartKey"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#variable-lengthkey","text":"static const string LengthKey ;","title":"variable LengthKey"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#variable-ensemblesizekey","text":"static const string EnsembleSizeKey ;","title":"variable EnsembleSizeKey"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#variable-ensemblelengthkey","text":"static const string EnsembleLengthKey ;","title":"variable EnsembleLengthKey"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#variable-ensembletimestepkey","text":"static const string EnsembleTimeStepKey ;","title":"variable EnsembleTimeStepKey"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#variable-filepatternkey","text":"static const string FilePatternKey ;","title":"variable FilePatternKey"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#variable-mappingkey","text":"static const string MappingKey ;","title":"variable MappingKey"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#variable-storagekey","text":"static const string StorageKey ;","title":"variable StorageKey"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#variable-singleseriestypeid","text":"static const string SingleSeriesTypeId ;","title":"variable SingleSeriesTypeId"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#variable-ensembleseriestypeid","text":"static const string EnsembleSeriesTypeId ;","title":"variable EnsembleSeriesTypeId"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#variable-timeseriesensemblestypeid","text":"static const string TimeSeriesEnsemblesTypeId ;","title":"variable TimeSeriesEnsemblesTypeId"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#variable-singleseriescollectiontypeid","text":"static const string SingleSeriesCollectionTypeId ;","title":"variable SingleSeriesCollectionTypeId"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#variable-storagetypesinglenetcdffile","text":"static const string StorageTypeSingleNetcdfFile ;","title":"variable StorageTypeSingleNetcdfFile"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1ConfigFileHelper/#variable-storagetypemultiplenetcdffiles","text":"static const string StorageTypeMultipleNetcdfFiles ; Updated on 2022-08-20 at 19:28:22 +1000","title":"variable StorageTypeMultipleNetcdfFiles"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/","text":"datatypes::timeseries::io::SwiftNetCDFAccess \u00b6 Class responsible for the low-level read/write operations from/to a SWIFT netCDF file. #include <time_series_io.hpp> Public Functions \u00b6 Name SwiftNetCDFAccess (const string & filename, bool lazyLoad =false) Constructor to wrap an existing SWIFT netCDF file. SwiftNetCDFAccess (const string & filename, const size_t nEns, const vector< double > & leadTimeVar, const string & timeUnits, const vector< double > & timeVar, const vector< string > & stationIds, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & leadTimeUnits =\"\") ** SwiftNetCDFAccess (const string & filename, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes) ~SwiftNetCDFAccess () size_t GetEnsembleSize () Gets ensemble size. size_t GetEnsembleSize (const string & ncVarName) size_t GetLeadTimeCount () Gets the lengths of the lead time dimension. size_t GetLeadTimeCount (const string & ncVarName) size_t GetTimeLength () const Gets the lengths of the main time dimension. vector< ptime > GetTimeDim () Gets the vector with the values of the main time dimension. ptime GetStart () Gets the first time in the main time dimension of this netCDF data set. ptime GetEnd () Gets the last time in the main time dimension of this netCDF data set. size_t IndexForIdentifier (const string & identifier) const Corresponding index for a string identifier for a variable in this data set. size_t GetNumIdentifiers () const vector< string > GetIdentifiers () const ptime TimeForIndex (size_t timeIndex) Time value for an index of the time dimension. template <typename ElementType > vector< ElementType * > * GetForecasts (const string & varName, size_t stationIndex, size_t timeIndex) Gets the values of an ensemble forecast for a variable, for a starting date in the main time dimension. template <typename ElementType > vector< ElementType * > * GetEnsemble (const string & varName, size_t stationIndex) template <typename ElementType > vector< ElementType > GetValues (const string & varName, size_t stationIndex) Gets the values of a variable stored as an non-ensemble series. template <typename ElementType > vector< ElementType > GetValues (const string & varName) template <typename ElementType > TTimeSeries < ElementType > * GetSeries (const string & varName, size_t stationIndex) template <typename ElementType > MultiTimeSeries < TTimeSeries < ElementType > * > * GetSeries (const string & varName) template <typename ElementType > MultiTimeSeries < TTimeSeries < ElementType > * > * GetEnsembleSeries (const string & varName, size_t stationIndex) template <typename ElementType > void SetForecasts (const string & varName, size_t stationIndex, size_t timeIndex, vector< ElementType * > & values) Sets the values for an ensemble forecast, for a variable, for a starting date in the main time dimension. template <typename ElementType > void SetEnsembles (const string & varName, size_t stationIndex, vector< ElementType * > & values) template <typename ElementType > void SetValues (const string & varName, size_t stationIndex, const vector< ElementType > & values) template <typename ElementType > void SetValues (const string & varName, const vector< ElementType > & values) vector< int > GetVarDims (int varNumDims) vector< int > GetVarDims (const string & varName) vector< string > ReadVariableNames (bool removeDimVars =true) vector< string > ReadAttributeNames (const string & varName) string ReadStringAttribute (int varId, const string & attName, bool throwIfNotFound =false, string defaultValue =\"\") string ReadStringAttribute (const string & varName, const string & attName, bool throwIfNotFound =false, string defaultValue =\"\") double ReadNumericAttribute (int varId, const string & attName, bool throwIfNotFound =false, double defaultValue =0.0) double ReadNumericAttribute (const string & varName, const string & attName, bool throwIfNotFound =false, double defaultValue =0.0) VariableAttributes ReadAttributes (const string & varName) GlobalAttributes ReadGlobalAttributes () TimeStep GetTimeStep () TimeStep GetLeadTimeStep () std::pair< ptime, TimeStep > GetLeadTimeGeometry (const ptime & issueTime) vector< double > GetLeadTimeDim () GlobalAttributes GetGlobalAttributes () VariableAttributes GetAttributes (const string & varName) void CheckCompliance (const string & filename, int majorVersion, int minorVersion, vector< string > & warnings, vector< string > & errors) template <typename ElementType > string CreateTimeUnitsAttribute (const TTimeSeries < ElementType > & tSeries) std::pair< vector< double >, vector< double > > CreateTimeVectors (const ptime & start, const TimeStep & timeStep, size_t tsLength, const TimeStep & leadTimeStep, size_t leadTimeSize, int fcastOffset =1) vector< double > CreateTimeVector (const ptime & start, const TimeStep & timeStep, const ptime & origin, const time_duration & timeStepAxis, const size_t length) vector< double > CreateTimeVector (const ptime & start, const TimeStep & timeStep, const ptime & origin, const TimeStep & timeStepAxis, const size_t length) vector< double > CreateTimeVector (const ptime & start, const TimeStep & timeStep, const size_t length) template <typename ElementType > vector< double > CreateTimeVector (const TTimeSeries < ElementType > & tSeries) template <typename ElementType > vector< double > CreateTimeVector (const TTimeSeries < ElementType > & tSeries, const ptime & origin, const TimeStep & timeStepAxis) template <typename T > ptime StartCoordinate (const ptime & origin, const TimeStep & timeStep, const vector< T > & timeCoords) std::pair< ptime, TimeStep > CreateTimeGeometry (const string & axisDefinition, const vector< double > & timeCoords) string GetTimeStepName (const TimeStep & timeStep) string CreateTimeUnitsAttribute (const ptime & utcStart, const string & units) string CreateTimeUnitsAttribute (const ptime & utcStart, const TimeStep & timeStep) ptime ParseStartDate (const string & unitsAttribute) string ParseTimeUnits (const string & unitsAttribute) string CreateLeadTimeUnitsAttribute (const TimeStep & timeStep) template <class TFrom ,class TTo > vector< TTo > Convert (const vector< TFrom > & from, const std::function< TTo(const TFrom &)> & f) time_duration CreateTimeUnits (const TimeStep & timeStep) void SetTimeOffsetIn (const time_duration & td) void SetTimeOffsetOut (const time_duration & td) Public Attributes \u00b6 Name time_duration TimeOffsetIn time_duration TimeOffsetOut Public Functions Documentation \u00b6 function SwiftNetCDFAccess \u00b6 SwiftNetCDFAccess ( const string & filename , bool lazyLoad = false ) Constructor to wrap an existing SWIFT netCDF file. Parameters : filename SWIFT netCDF file. function SwiftNetCDFAccess \u00b6 SwiftNetCDFAccess ( const string & filename , const size_t nEns , const vector < double > & leadTimeVar , const string & timeUnits , const vector < double > & timeVar , const vector < string > & stationIds , const std :: map < string , VariableDefinition > & varDefinitions , const GlobalAttributes & globalAttributes , const string & leadTimeUnits = \"\" ) ** function SwiftNetCDFAccess \u00b6 SwiftNetCDFAccess ( const string & filename , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition > & varDefinitions , const GlobalAttributes & globalAttributes ) function ~SwiftNetCDFAccess \u00b6 ~ SwiftNetCDFAccess () function GetEnsembleSize \u00b6 size_t GetEnsembleSize () Gets ensemble size. Return : The ensemble size. function GetEnsembleSize \u00b6 size_t GetEnsembleSize ( const string & ncVarName ) function GetLeadTimeCount \u00b6 size_t GetLeadTimeCount () Gets the lengths of the lead time dimension. Return : The lead time length. function GetLeadTimeCount \u00b6 size_t GetLeadTimeCount ( const string & ncVarName ) function GetTimeLength \u00b6 size_t GetTimeLength () const Gets the lengths of the main time dimension. Return : The time length. function GetTimeDim \u00b6 vector < ptime > GetTimeDim () Gets the vector with the values of the main time dimension. Return : the values of the main time dimension function GetStart \u00b6 ptime GetStart () Gets the first time in the main time dimension of this netCDF data set. Return : The start date of the data set. function GetEnd \u00b6 ptime GetEnd () Gets the last time in the main time dimension of this netCDF data set. Return : The end date of the data set. function IndexForIdentifier \u00b6 size_t IndexForIdentifier ( const string & identifier ) const Corresponding index for a string identifier for a variable in this data set. Parameters : identifier The identifier. Return : An int. function GetNumIdentifiers \u00b6 size_t GetNumIdentifiers () const function GetIdentifiers \u00b6 vector < string > GetIdentifiers () const function TimeForIndex \u00b6 ptime TimeForIndex ( size_t timeIndex ) Time value for an index of the time dimension. Parameters : timeIndex Zero-based index of the time. Return : A ptime. function GetForecasts \u00b6 template < typename ElementType > inline vector < ElementType * > * GetForecasts ( const string & varName , size_t stationIndex , size_t timeIndex ) Gets the values of an ensemble forecast for a variable, for a starting date in the main time dimension. Parameters : varName Name of the variable. stationIndex The catchment number. timeIndex Zero-based index of the time dimension. Template Parameters : ElementType type of element expected for this variable. Return : null if it fails, else the forecasts. function GetEnsemble \u00b6 template < typename ElementType > inline vector < ElementType * > * GetEnsemble ( const string & varName , size_t stationIndex ) function GetValues \u00b6 template < typename ElementType > inline vector < ElementType > GetValues ( const string & varName , size_t stationIndex ) Gets the values of a variable stored as an non-ensemble series. Parameters : varName Name of the variable. stationIndex The catchment number. Template Parameters : ElementType type of element expected for this variable. Return : All the values for the time series defined with this variable name. function GetValues \u00b6 template < typename ElementType > inline vector < ElementType > GetValues ( const string & varName ) function GetSeries \u00b6 template < typename ElementType > inline TTimeSeries < ElementType > * GetSeries ( const string & varName , size_t stationIndex ) function GetSeries \u00b6 template < typename ElementType > inline MultiTimeSeries < TTimeSeries < ElementType > * > * GetSeries ( const string & varName ) function GetEnsembleSeries \u00b6 template < typename ElementType > inline MultiTimeSeries < TTimeSeries < ElementType > * > * GetEnsembleSeries ( const string & varName , size_t stationIndex ) function SetForecasts \u00b6 template < typename ElementType > inline void SetForecasts ( const string & varName , size_t stationIndex , size_t timeIndex , vector < ElementType * > & values ) Sets the values for an ensemble forecast, for a variable, for a starting date in the main time dimension. Parameters : varName Name of the variable. stationIndex The catchment number. timeIndex Zero-based index of the time. values [in] the values to write to file. Template Parameters : ElementType type of element expected for this variable. function SetEnsembles \u00b6 template < typename ElementType > inline void SetEnsembles ( const string & varName , size_t stationIndex , vector < ElementType * > & values ) function SetValues \u00b6 template < typename ElementType > inline void SetValues ( const string & varName , size_t stationIndex , const vector < ElementType > & values ) function SetValues \u00b6 template < typename ElementType > inline void SetValues ( const string & varName , const vector < ElementType > & values ) function GetVarDims \u00b6 vector < int > GetVarDims ( int varNumDims ) function GetVarDims \u00b6 vector < int > GetVarDims ( const string & varName ) function ReadVariableNames \u00b6 vector < string > ReadVariableNames ( bool removeDimVars = true ) function ReadAttributeNames \u00b6 vector < string > ReadAttributeNames ( const string & varName ) function ReadStringAttribute \u00b6 string ReadStringAttribute ( int varId , const string & attName , bool throwIfNotFound = false , string defaultValue = \"\" ) function ReadStringAttribute \u00b6 string ReadStringAttribute ( const string & varName , const string & attName , bool throwIfNotFound = false , string defaultValue = \"\" ) function ReadNumericAttribute \u00b6 double ReadNumericAttribute ( int varId , const string & attName , bool throwIfNotFound = false , double defaultValue = 0.0 ) function ReadNumericAttribute \u00b6 double ReadNumericAttribute ( const string & varName , const string & attName , bool throwIfNotFound = false , double defaultValue = 0.0 ) function ReadAttributes \u00b6 VariableAttributes ReadAttributes ( const string & varName ) function ReadGlobalAttributes \u00b6 GlobalAttributes ReadGlobalAttributes () function GetTimeStep \u00b6 TimeStep GetTimeStep () function GetLeadTimeStep \u00b6 TimeStep GetLeadTimeStep () function GetLeadTimeGeometry \u00b6 std :: pair < ptime , TimeStep > GetLeadTimeGeometry ( const ptime & issueTime ) function GetLeadTimeDim \u00b6 vector < double > GetLeadTimeDim () function GetGlobalAttributes \u00b6 GlobalAttributes GetGlobalAttributes () function GetAttributes \u00b6 VariableAttributes GetAttributes ( const string & varName ) function CheckCompliance \u00b6 static void CheckCompliance ( const string & filename , int majorVersion , int minorVersion , vector < string > & warnings , vector < string > & errors ) function CreateTimeUnitsAttribute \u00b6 template < typename ElementType > static inline string CreateTimeUnitsAttribute ( const TTimeSeries < ElementType > & tSeries ) function CreateTimeVectors \u00b6 static std :: pair < vector < double > , vector < double > > CreateTimeVectors ( const ptime & start , const TimeStep & timeStep , size_t tsLength , const TimeStep & leadTimeStep , size_t leadTimeSize , int fcastOffset = 1 ) function CreateTimeVector \u00b6 static vector < double > CreateTimeVector ( const ptime & start , const TimeStep & timeStep , const ptime & origin , const time_duration & timeStepAxis , const size_t length ) function CreateTimeVector \u00b6 static vector < double > CreateTimeVector ( const ptime & start , const TimeStep & timeStep , const ptime & origin , const TimeStep & timeStepAxis , const size_t length ) function CreateTimeVector \u00b6 static vector < double > CreateTimeVector ( const ptime & start , const TimeStep & timeStep , const size_t length ) function CreateTimeVector \u00b6 template < typename ElementType > static inline vector < double > CreateTimeVector ( const TTimeSeries < ElementType > & tSeries ) function CreateTimeVector \u00b6 template < typename ElementType > static inline vector < double > CreateTimeVector ( const TTimeSeries < ElementType > & tSeries , const ptime & origin , const TimeStep & timeStepAxis ) function StartCoordinate \u00b6 template < typename T > static inline ptime StartCoordinate ( const ptime & origin , const TimeStep & timeStep , const vector < T > & timeCoords ) function CreateTimeGeometry \u00b6 static std :: pair < ptime , TimeStep > CreateTimeGeometry ( const string & axisDefinition , const vector < double > & timeCoords ) function GetTimeStepName \u00b6 static string GetTimeStepName ( const TimeStep & timeStep ) function CreateTimeUnitsAttribute \u00b6 static string CreateTimeUnitsAttribute ( const ptime & utcStart , const string & units ) function CreateTimeUnitsAttribute \u00b6 static string CreateTimeUnitsAttribute ( const ptime & utcStart , const TimeStep & timeStep ) function ParseStartDate \u00b6 static ptime ParseStartDate ( const string & unitsAttribute ) function ParseTimeUnits \u00b6 static string ParseTimeUnits ( const string & unitsAttribute ) function CreateLeadTimeUnitsAttribute \u00b6 static string CreateLeadTimeUnitsAttribute ( const TimeStep & timeStep ) function Convert \u00b6 template < class TFrom , class TTo > static inline vector < TTo > Convert ( const vector < TFrom > & from , const std :: function < TTo ( const TFrom & ) > & f ) function CreateTimeUnits \u00b6 static time_duration CreateTimeUnits ( const TimeStep & timeStep ) function SetTimeOffsetIn \u00b6 static void SetTimeOffsetIn ( const time_duration & td ) function SetTimeOffsetOut \u00b6 static void SetTimeOffsetOut ( const time_duration & td ) Public Attributes Documentation \u00b6 variable TimeOffsetIn \u00b6 static time_duration TimeOffsetIn ; variable TimeOffsetOut \u00b6 static time_duration TimeOffsetOut ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::io::SwiftNetCDFAccess"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#datatypestimeseriesioswiftnetcdfaccess","text":"Class responsible for the low-level read/write operations from/to a SWIFT netCDF file. #include <time_series_io.hpp>","title":"datatypes::timeseries::io::SwiftNetCDFAccess"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#public-functions","text":"Name SwiftNetCDFAccess (const string & filename, bool lazyLoad =false) Constructor to wrap an existing SWIFT netCDF file. SwiftNetCDFAccess (const string & filename, const size_t nEns, const vector< double > & leadTimeVar, const string & timeUnits, const vector< double > & timeVar, const vector< string > & stationIds, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes, const string & leadTimeUnits =\"\") ** SwiftNetCDFAccess (const string & filename, const DimensionsDefinitions & dimDefinitions, const std::map< string, VariableDefinition > & varDefinitions, const GlobalAttributes & globalAttributes) ~SwiftNetCDFAccess () size_t GetEnsembleSize () Gets ensemble size. size_t GetEnsembleSize (const string & ncVarName) size_t GetLeadTimeCount () Gets the lengths of the lead time dimension. size_t GetLeadTimeCount (const string & ncVarName) size_t GetTimeLength () const Gets the lengths of the main time dimension. vector< ptime > GetTimeDim () Gets the vector with the values of the main time dimension. ptime GetStart () Gets the first time in the main time dimension of this netCDF data set. ptime GetEnd () Gets the last time in the main time dimension of this netCDF data set. size_t IndexForIdentifier (const string & identifier) const Corresponding index for a string identifier for a variable in this data set. size_t GetNumIdentifiers () const vector< string > GetIdentifiers () const ptime TimeForIndex (size_t timeIndex) Time value for an index of the time dimension. template <typename ElementType > vector< ElementType * > * GetForecasts (const string & varName, size_t stationIndex, size_t timeIndex) Gets the values of an ensemble forecast for a variable, for a starting date in the main time dimension. template <typename ElementType > vector< ElementType * > * GetEnsemble (const string & varName, size_t stationIndex) template <typename ElementType > vector< ElementType > GetValues (const string & varName, size_t stationIndex) Gets the values of a variable stored as an non-ensemble series. template <typename ElementType > vector< ElementType > GetValues (const string & varName) template <typename ElementType > TTimeSeries < ElementType > * GetSeries (const string & varName, size_t stationIndex) template <typename ElementType > MultiTimeSeries < TTimeSeries < ElementType > * > * GetSeries (const string & varName) template <typename ElementType > MultiTimeSeries < TTimeSeries < ElementType > * > * GetEnsembleSeries (const string & varName, size_t stationIndex) template <typename ElementType > void SetForecasts (const string & varName, size_t stationIndex, size_t timeIndex, vector< ElementType * > & values) Sets the values for an ensemble forecast, for a variable, for a starting date in the main time dimension. template <typename ElementType > void SetEnsembles (const string & varName, size_t stationIndex, vector< ElementType * > & values) template <typename ElementType > void SetValues (const string & varName, size_t stationIndex, const vector< ElementType > & values) template <typename ElementType > void SetValues (const string & varName, const vector< ElementType > & values) vector< int > GetVarDims (int varNumDims) vector< int > GetVarDims (const string & varName) vector< string > ReadVariableNames (bool removeDimVars =true) vector< string > ReadAttributeNames (const string & varName) string ReadStringAttribute (int varId, const string & attName, bool throwIfNotFound =false, string defaultValue =\"\") string ReadStringAttribute (const string & varName, const string & attName, bool throwIfNotFound =false, string defaultValue =\"\") double ReadNumericAttribute (int varId, const string & attName, bool throwIfNotFound =false, double defaultValue =0.0) double ReadNumericAttribute (const string & varName, const string & attName, bool throwIfNotFound =false, double defaultValue =0.0) VariableAttributes ReadAttributes (const string & varName) GlobalAttributes ReadGlobalAttributes () TimeStep GetTimeStep () TimeStep GetLeadTimeStep () std::pair< ptime, TimeStep > GetLeadTimeGeometry (const ptime & issueTime) vector< double > GetLeadTimeDim () GlobalAttributes GetGlobalAttributes () VariableAttributes GetAttributes (const string & varName) void CheckCompliance (const string & filename, int majorVersion, int minorVersion, vector< string > & warnings, vector< string > & errors) template <typename ElementType > string CreateTimeUnitsAttribute (const TTimeSeries < ElementType > & tSeries) std::pair< vector< double >, vector< double > > CreateTimeVectors (const ptime & start, const TimeStep & timeStep, size_t tsLength, const TimeStep & leadTimeStep, size_t leadTimeSize, int fcastOffset =1) vector< double > CreateTimeVector (const ptime & start, const TimeStep & timeStep, const ptime & origin, const time_duration & timeStepAxis, const size_t length) vector< double > CreateTimeVector (const ptime & start, const TimeStep & timeStep, const ptime & origin, const TimeStep & timeStepAxis, const size_t length) vector< double > CreateTimeVector (const ptime & start, const TimeStep & timeStep, const size_t length) template <typename ElementType > vector< double > CreateTimeVector (const TTimeSeries < ElementType > & tSeries) template <typename ElementType > vector< double > CreateTimeVector (const TTimeSeries < ElementType > & tSeries, const ptime & origin, const TimeStep & timeStepAxis) template <typename T > ptime StartCoordinate (const ptime & origin, const TimeStep & timeStep, const vector< T > & timeCoords) std::pair< ptime, TimeStep > CreateTimeGeometry (const string & axisDefinition, const vector< double > & timeCoords) string GetTimeStepName (const TimeStep & timeStep) string CreateTimeUnitsAttribute (const ptime & utcStart, const string & units) string CreateTimeUnitsAttribute (const ptime & utcStart, const TimeStep & timeStep) ptime ParseStartDate (const string & unitsAttribute) string ParseTimeUnits (const string & unitsAttribute) string CreateLeadTimeUnitsAttribute (const TimeStep & timeStep) template <class TFrom ,class TTo > vector< TTo > Convert (const vector< TFrom > & from, const std::function< TTo(const TFrom &)> & f) time_duration CreateTimeUnits (const TimeStep & timeStep) void SetTimeOffsetIn (const time_duration & td) void SetTimeOffsetOut (const time_duration & td)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#public-attributes","text":"Name time_duration TimeOffsetIn time_duration TimeOffsetOut","title":"Public Attributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-swiftnetcdfaccess","text":"SwiftNetCDFAccess ( const string & filename , bool lazyLoad = false ) Constructor to wrap an existing SWIFT netCDF file. Parameters : filename SWIFT netCDF file.","title":"function SwiftNetCDFAccess"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-swiftnetcdfaccess_1","text":"SwiftNetCDFAccess ( const string & filename , const size_t nEns , const vector < double > & leadTimeVar , const string & timeUnits , const vector < double > & timeVar , const vector < string > & stationIds , const std :: map < string , VariableDefinition > & varDefinitions , const GlobalAttributes & globalAttributes , const string & leadTimeUnits = \"\" ) **","title":"function SwiftNetCDFAccess"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-swiftnetcdfaccess_2","text":"SwiftNetCDFAccess ( const string & filename , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition > & varDefinitions , const GlobalAttributes & globalAttributes )","title":"function SwiftNetCDFAccess"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-swiftnetcdfaccess_3","text":"~ SwiftNetCDFAccess ()","title":"function ~SwiftNetCDFAccess"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-getensemblesize","text":"size_t GetEnsembleSize () Gets ensemble size. Return : The ensemble size.","title":"function GetEnsembleSize"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-getensemblesize_1","text":"size_t GetEnsembleSize ( const string & ncVarName )","title":"function GetEnsembleSize"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-getleadtimecount","text":"size_t GetLeadTimeCount () Gets the lengths of the lead time dimension. Return : The lead time length.","title":"function GetLeadTimeCount"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-getleadtimecount_1","text":"size_t GetLeadTimeCount ( const string & ncVarName )","title":"function GetLeadTimeCount"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-gettimelength","text":"size_t GetTimeLength () const Gets the lengths of the main time dimension. Return : The time length.","title":"function GetTimeLength"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-gettimedim","text":"vector < ptime > GetTimeDim () Gets the vector with the values of the main time dimension. Return : the values of the main time dimension","title":"function GetTimeDim"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-getstart","text":"ptime GetStart () Gets the first time in the main time dimension of this netCDF data set. Return : The start date of the data set.","title":"function GetStart"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-getend","text":"ptime GetEnd () Gets the last time in the main time dimension of this netCDF data set. Return : The end date of the data set.","title":"function GetEnd"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-indexforidentifier","text":"size_t IndexForIdentifier ( const string & identifier ) const Corresponding index for a string identifier for a variable in this data set. Parameters : identifier The identifier. Return : An int.","title":"function IndexForIdentifier"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-getnumidentifiers","text":"size_t GetNumIdentifiers () const","title":"function GetNumIdentifiers"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-getidentifiers","text":"vector < string > GetIdentifiers () const","title":"function GetIdentifiers"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-timeforindex","text":"ptime TimeForIndex ( size_t timeIndex ) Time value for an index of the time dimension. Parameters : timeIndex Zero-based index of the time. Return : A ptime.","title":"function TimeForIndex"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-getforecasts","text":"template < typename ElementType > inline vector < ElementType * > * GetForecasts ( const string & varName , size_t stationIndex , size_t timeIndex ) Gets the values of an ensemble forecast for a variable, for a starting date in the main time dimension. Parameters : varName Name of the variable. stationIndex The catchment number. timeIndex Zero-based index of the time dimension. Template Parameters : ElementType type of element expected for this variable. Return : null if it fails, else the forecasts.","title":"function GetForecasts"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-getensemble","text":"template < typename ElementType > inline vector < ElementType * > * GetEnsemble ( const string & varName , size_t stationIndex )","title":"function GetEnsemble"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-getvalues","text":"template < typename ElementType > inline vector < ElementType > GetValues ( const string & varName , size_t stationIndex ) Gets the values of a variable stored as an non-ensemble series. Parameters : varName Name of the variable. stationIndex The catchment number. Template Parameters : ElementType type of element expected for this variable. Return : All the values for the time series defined with this variable name.","title":"function GetValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-getvalues_1","text":"template < typename ElementType > inline vector < ElementType > GetValues ( const string & varName )","title":"function GetValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-getseries","text":"template < typename ElementType > inline TTimeSeries < ElementType > * GetSeries ( const string & varName , size_t stationIndex )","title":"function GetSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-getseries_1","text":"template < typename ElementType > inline MultiTimeSeries < TTimeSeries < ElementType > * > * GetSeries ( const string & varName )","title":"function GetSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-getensembleseries","text":"template < typename ElementType > inline MultiTimeSeries < TTimeSeries < ElementType > * > * GetEnsembleSeries ( const string & varName , size_t stationIndex )","title":"function GetEnsembleSeries"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-setforecasts","text":"template < typename ElementType > inline void SetForecasts ( const string & varName , size_t stationIndex , size_t timeIndex , vector < ElementType * > & values ) Sets the values for an ensemble forecast, for a variable, for a starting date in the main time dimension. Parameters : varName Name of the variable. stationIndex The catchment number. timeIndex Zero-based index of the time. values [in] the values to write to file. Template Parameters : ElementType type of element expected for this variable.","title":"function SetForecasts"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-setensembles","text":"template < typename ElementType > inline void SetEnsembles ( const string & varName , size_t stationIndex , vector < ElementType * > & values )","title":"function SetEnsembles"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-setvalues","text":"template < typename ElementType > inline void SetValues ( const string & varName , size_t stationIndex , const vector < ElementType > & values )","title":"function SetValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-setvalues_1","text":"template < typename ElementType > inline void SetValues ( const string & varName , const vector < ElementType > & values )","title":"function SetValues"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-getvardims","text":"vector < int > GetVarDims ( int varNumDims )","title":"function GetVarDims"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-getvardims_1","text":"vector < int > GetVarDims ( const string & varName )","title":"function GetVarDims"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-readvariablenames","text":"vector < string > ReadVariableNames ( bool removeDimVars = true )","title":"function ReadVariableNames"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-readattributenames","text":"vector < string > ReadAttributeNames ( const string & varName )","title":"function ReadAttributeNames"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-readstringattribute","text":"string ReadStringAttribute ( int varId , const string & attName , bool throwIfNotFound = false , string defaultValue = \"\" )","title":"function ReadStringAttribute"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-readstringattribute_1","text":"string ReadStringAttribute ( const string & varName , const string & attName , bool throwIfNotFound = false , string defaultValue = \"\" )","title":"function ReadStringAttribute"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-readnumericattribute","text":"double ReadNumericAttribute ( int varId , const string & attName , bool throwIfNotFound = false , double defaultValue = 0.0 )","title":"function ReadNumericAttribute"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-readnumericattribute_1","text":"double ReadNumericAttribute ( const string & varName , const string & attName , bool throwIfNotFound = false , double defaultValue = 0.0 )","title":"function ReadNumericAttribute"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-readattributes","text":"VariableAttributes ReadAttributes ( const string & varName )","title":"function ReadAttributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-readglobalattributes","text":"GlobalAttributes ReadGlobalAttributes ()","title":"function ReadGlobalAttributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-gettimestep","text":"TimeStep GetTimeStep ()","title":"function GetTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-getleadtimestep","text":"TimeStep GetLeadTimeStep ()","title":"function GetLeadTimeStep"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-getleadtimegeometry","text":"std :: pair < ptime , TimeStep > GetLeadTimeGeometry ( const ptime & issueTime )","title":"function GetLeadTimeGeometry"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-getleadtimedim","text":"vector < double > GetLeadTimeDim ()","title":"function GetLeadTimeDim"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-getglobalattributes","text":"GlobalAttributes GetGlobalAttributes ()","title":"function GetGlobalAttributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-getattributes","text":"VariableAttributes GetAttributes ( const string & varName )","title":"function GetAttributes"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-checkcompliance","text":"static void CheckCompliance ( const string & filename , int majorVersion , int minorVersion , vector < string > & warnings , vector < string > & errors )","title":"function CheckCompliance"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-createtimeunitsattribute","text":"template < typename ElementType > static inline string CreateTimeUnitsAttribute ( const TTimeSeries < ElementType > & tSeries )","title":"function CreateTimeUnitsAttribute"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-createtimevectors","text":"static std :: pair < vector < double > , vector < double > > CreateTimeVectors ( const ptime & start , const TimeStep & timeStep , size_t tsLength , const TimeStep & leadTimeStep , size_t leadTimeSize , int fcastOffset = 1 )","title":"function CreateTimeVectors"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-createtimevector","text":"static vector < double > CreateTimeVector ( const ptime & start , const TimeStep & timeStep , const ptime & origin , const time_duration & timeStepAxis , const size_t length )","title":"function CreateTimeVector"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-createtimevector_1","text":"static vector < double > CreateTimeVector ( const ptime & start , const TimeStep & timeStep , const ptime & origin , const TimeStep & timeStepAxis , const size_t length )","title":"function CreateTimeVector"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-createtimevector_2","text":"static vector < double > CreateTimeVector ( const ptime & start , const TimeStep & timeStep , const size_t length )","title":"function CreateTimeVector"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-createtimevector_3","text":"template < typename ElementType > static inline vector < double > CreateTimeVector ( const TTimeSeries < ElementType > & tSeries )","title":"function CreateTimeVector"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-createtimevector_4","text":"template < typename ElementType > static inline vector < double > CreateTimeVector ( const TTimeSeries < ElementType > & tSeries , const ptime & origin , const TimeStep & timeStepAxis )","title":"function CreateTimeVector"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-startcoordinate","text":"template < typename T > static inline ptime StartCoordinate ( const ptime & origin , const TimeStep & timeStep , const vector < T > & timeCoords )","title":"function StartCoordinate"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-createtimegeometry","text":"static std :: pair < ptime , TimeStep > CreateTimeGeometry ( const string & axisDefinition , const vector < double > & timeCoords )","title":"function CreateTimeGeometry"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-gettimestepname","text":"static string GetTimeStepName ( const TimeStep & timeStep )","title":"function GetTimeStepName"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-createtimeunitsattribute_1","text":"static string CreateTimeUnitsAttribute ( const ptime & utcStart , const string & units )","title":"function CreateTimeUnitsAttribute"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-createtimeunitsattribute_2","text":"static string CreateTimeUnitsAttribute ( const ptime & utcStart , const TimeStep & timeStep )","title":"function CreateTimeUnitsAttribute"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-parsestartdate","text":"static ptime ParseStartDate ( const string & unitsAttribute )","title":"function ParseStartDate"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-parsetimeunits","text":"static string ParseTimeUnits ( const string & unitsAttribute )","title":"function ParseTimeUnits"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-createleadtimeunitsattribute","text":"static string CreateLeadTimeUnitsAttribute ( const TimeStep & timeStep )","title":"function CreateLeadTimeUnitsAttribute"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-convert","text":"template < class TFrom , class TTo > static inline vector < TTo > Convert ( const vector < TFrom > & from , const std :: function < TTo ( const TFrom & ) > & f )","title":"function Convert"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-createtimeunits","text":"static time_duration CreateTimeUnits ( const TimeStep & timeStep )","title":"function CreateTimeUnits"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-settimeoffsetin","text":"static void SetTimeOffsetIn ( const time_duration & td )","title":"function SetTimeOffsetIn"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#function-settimeoffsetout","text":"static void SetTimeOffsetOut ( const time_duration & td )","title":"function SetTimeOffsetOut"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#variable-timeoffsetin","text":"static time_duration TimeOffsetIn ;","title":"variable TimeOffsetIn"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFAccess/#variable-timeoffsetout","text":"static time_duration TimeOffsetOut ; Updated on 2022-08-20 at 19:28:22 +1000","title":"variable TimeOffsetOut"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister/","text":"datatypes::timeseries::io::SwiftNetCDFVariablePersister \u00b6 More... #include <time_series_io.hpp> Public Functions \u00b6 Name int NcGetVara (int ncid, int varid, const size_t * startp, const size_t * countp, ElementType * op) int NcPutVara (int ncid, int varid, const size_t * startp, const size_t * countp, const ElementType * op) Detailed Description \u00b6 template < typename ElementType > class datatypes :: timeseries :: io :: SwiftNetCDFVariablePersister ; Public Functions Documentation \u00b6 function NcGetVara \u00b6 static inline int NcGetVara ( int ncid , int varid , const size_t * startp , const size_t * countp , ElementType * op ) function NcPutVara \u00b6 static inline int NcPutVara ( int ncid , int varid , const size_t * startp , const size_t * countp , const ElementType * op ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::io::SwiftNetCDFVariablePersister"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister/#datatypestimeseriesioswiftnetcdfvariablepersister","text":"More... #include <time_series_io.hpp>","title":"datatypes::timeseries::io::SwiftNetCDFVariablePersister"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister/#public-functions","text":"Name int NcGetVara (int ncid, int varid, const size_t * startp, const size_t * countp, ElementType * op) int NcPutVara (int ncid, int varid, const size_t * startp, const size_t * countp, const ElementType * op)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister/#detailed-description","text":"template < typename ElementType > class datatypes :: timeseries :: io :: SwiftNetCDFVariablePersister ;","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister/#function-ncgetvara","text":"static inline int NcGetVara ( int ncid , int varid , const size_t * startp , const size_t * countp , ElementType * op )","title":"function NcGetVara"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister/#function-ncputvara","text":"static inline int NcPutVara ( int ncid , int varid , const size_t * startp , const size_t * countp , const ElementType * op ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function NcPutVara"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01double_01_4/","text":"datatypes::timeseries::io::SwiftNetCDFVariablePersister< double > \u00b6 #include <time_series_io.hpp> Public Functions \u00b6 Name int NcGetVara (int ncid, int varid, const size_t * startp, const size_t * countp, double * op) int NcPutVara (int ncid, int varid, const size_t * startp, const size_t * countp, const double * op) Public Functions Documentation \u00b6 function NcGetVara \u00b6 static inline int NcGetVara ( int ncid , int varid , const size_t * startp , const size_t * countp , double * op ) function NcPutVara \u00b6 static inline int NcPutVara ( int ncid , int varid , const size_t * startp , const size_t * countp , const double * op ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::io::SwiftNetCDFVariablePersister< double >"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01double_01_4/#datatypestimeseriesioswiftnetcdfvariablepersister-double","text":"#include <time_series_io.hpp>","title":"datatypes::timeseries::io::SwiftNetCDFVariablePersister&lt; double &gt;"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01double_01_4/#public-functions","text":"Name int NcGetVara (int ncid, int varid, const size_t * startp, const size_t * countp, double * op) int NcPutVara (int ncid, int varid, const size_t * startp, const size_t * countp, const double * op)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01double_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01double_01_4/#function-ncgetvara","text":"static inline int NcGetVara ( int ncid , int varid , const size_t * startp , const size_t * countp , double * op )","title":"function NcGetVara"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01double_01_4/#function-ncputvara","text":"static inline int NcPutVara ( int ncid , int varid , const size_t * startp , const size_t * countp , const double * op ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function NcPutVara"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01float_01_4/","text":"datatypes::timeseries::io::SwiftNetCDFVariablePersister< float > \u00b6 #include <time_series_io.hpp> Public Functions \u00b6 Name int NcGetVara (int ncid, int varid, const size_t * startp, const size_t * countp, float * op) int NcPutVara (int ncid, int varid, const size_t * startp, const size_t * countp, const float * op) Public Functions Documentation \u00b6 function NcGetVara \u00b6 static inline int NcGetVara ( int ncid , int varid , const size_t * startp , const size_t * countp , float * op ) function NcPutVara \u00b6 static inline int NcPutVara ( int ncid , int varid , const size_t * startp , const size_t * countp , const float * op ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::io::SwiftNetCDFVariablePersister< float >"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01float_01_4/#datatypestimeseriesioswiftnetcdfvariablepersister-float","text":"#include <time_series_io.hpp>","title":"datatypes::timeseries::io::SwiftNetCDFVariablePersister&lt; float &gt;"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01float_01_4/#public-functions","text":"Name int NcGetVara (int ncid, int varid, const size_t * startp, const size_t * countp, float * op) int NcPutVara (int ncid, int varid, const size_t * startp, const size_t * countp, const float * op)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01float_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01float_01_4/#function-ncgetvara","text":"static inline int NcGetVara ( int ncid , int varid , const size_t * startp , const size_t * countp , float * op )","title":"function NcGetVara"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01float_01_4/#function-ncputvara","text":"static inline int NcPutVara ( int ncid , int varid , const size_t * startp , const size_t * countp , const float * op ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function NcPutVara"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01int_01_4/","text":"datatypes::timeseries::io::SwiftNetCDFVariablePersister< int > \u00b6 #include <time_series_io.hpp> Public Functions \u00b6 Name int NcGetVara (int ncid, int varid, const size_t * startp, const size_t * countp, int * op) int NcPutVara (int ncid, int varid, const size_t * startp, const size_t * countp, const int * op) Public Functions Documentation \u00b6 function NcGetVara \u00b6 static inline int NcGetVara ( int ncid , int varid , const size_t * startp , const size_t * countp , int * op ) function NcPutVara \u00b6 static inline int NcPutVara ( int ncid , int varid , const size_t * startp , const size_t * countp , const int * op ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::io::SwiftNetCDFVariablePersister< int >"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01int_01_4/#datatypestimeseriesioswiftnetcdfvariablepersister-int","text":"#include <time_series_io.hpp>","title":"datatypes::timeseries::io::SwiftNetCDFVariablePersister&lt; int &gt;"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01int_01_4/#public-functions","text":"Name int NcGetVara (int ncid, int varid, const size_t * startp, const size_t * countp, int * op) int NcPutVara (int ncid, int varid, const size_t * startp, const size_t * countp, const int * op)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01int_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01int_01_4/#function-ncgetvara","text":"static inline int NcGetVara ( int ncid , int varid , const size_t * startp , const size_t * countp , int * op )","title":"function NcGetVara"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01int_01_4/#function-ncputvara","text":"static inline int NcPutVara ( int ncid , int varid , const size_t * startp , const size_t * countp , const int * op ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function NcPutVara"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01long_01_4/","text":"datatypes::timeseries::io::SwiftNetCDFVariablePersister< long > \u00b6 #include <time_series_io.hpp> Public Functions \u00b6 Name int NcGetVara (int ncid, int varid, const size_t * startp, const size_t * countp, long * op) int NcPutVara (int ncid, int varid, const size_t * startp, const size_t * countp, const long * op) Public Functions Documentation \u00b6 function NcGetVara \u00b6 static inline int NcGetVara ( int ncid , int varid , const size_t * startp , const size_t * countp , long * op ) function NcPutVara \u00b6 static inline int NcPutVara ( int ncid , int varid , const size_t * startp , const size_t * countp , const long * op ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::io::SwiftNetCDFVariablePersister< long >"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01long_01_4/#datatypestimeseriesioswiftnetcdfvariablepersister-long","text":"#include <time_series_io.hpp>","title":"datatypes::timeseries::io::SwiftNetCDFVariablePersister&lt; long &gt;"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01long_01_4/#public-functions","text":"Name int NcGetVara (int ncid, int varid, const size_t * startp, const size_t * countp, long * op) int NcPutVara (int ncid, int varid, const size_t * startp, const size_t * countp, const long * op)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01long_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01long_01_4/#function-ncgetvara","text":"static inline int NcGetVara ( int ncid , int varid , const size_t * startp , const size_t * countp , long * op )","title":"function NcGetVara"},{"location":"cpp/Classes/classdatatypes_1_1timeseries_1_1io_1_1SwiftNetCDFVariablePersister_3_01long_01_4/#function-ncputvara","text":"static inline int NcPutVara ( int ncid , int varid , const size_t * startp , const size_t * countp , const long * op ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function NcPutVara"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1IfThenElse/","text":"datatypes::utils::IfThenElse \u00b6 More... Detailed Description \u00b6 template < bool C , typename Ta , typename Tb > class datatypes :: utils :: IfThenElse ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::utils::IfThenElse"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1IfThenElse/#datatypesutilsifthenelse","text":"More...","title":"datatypes::utils::IfThenElse"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1IfThenElse/#detailed-description","text":"template < bool C , typename Ta , typename Tb > class datatypes :: utils :: IfThenElse ; Updated on 2022-08-20 at 19:28:22 +1000","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1IfThenElse_3_01false_00_01Ta_00_01Tb_01_4/","text":"datatypes::utils::IfThenElse< false, Ta, Tb > \u00b6 More... #include <common.h> Public Types \u00b6 Name typedef Tb ResultT Detailed Description \u00b6 template < typename Ta , typename Tb > class datatypes :: utils :: IfThenElse < false , Ta , Tb > ; Public Types Documentation \u00b6 typedef ResultT \u00b6 typedef Tb datatypes :: utils :: IfThenElse < false , Ta , Tb >:: ResultT ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::utils::IfThenElse< false, Ta, Tb >"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1IfThenElse_3_01false_00_01Ta_00_01Tb_01_4/#datatypesutilsifthenelse-false-ta-tb","text":"More... #include <common.h>","title":"datatypes::utils::IfThenElse&lt; false, Ta, Tb &gt;"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1IfThenElse_3_01false_00_01Ta_00_01Tb_01_4/#public-types","text":"Name typedef Tb ResultT","title":"Public Types"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1IfThenElse_3_01false_00_01Ta_00_01Tb_01_4/#detailed-description","text":"template < typename Ta , typename Tb > class datatypes :: utils :: IfThenElse < false , Ta , Tb > ;","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1IfThenElse_3_01false_00_01Ta_00_01Tb_01_4/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1IfThenElse_3_01false_00_01Ta_00_01Tb_01_4/#typedef-resultt","text":"typedef Tb datatypes :: utils :: IfThenElse < false , Ta , Tb >:: ResultT ; Updated on 2022-08-20 at 19:28:22 +1000","title":"typedef ResultT"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1IfThenElse_3_01true_00_01Ta_00_01Tb_01_4/","text":"datatypes::utils::IfThenElse< true, Ta, Tb > \u00b6 More... #include <common.h> Public Types \u00b6 Name typedef Ta ResultT Detailed Description \u00b6 template < typename Ta , typename Tb > class datatypes :: utils :: IfThenElse < true , Ta , Tb > ; Public Types Documentation \u00b6 typedef ResultT \u00b6 typedef Ta datatypes :: utils :: IfThenElse < true , Ta , Tb >:: ResultT ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::utils::IfThenElse< true, Ta, Tb >"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1IfThenElse_3_01true_00_01Ta_00_01Tb_01_4/#datatypesutilsifthenelse-true-ta-tb","text":"More... #include <common.h>","title":"datatypes::utils::IfThenElse&lt; true, Ta, Tb &gt;"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1IfThenElse_3_01true_00_01Ta_00_01Tb_01_4/#public-types","text":"Name typedef Ta ResultT","title":"Public Types"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1IfThenElse_3_01true_00_01Ta_00_01Tb_01_4/#detailed-description","text":"template < typename Ta , typename Tb > class datatypes :: utils :: IfThenElse < true , Ta , Tb > ;","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1IfThenElse_3_01true_00_01Ta_00_01Tb_01_4/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1IfThenElse_3_01true_00_01Ta_00_01Tb_01_4/#typedef-resultt","text":"typedef Ta datatypes :: utils :: IfThenElse < true , Ta , Tb >:: ResultT ; Updated on 2022-08-20 at 19:28:22 +1000","title":"typedef ResultT"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1PointerTypeVectorDispose/","text":"datatypes::utils::PointerTypeVectorDispose \u00b6 More... #include <common.h> Public Functions \u00b6 Name void Dispose (vector< T > & a) Detailed Description \u00b6 template < typename T > class datatypes :: utils :: PointerTypeVectorDispose ; Public Functions Documentation \u00b6 function Dispose \u00b6 static inline void Dispose ( vector < T > & a ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::utils::PointerTypeVectorDispose"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1PointerTypeVectorDispose/#datatypesutilspointertypevectordispose","text":"More... #include <common.h>","title":"datatypes::utils::PointerTypeVectorDispose"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1PointerTypeVectorDispose/#public-functions","text":"Name void Dispose (vector< T > & a)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1PointerTypeVectorDispose/#detailed-description","text":"template < typename T > class datatypes :: utils :: PointerTypeVectorDispose ;","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1PointerTypeVectorDispose/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1PointerTypeVectorDispose/#function-dispose","text":"static inline void Dispose ( vector < T > & a ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function Dispose"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper/","text":"datatypes::utils::STLHelper \u00b6 #include <common.h> Public Functions \u00b6 Name template <typename K =string,typename V =string> bool HasKey (const map< K, V > & dict, const string & key) template <typename K =string,typename V =string> vector< K > GetKeys (const map< K, V > & dict) template <typename K =string,typename V =string> map< K, V > Remap (const map< K, V > & dict, const map< K, K > & newKeys) template <typename K =string,typename V =string> map< K, V > Zip (const vector< K > & key, const vector< V > & values) template <typename K =string,typename V =string> vector< V > GetValues (const map< K, V > & dict) template <typename K =string,typename V =string> vector< V > GetValues (const map< K, V > & dict, const vector< K > & keys) template <typename U > bool LessThan (const U & first, const U & second) template <typename U > bool MoreThan (const U & first, const U & second) template <typename K ,typename V > vector< V > SortValues (const std::map< K, V > & in, const vector< K > & order) template <typename T > vector< T > Serialize (const vector< vector< T >> & series) template <typename T ,typename U > vector< T > SortFromRef (const vector< T > & in, const vector< U > & reference, std::function< bool(const U &, const U &)> comparer = STLHelper::LessThan < U >) Public Functions Documentation \u00b6 function HasKey \u00b6 template < typename K = string , typename V = string > static inline bool HasKey ( const map < K , V > & dict , const string & key ) function GetKeys \u00b6 template < typename K = string , typename V = string > static inline vector < K > GetKeys ( const map < K , V > & dict ) function Remap \u00b6 template < typename K = string , typename V = string > static inline map < K , V > Remap ( const map < K , V > & dict , const map < K , K > & newKeys ) function Zip \u00b6 template < typename K = string , typename V = string > static inline map < K , V > Zip ( const vector < K > & key , const vector < V > & values ) function GetValues \u00b6 template < typename K = string , typename V = string > static inline vector < V > GetValues ( const map < K , V > & dict ) function GetValues \u00b6 template < typename K = string , typename V = string > static inline vector < V > GetValues ( const map < K , V > & dict , const vector < K > & keys ) function LessThan \u00b6 template < typename U > static inline bool LessThan ( const U & first , const U & second ) function MoreThan \u00b6 template < typename U > static inline bool MoreThan ( const U & first , const U & second ) function SortValues \u00b6 template < typename K , typename V > static inline vector < V > SortValues ( const std :: map < K , V > & in , const vector < K > & order ) function Serialize \u00b6 template < typename T > static inline vector < T > Serialize ( const vector < vector < T >> & series ) function SortFromRef \u00b6 template < typename T , typename U > static inline vector < T > SortFromRef ( const vector < T > & in , const vector < U > & reference , std :: function < bool ( const U & , const U & ) > comparer = STLHelper :: LessThan < U > ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::utils::STLHelper"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper/#datatypesutilsstlhelper","text":"#include <common.h>","title":"datatypes::utils::STLHelper"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper/#public-functions","text":"Name template <typename K =string,typename V =string> bool HasKey (const map< K, V > & dict, const string & key) template <typename K =string,typename V =string> vector< K > GetKeys (const map< K, V > & dict) template <typename K =string,typename V =string> map< K, V > Remap (const map< K, V > & dict, const map< K, K > & newKeys) template <typename K =string,typename V =string> map< K, V > Zip (const vector< K > & key, const vector< V > & values) template <typename K =string,typename V =string> vector< V > GetValues (const map< K, V > & dict) template <typename K =string,typename V =string> vector< V > GetValues (const map< K, V > & dict, const vector< K > & keys) template <typename U > bool LessThan (const U & first, const U & second) template <typename U > bool MoreThan (const U & first, const U & second) template <typename K ,typename V > vector< V > SortValues (const std::map< K, V > & in, const vector< K > & order) template <typename T > vector< T > Serialize (const vector< vector< T >> & series) template <typename T ,typename U > vector< T > SortFromRef (const vector< T > & in, const vector< U > & reference, std::function< bool(const U &, const U &)> comparer = STLHelper::LessThan < U >)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper/#function-haskey","text":"template < typename K = string , typename V = string > static inline bool HasKey ( const map < K , V > & dict , const string & key )","title":"function HasKey"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper/#function-getkeys","text":"template < typename K = string , typename V = string > static inline vector < K > GetKeys ( const map < K , V > & dict )","title":"function GetKeys"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper/#function-remap","text":"template < typename K = string , typename V = string > static inline map < K , V > Remap ( const map < K , V > & dict , const map < K , K > & newKeys )","title":"function Remap"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper/#function-zip","text":"template < typename K = string , typename V = string > static inline map < K , V > Zip ( const vector < K > & key , const vector < V > & values )","title":"function Zip"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper/#function-getvalues","text":"template < typename K = string , typename V = string > static inline vector < V > GetValues ( const map < K , V > & dict )","title":"function GetValues"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper/#function-getvalues_1","text":"template < typename K = string , typename V = string > static inline vector < V > GetValues ( const map < K , V > & dict , const vector < K > & keys )","title":"function GetValues"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper/#function-lessthan","text":"template < typename U > static inline bool LessThan ( const U & first , const U & second )","title":"function LessThan"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper/#function-morethan","text":"template < typename U > static inline bool MoreThan ( const U & first , const U & second )","title":"function MoreThan"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper/#function-sortvalues","text":"template < typename K , typename V > static inline vector < V > SortValues ( const std :: map < K , V > & in , const vector < K > & order )","title":"function SortValues"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper/#function-serialize","text":"template < typename T > static inline vector < T > Serialize ( const vector < vector < T >> & series )","title":"function Serialize"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper/#function-sortfromref","text":"template < typename T , typename U > static inline vector < T > SortFromRef ( const vector < T > & in , const vector < U > & reference , std :: function < bool ( const U & , const U & ) > comparer = STLHelper :: LessThan < U > ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function SortFromRef"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper_1_1Comparer/","text":"datatypes::utils::STLHelper::Comparer \u00b6 More... Public Types \u00b6 Name typedef vector< U >::const_iterator const_iterator Public Functions \u00b6 Name Comparer (std::function< bool(const U &, const U &)> & valueCompare) bool operator() (const std::pair< size_t, const_iterator > & a, const std::pair< size_t, const_iterator > & b) Detailed Description \u00b6 template < typename U > class datatypes :: utils :: STLHelper :: Comparer ; Public Types Documentation \u00b6 typedef const_iterator \u00b6 typedef vector < U >:: const_iterator datatypes :: utils :: STLHelper :: Comparer < U >:: const_iterator ; Public Functions Documentation \u00b6 function Comparer \u00b6 inline Comparer ( std :: function < bool ( const U & , const U & ) > & valueCompare ) function operator() \u00b6 inline bool operator ()( const std :: pair < size_t , const_iterator > & a , const std :: pair < size_t , const_iterator > & b ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::utils::STLHelper::Comparer"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper_1_1Comparer/#datatypesutilsstlhelpercomparer","text":"More...","title":"datatypes::utils::STLHelper::Comparer"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper_1_1Comparer/#public-types","text":"Name typedef vector< U >::const_iterator const_iterator","title":"Public Types"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper_1_1Comparer/#public-functions","text":"Name Comparer (std::function< bool(const U &, const U &)> & valueCompare) bool operator() (const std::pair< size_t, const_iterator > & a, const std::pair< size_t, const_iterator > & b)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper_1_1Comparer/#detailed-description","text":"template < typename U > class datatypes :: utils :: STLHelper :: Comparer ;","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper_1_1Comparer/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper_1_1Comparer/#typedef-const_iterator","text":"typedef vector < U >:: const_iterator datatypes :: utils :: STLHelper :: Comparer < U >:: const_iterator ;","title":"typedef const_iterator"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper_1_1Comparer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper_1_1Comparer/#function-comparer","text":"inline Comparer ( std :: function < bool ( const U & , const U & ) > & valueCompare )","title":"function Comparer"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1STLHelper_1_1Comparer/#function-operator","text":"inline bool operator ()( const std :: pair < size_t , const_iterator > & a , const std :: pair < size_t , const_iterator > & b ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function operator()"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/","text":"datatypes::utils::StringProcessing \u00b6 #include <common.h> Public Functions \u00b6 Name vector< string > Split (const string & s, const string & separators) string TrimAny (const string & s, const string & charactersToTrim) vector< string > SplitOnSpaces (const string & s, bool removeEmptyEntries) vector< string > RemoveEmpty (const vector< string > & s) vector< string > Concatenate (const vector< vector< string >> & vars) void Concatenate (vector< string > & a, const vector< string > & b) bool Contains (const string & toTest, const string & toMatch, bool caseSensitive =true) bool StartsWith (const string & toTest, const string & toMatch, bool caseSensitive =true) bool Equals (const string & toTest, const string & toMatch, bool caseSensitive =true) bool EqualsAny (const string & toTest, const vector< string > & toMatch, bool caseSensitive =true) bool StringPredicate (const string & toTest, const string & toMatch, boost::function< bool(const string &, const string &)> predicate, bool caseSensitive =true) string Paste (const vector< string > & items, const string & sep =\"\") vector< string > VPaste (const vector< string > & prefixes, const string & postfix, const string & sep =\"\") vector< string > VPaste (const string & prefix, const vector< string > & postfixes, const string & sep =\"\") bool ContainsAll (const vector< string > & toTest, const vector< string > & toMatch, bool caseSensitive =true) bool SetEquals (const vector< string > & toTest, const vector< string > & toMatch, bool caseSensitive =true) vector< string > SetDiff (const vector< string > & toTest, const vector< string > & toRemove, bool caseSensitive =true) vector< string > Unique (const vector< string > & set) string BuildIdentifier (vector< string > & tokens, int fromIndex, int toIndex =-1, const string & sep = StringProcessing::kElementSeparatorToken ) string BuildIdentifier (const string & a, const string & b, const string & sep = StringProcessing::kElementSeparatorToken ) Public Attributes \u00b6 Name const string kElementSeparatorToken Public Functions Documentation \u00b6 function Split \u00b6 static vector < string > Split ( const string & s , const string & separators ) function TrimAny \u00b6 static string TrimAny ( const string & s , const string & charactersToTrim ) function SplitOnSpaces \u00b6 static vector < string > SplitOnSpaces ( const string & s , bool removeEmptyEntries ) function RemoveEmpty \u00b6 static vector < string > RemoveEmpty ( const vector < string > & s ) function Concatenate \u00b6 static vector < string > Concatenate ( const vector < vector < string >> & vars ) function Concatenate \u00b6 static void Concatenate ( vector < string > & a , const vector < string > & b ) function Contains \u00b6 static bool Contains ( const string & toTest , const string & toMatch , bool caseSensitive = true ) function StartsWith \u00b6 static bool StartsWith ( const string & toTest , const string & toMatch , bool caseSensitive = true ) function Equals \u00b6 static bool Equals ( const string & toTest , const string & toMatch , bool caseSensitive = true ) function EqualsAny \u00b6 static bool EqualsAny ( const string & toTest , const vector < string > & toMatch , bool caseSensitive = true ) function StringPredicate \u00b6 static bool StringPredicate ( const string & toTest , const string & toMatch , boost :: function < bool ( const string & , const string & ) > predicate , bool caseSensitive = true ) function Paste \u00b6 static string Paste ( const vector < string > & items , const string & sep = \"\" ) function VPaste \u00b6 static vector < string > VPaste ( const vector < string > & prefixes , const string & postfix , const string & sep = \"\" ) function VPaste \u00b6 static vector < string > VPaste ( const string & prefix , const vector < string > & postfixes , const string & sep = \"\" ) function ContainsAll \u00b6 static bool ContainsAll ( const vector < string > & toTest , const vector < string > & toMatch , bool caseSensitive = true ) function SetEquals \u00b6 static bool SetEquals ( const vector < string > & toTest , const vector < string > & toMatch , bool caseSensitive = true ) function SetDiff \u00b6 static vector < string > SetDiff ( const vector < string > & toTest , const vector < string > & toRemove , bool caseSensitive = true ) function Unique \u00b6 static vector < string > Unique ( const vector < string > & set ) function BuildIdentifier \u00b6 static string BuildIdentifier ( vector < string > & tokens , int fromIndex , int toIndex = -1 , const string & sep = StringProcessing :: kElementSeparatorToken ) function BuildIdentifier \u00b6 static string BuildIdentifier ( const string & a , const string & b , const string & sep = StringProcessing :: kElementSeparatorToken ) Public Attributes Documentation \u00b6 variable kElementSeparatorToken \u00b6 static const string kElementSeparatorToken ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::utils::StringProcessing"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#datatypesutilsstringprocessing","text":"#include <common.h>","title":"datatypes::utils::StringProcessing"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#public-functions","text":"Name vector< string > Split (const string & s, const string & separators) string TrimAny (const string & s, const string & charactersToTrim) vector< string > SplitOnSpaces (const string & s, bool removeEmptyEntries) vector< string > RemoveEmpty (const vector< string > & s) vector< string > Concatenate (const vector< vector< string >> & vars) void Concatenate (vector< string > & a, const vector< string > & b) bool Contains (const string & toTest, const string & toMatch, bool caseSensitive =true) bool StartsWith (const string & toTest, const string & toMatch, bool caseSensitive =true) bool Equals (const string & toTest, const string & toMatch, bool caseSensitive =true) bool EqualsAny (const string & toTest, const vector< string > & toMatch, bool caseSensitive =true) bool StringPredicate (const string & toTest, const string & toMatch, boost::function< bool(const string &, const string &)> predicate, bool caseSensitive =true) string Paste (const vector< string > & items, const string & sep =\"\") vector< string > VPaste (const vector< string > & prefixes, const string & postfix, const string & sep =\"\") vector< string > VPaste (const string & prefix, const vector< string > & postfixes, const string & sep =\"\") bool ContainsAll (const vector< string > & toTest, const vector< string > & toMatch, bool caseSensitive =true) bool SetEquals (const vector< string > & toTest, const vector< string > & toMatch, bool caseSensitive =true) vector< string > SetDiff (const vector< string > & toTest, const vector< string > & toRemove, bool caseSensitive =true) vector< string > Unique (const vector< string > & set) string BuildIdentifier (vector< string > & tokens, int fromIndex, int toIndex =-1, const string & sep = StringProcessing::kElementSeparatorToken ) string BuildIdentifier (const string & a, const string & b, const string & sep = StringProcessing::kElementSeparatorToken )","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#public-attributes","text":"Name const string kElementSeparatorToken","title":"Public Attributes"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#function-split","text":"static vector < string > Split ( const string & s , const string & separators )","title":"function Split"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#function-trimany","text":"static string TrimAny ( const string & s , const string & charactersToTrim )","title":"function TrimAny"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#function-splitonspaces","text":"static vector < string > SplitOnSpaces ( const string & s , bool removeEmptyEntries )","title":"function SplitOnSpaces"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#function-removeempty","text":"static vector < string > RemoveEmpty ( const vector < string > & s )","title":"function RemoveEmpty"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#function-concatenate","text":"static vector < string > Concatenate ( const vector < vector < string >> & vars )","title":"function Concatenate"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#function-concatenate_1","text":"static void Concatenate ( vector < string > & a , const vector < string > & b )","title":"function Concatenate"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#function-contains","text":"static bool Contains ( const string & toTest , const string & toMatch , bool caseSensitive = true )","title":"function Contains"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#function-startswith","text":"static bool StartsWith ( const string & toTest , const string & toMatch , bool caseSensitive = true )","title":"function StartsWith"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#function-equals","text":"static bool Equals ( const string & toTest , const string & toMatch , bool caseSensitive = true )","title":"function Equals"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#function-equalsany","text":"static bool EqualsAny ( const string & toTest , const vector < string > & toMatch , bool caseSensitive = true )","title":"function EqualsAny"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#function-stringpredicate","text":"static bool StringPredicate ( const string & toTest , const string & toMatch , boost :: function < bool ( const string & , const string & ) > predicate , bool caseSensitive = true )","title":"function StringPredicate"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#function-paste","text":"static string Paste ( const vector < string > & items , const string & sep = \"\" )","title":"function Paste"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#function-vpaste","text":"static vector < string > VPaste ( const vector < string > & prefixes , const string & postfix , const string & sep = \"\" )","title":"function VPaste"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#function-vpaste_1","text":"static vector < string > VPaste ( const string & prefix , const vector < string > & postfixes , const string & sep = \"\" )","title":"function VPaste"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#function-containsall","text":"static bool ContainsAll ( const vector < string > & toTest , const vector < string > & toMatch , bool caseSensitive = true )","title":"function ContainsAll"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#function-setequals","text":"static bool SetEquals ( const vector < string > & toTest , const vector < string > & toMatch , bool caseSensitive = true )","title":"function SetEquals"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#function-setdiff","text":"static vector < string > SetDiff ( const vector < string > & toTest , const vector < string > & toRemove , bool caseSensitive = true )","title":"function SetDiff"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#function-unique","text":"static vector < string > Unique ( const vector < string > & set )","title":"function Unique"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#function-buildidentifier","text":"static string BuildIdentifier ( vector < string > & tokens , int fromIndex , int toIndex = -1 , const string & sep = StringProcessing :: kElementSeparatorToken )","title":"function BuildIdentifier"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#function-buildidentifier_1","text":"static string BuildIdentifier ( const string & a , const string & b , const string & sep = StringProcessing :: kElementSeparatorToken )","title":"function BuildIdentifier"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1StringProcessing/#variable-kelementseparatortoken","text":"static const string kElementSeparatorToken ; Updated on 2022-08-20 at 19:28:22 +1000","title":"variable kElementSeparatorToken"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1ValueTypeVectorDispose/","text":"datatypes::utils::ValueTypeVectorDispose \u00b6 More... #include <common.h> Public Functions \u00b6 Name void Dispose (vector< T > & a) Detailed Description \u00b6 template < typename T > class datatypes :: utils :: ValueTypeVectorDispose ; Public Functions Documentation \u00b6 function Dispose \u00b6 static inline void Dispose ( vector < T > & a ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::utils::ValueTypeVectorDispose"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1ValueTypeVectorDispose/#datatypesutilsvaluetypevectordispose","text":"More... #include <common.h>","title":"datatypes::utils::ValueTypeVectorDispose"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1ValueTypeVectorDispose/#public-functions","text":"Name void Dispose (vector< T > & a)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1ValueTypeVectorDispose/#detailed-description","text":"template < typename T > class datatypes :: utils :: ValueTypeVectorDispose ;","title":"Detailed Description"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1ValueTypeVectorDispose/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1ValueTypeVectorDispose/#function-dispose","text":"static inline void Dispose ( vector < T > & a ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function Dispose"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1bad__lexical__cast/","text":"datatypes::utils::bad_lexical_cast \u00b6 A bad_lexical_cast that inherits from std::exception, unlike Boost's. Needed for graceful C API interop. #include <common.h> Inherits from std::invalid_argument Public Functions \u00b6 Name bad_lexical_cast (const string & msg) Public Functions Documentation \u00b6 function bad_lexical_cast \u00b6 bad_lexical_cast ( const string & msg ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::utils::bad_lexical_cast"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1bad__lexical__cast/#datatypesutilsbad_lexical_cast","text":"A bad_lexical_cast that inherits from std::exception, unlike Boost's. Needed for graceful C API interop. #include <common.h> Inherits from std::invalid_argument","title":"datatypes::utils::bad_lexical_cast"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1bad__lexical__cast/#public-functions","text":"Name bad_lexical_cast (const string & msg)","title":"Public Functions"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1bad__lexical__cast/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/classdatatypes_1_1utils_1_1bad__lexical__cast/#function-bad_lexical_cast","text":"bad_lexical_cast ( const string & msg ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function bad_lexical_cast"},{"location":"cpp/Classes/structdatatypes_1_1exceptions_1_1RangeCheck/","text":"datatypes::exceptions::RangeCheck \u00b6 More... #include <exception_utilities.h> Public Functions \u00b6 Name void Check (T value, T min, T max, const string & variableName) Detailed Description \u00b6 template < typename T > struct datatypes :: exceptions :: RangeCheck ; Public Functions Documentation \u00b6 function Check \u00b6 static inline void Check ( T value , T min , T max , const string & variableName ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::exceptions::RangeCheck"},{"location":"cpp/Classes/structdatatypes_1_1exceptions_1_1RangeCheck/#datatypesexceptionsrangecheck","text":"More... #include <exception_utilities.h>","title":"datatypes::exceptions::RangeCheck"},{"location":"cpp/Classes/structdatatypes_1_1exceptions_1_1RangeCheck/#public-functions","text":"Name void Check (T value, T min, T max, const string & variableName)","title":"Public Functions"},{"location":"cpp/Classes/structdatatypes_1_1exceptions_1_1RangeCheck/#detailed-description","text":"template < typename T > struct datatypes :: exceptions :: RangeCheck ;","title":"Detailed Description"},{"location":"cpp/Classes/structdatatypes_1_1exceptions_1_1RangeCheck/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/structdatatypes_1_1exceptions_1_1RangeCheck/#function-check","text":"static inline void Check ( T value , T min , T max , const string & variableName ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function Check"},{"location":"cpp/Classes/structdatatypes_1_1exceptions_1_1RangeCheck_3_01size__t_01_4/","text":"datatypes::exceptions::RangeCheck< size_t > \u00b6 #include <exception_utilities.h> Public Functions \u00b6 Name size_t MaxIndexing () void Check (size_t value, size_t min, size_t max, const string & variableName) void CheckTimeSeriesInterval (const size_t & from, size_t & to, const size_t & tsLength) void CheckTimeSeriesIndex (const size_t & index, const size_t & tsLength, const string & variableName =\"index\") Public Functions Documentation \u00b6 function MaxIndexing \u00b6 static inline size_t MaxIndexing () function Check \u00b6 static inline void Check ( size_t value , size_t min , size_t max , const string & variableName ) function CheckTimeSeriesInterval \u00b6 static inline void CheckTimeSeriesInterval ( const size_t & from , size_t & to , const size_t & tsLength ) function CheckTimeSeriesIndex \u00b6 static inline void CheckTimeSeriesIndex ( const size_t & index , const size_t & tsLength , const string & variableName = \"index\" ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::exceptions::RangeCheck< size_t >"},{"location":"cpp/Classes/structdatatypes_1_1exceptions_1_1RangeCheck_3_01size__t_01_4/#datatypesexceptionsrangecheck-size_t","text":"#include <exception_utilities.h>","title":"datatypes::exceptions::RangeCheck&lt; size_t &gt;"},{"location":"cpp/Classes/structdatatypes_1_1exceptions_1_1RangeCheck_3_01size__t_01_4/#public-functions","text":"Name size_t MaxIndexing () void Check (size_t value, size_t min, size_t max, const string & variableName) void CheckTimeSeriesInterval (const size_t & from, size_t & to, const size_t & tsLength) void CheckTimeSeriesIndex (const size_t & index, const size_t & tsLength, const string & variableName =\"index\")","title":"Public Functions"},{"location":"cpp/Classes/structdatatypes_1_1exceptions_1_1RangeCheck_3_01size__t_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/structdatatypes_1_1exceptions_1_1RangeCheck_3_01size__t_01_4/#function-maxindexing","text":"static inline size_t MaxIndexing ()","title":"function MaxIndexing"},{"location":"cpp/Classes/structdatatypes_1_1exceptions_1_1RangeCheck_3_01size__t_01_4/#function-check","text":"static inline void Check ( size_t value , size_t min , size_t max , const string & variableName )","title":"function Check"},{"location":"cpp/Classes/structdatatypes_1_1exceptions_1_1RangeCheck_3_01size__t_01_4/#function-checktimeseriesinterval","text":"static inline void CheckTimeSeriesInterval ( const size_t & from , size_t & to , const size_t & tsLength )","title":"function CheckTimeSeriesInterval"},{"location":"cpp/Classes/structdatatypes_1_1exceptions_1_1RangeCheck_3_01size__t_01_4/#function-checktimeseriesindex","text":"static inline void CheckTimeSeriesIndex ( const size_t & index , const size_t & tsLength , const string & variableName = \"index\" ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function CheckTimeSeriesIndex"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1CommonTypes/","text":"datatypes::timeseries::CommonTypes \u00b6 Typical ensemble and time series data types derived from a fundamental data type for each data item. More... #include <time_series.hpp> Public Types \u00b6 Name using typename time_series_of < ElementType >::type SeriesType Type of a time series for this fundamental element type: TTimeSeries using typename std::add_pointer< SeriesType >::type PtrSeriesType Type of pointer a time series for this fundamental element type: TTimeSeries *. using typename ensemble_of < SeriesType >::type EnsembleType Type of MultiTimeSeries > using typename ensemble_of < PtrSeriesType >::type EnsemblePtrType Type of MultiTimeSeries *> using typename std::add_pointer< EnsemblePtrType >::type PtrEnsemblePtrType Type of a pointer to a MultiTimeSeries *> using typename time_series_of < PtrEnsemblePtrType >::type TSeriesEnsemblePtrType Type of TTimeSeries < MultiTimeSeries *>* > using typename std::add_pointer< TSeriesEnsemblePtrType >::type PtrTSeriesEnsemblePtrType Type of a pointer to a TTimeSeries < MultiTimeSeries *>* > Detailed Description \u00b6 template < typename ElementType = double > struct datatypes :: timeseries :: CommonTypes ; Typical ensemble and time series data types derived from a fundamental data type for each data item. Template Parameters : ElementType fundamental data type for each data item. Public Types Documentation \u00b6 using SeriesType \u00b6 using datatypes :: timeseries :: CommonTypes < ElementType >:: SeriesType = typename time_series_of < ElementType >:: type ; Type of a time series for this fundamental element type: TTimeSeries using PtrSeriesType \u00b6 using datatypes :: timeseries :: CommonTypes < ElementType >:: PtrSeriesType = typename std :: add_pointer < SeriesType >:: type ; Type of pointer a time series for this fundamental element type: TTimeSeries *. using EnsembleType \u00b6 using datatypes :: timeseries :: CommonTypes < ElementType >:: EnsembleType = typename ensemble_of < SeriesType >:: type ; Type of MultiTimeSeries > using EnsemblePtrType \u00b6 using datatypes :: timeseries :: CommonTypes < ElementType >:: EnsemblePtrType = typename ensemble_of < PtrSeriesType >:: type ; Type of MultiTimeSeries *> using PtrEnsemblePtrType \u00b6 using datatypes :: timeseries :: CommonTypes < ElementType >:: PtrEnsemblePtrType = typename std :: add_pointer < EnsemblePtrType >:: type ; Type of a pointer to a MultiTimeSeries *> using TSeriesEnsemblePtrType \u00b6 using datatypes :: timeseries :: CommonTypes < ElementType >:: TSeriesEnsemblePtrType = typename time_series_of < PtrEnsemblePtrType >:: type ; Type of TTimeSeries < MultiTimeSeries *>* > using PtrTSeriesEnsemblePtrType \u00b6 using datatypes :: timeseries :: CommonTypes < ElementType >:: PtrTSeriesEnsemblePtrType = typename std :: add_pointer < TSeriesEnsemblePtrType >:: type ; Type of a pointer to a TTimeSeries < MultiTimeSeries *>* > Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::CommonTypes"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1CommonTypes/#datatypestimeseriescommontypes","text":"Typical ensemble and time series data types derived from a fundamental data type for each data item. More... #include <time_series.hpp>","title":"datatypes::timeseries::CommonTypes"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1CommonTypes/#public-types","text":"Name using typename time_series_of < ElementType >::type SeriesType Type of a time series for this fundamental element type: TTimeSeries using typename std::add_pointer< SeriesType >::type PtrSeriesType Type of pointer a time series for this fundamental element type: TTimeSeries *. using typename ensemble_of < SeriesType >::type EnsembleType Type of MultiTimeSeries > using typename ensemble_of < PtrSeriesType >::type EnsemblePtrType Type of MultiTimeSeries *> using typename std::add_pointer< EnsemblePtrType >::type PtrEnsemblePtrType Type of a pointer to a MultiTimeSeries *> using typename time_series_of < PtrEnsemblePtrType >::type TSeriesEnsemblePtrType Type of TTimeSeries < MultiTimeSeries *>* > using typename std::add_pointer< TSeriesEnsemblePtrType >::type PtrTSeriesEnsemblePtrType Type of a pointer to a TTimeSeries < MultiTimeSeries *>* >","title":"Public Types"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1CommonTypes/#detailed-description","text":"template < typename ElementType = double > struct datatypes :: timeseries :: CommonTypes ; Typical ensemble and time series data types derived from a fundamental data type for each data item. Template Parameters : ElementType fundamental data type for each data item.","title":"Detailed Description"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1CommonTypes/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1CommonTypes/#using-seriestype","text":"using datatypes :: timeseries :: CommonTypes < ElementType >:: SeriesType = typename time_series_of < ElementType >:: type ; Type of a time series for this fundamental element type: TTimeSeries","title":"using SeriesType"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1CommonTypes/#using-ptrseriestype","text":"using datatypes :: timeseries :: CommonTypes < ElementType >:: PtrSeriesType = typename std :: add_pointer < SeriesType >:: type ; Type of pointer a time series for this fundamental element type: TTimeSeries *.","title":"using PtrSeriesType"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1CommonTypes/#using-ensembletype","text":"using datatypes :: timeseries :: CommonTypes < ElementType >:: EnsembleType = typename ensemble_of < SeriesType >:: type ; Type of MultiTimeSeries >","title":"using EnsembleType"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1CommonTypes/#using-ensembleptrtype","text":"using datatypes :: timeseries :: CommonTypes < ElementType >:: EnsemblePtrType = typename ensemble_of < PtrSeriesType >:: type ; Type of MultiTimeSeries *>","title":"using EnsemblePtrType"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1CommonTypes/#using-ptrensembleptrtype","text":"using datatypes :: timeseries :: CommonTypes < ElementType >:: PtrEnsemblePtrType = typename std :: add_pointer < EnsemblePtrType >:: type ; Type of a pointer to a MultiTimeSeries *>","title":"using PtrEnsemblePtrType"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1CommonTypes/#using-tseriesensembleptrtype","text":"using datatypes :: timeseries :: CommonTypes < ElementType >:: TSeriesEnsemblePtrType = typename time_series_of < PtrEnsemblePtrType >:: type ; Type of TTimeSeries < MultiTimeSeries *>* >","title":"using TSeriesEnsemblePtrType"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1CommonTypes/#using-ptrtseriesensembleptrtype","text":"using datatypes :: timeseries :: CommonTypes < ElementType >:: PtrTSeriesEnsemblePtrType = typename std :: add_pointer < TSeriesEnsemblePtrType >:: type ; Type of a pointer to a TTimeSeries < MultiTimeSeries *>* > Updated on 2022-08-20 at 19:28:22 +1000","title":"using PtrTSeriesEnsemblePtrType"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1DefaultMissingValuePolicyTypeFactory/","text":"datatypes::timeseries::DefaultMissingValuePolicyTypeFactory \u00b6 More... #include <time_series.hpp> Public Types \u00b6 Name typedef IfThenElse < std::is_pointer< T >::value, NullPointerIsMissingPolicy < T >, DefaultMissingFloatingPointPolicy < T > >::ResultT type Detailed Description \u00b6 template < typename T > struct datatypes :: timeseries :: DefaultMissingValuePolicyTypeFactory ; Public Types Documentation \u00b6 typedef type \u00b6 typedef IfThenElse < std :: is_pointer < T >:: value , NullPointerIsMissingPolicy < T > , DefaultMissingFloatingPointPolicy < T > >:: ResultT datatypes :: timeseries :: DefaultMissingValuePolicyTypeFactory < T >:: type ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::DefaultMissingValuePolicyTypeFactory"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1DefaultMissingValuePolicyTypeFactory/#datatypestimeseriesdefaultmissingvaluepolicytypefactory","text":"More... #include <time_series.hpp>","title":"datatypes::timeseries::DefaultMissingValuePolicyTypeFactory"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1DefaultMissingValuePolicyTypeFactory/#public-types","text":"Name typedef IfThenElse < std::is_pointer< T >::value, NullPointerIsMissingPolicy < T >, DefaultMissingFloatingPointPolicy < T > >::ResultT type","title":"Public Types"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1DefaultMissingValuePolicyTypeFactory/#detailed-description","text":"template < typename T > struct datatypes :: timeseries :: DefaultMissingValuePolicyTypeFactory ;","title":"Detailed Description"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1DefaultMissingValuePolicyTypeFactory/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1DefaultMissingValuePolicyTypeFactory/#typedef-type","text":"typedef IfThenElse < std :: is_pointer < T >:: value , NullPointerIsMissingPolicy < T > , DefaultMissingFloatingPointPolicy < T > >:: ResultT datatypes :: timeseries :: DefaultMissingValuePolicyTypeFactory < T >:: type ; Updated on 2022-08-20 at 19:28:22 +1000","title":"typedef type"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1ensemble__of/","text":"datatypes::timeseries::ensemble_of \u00b6 More... #include <time_series.hpp> Public Types \u00b6 Name typedef MultiTimeSeries < T > type Detailed Description \u00b6 template < typename T > struct datatypes :: timeseries :: ensemble_of ; Public Types Documentation \u00b6 typedef type \u00b6 typedef MultiTimeSeries < T > datatypes :: timeseries :: ensemble_of < T >:: type ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::ensemble_of"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1ensemble__of/#datatypestimeseriesensemble_of","text":"More... #include <time_series.hpp>","title":"datatypes::timeseries::ensemble_of"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1ensemble__of/#public-types","text":"Name typedef MultiTimeSeries < T > type","title":"Public Types"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1ensemble__of/#detailed-description","text":"template < typename T > struct datatypes :: timeseries :: ensemble_of ;","title":"Detailed Description"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1ensemble__of/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1ensemble__of/#typedef-type","text":"typedef MultiTimeSeries < T > datatypes :: timeseries :: ensemble_of < T >:: type ; Updated on 2022-08-20 at 19:28:22 +1000","title":"typedef type"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1item__type__of/","text":"datatypes::timeseries::item_type_of \u00b6 More... #include <time_series.hpp> Public Types \u00b6 Name typedef T::ElementType type Detailed Description \u00b6 template < typename T > struct datatypes :: timeseries :: item_type_of ; Public Types Documentation \u00b6 typedef type \u00b6 typedef T :: ElementType datatypes :: timeseries :: item_type_of < T >:: type ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::item_type_of"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1item__type__of/#datatypestimeseriesitem_type_of","text":"More... #include <time_series.hpp>","title":"datatypes::timeseries::item_type_of"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1item__type__of/#public-types","text":"Name typedef T::ElementType type","title":"Public Types"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1item__type__of/#detailed-description","text":"template < typename T > struct datatypes :: timeseries :: item_type_of ;","title":"Detailed Description"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1item__type__of/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1item__type__of/#typedef-type","text":"typedef T :: ElementType datatypes :: timeseries :: item_type_of < T >:: type ; Updated on 2022-08-20 at 19:28:22 +1000","title":"typedef type"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1time__series__of/","text":"datatypes::timeseries::time_series_of \u00b6 More... #include <time_series.hpp> Public Types \u00b6 Name typedef TTimeSeries < T > type Detailed Description \u00b6 template < typename T > struct datatypes :: timeseries :: time_series_of ; Public Types Documentation \u00b6 typedef type \u00b6 typedef TTimeSeries < T > datatypes :: timeseries :: time_series_of < T >:: type ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::time_series_of"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1time__series__of/#datatypestimeseriestime_series_of","text":"More... #include <time_series.hpp>","title":"datatypes::timeseries::time_series_of"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1time__series__of/#public-types","text":"Name typedef TTimeSeries < T > type","title":"Public Types"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1time__series__of/#detailed-description","text":"template < typename T > struct datatypes :: timeseries :: time_series_of ;","title":"Detailed Description"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1time__series__of/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/structdatatypes_1_1timeseries_1_1time__series__of/#typedef-type","text":"typedef TTimeSeries < T > datatypes :: timeseries :: time_series_of < T >:: type ; Updated on 2022-08-20 at 19:28:22 +1000","title":"typedef type"},{"location":"cpp/Classes/structdatatypes_1_1utils_1_1DisposeVectorTypeFactory/","text":"datatypes::utils::DisposeVectorTypeFactory \u00b6 More... #include <common.h> Public Types \u00b6 Name typedef IfThenElse < std::is_pointer< T >::value, ValueTypeVectorDispose < T >, PointerTypeVectorDispose < T > >::ResultT type Detailed Description \u00b6 template < typename T > struct datatypes :: utils :: DisposeVectorTypeFactory ; Public Types Documentation \u00b6 typedef type \u00b6 typedef IfThenElse < std :: is_pointer < T >:: value , ValueTypeVectorDispose < T > , PointerTypeVectorDispose < T > >:: ResultT datatypes :: utils :: DisposeVectorTypeFactory < T >:: type ; Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::utils::DisposeVectorTypeFactory"},{"location":"cpp/Classes/structdatatypes_1_1utils_1_1DisposeVectorTypeFactory/#datatypesutilsdisposevectortypefactory","text":"More... #include <common.h>","title":"datatypes::utils::DisposeVectorTypeFactory"},{"location":"cpp/Classes/structdatatypes_1_1utils_1_1DisposeVectorTypeFactory/#public-types","text":"Name typedef IfThenElse < std::is_pointer< T >::value, ValueTypeVectorDispose < T >, PointerTypeVectorDispose < T > >::ResultT type","title":"Public Types"},{"location":"cpp/Classes/structdatatypes_1_1utils_1_1DisposeVectorTypeFactory/#detailed-description","text":"template < typename T > struct datatypes :: utils :: DisposeVectorTypeFactory ;","title":"Detailed Description"},{"location":"cpp/Classes/structdatatypes_1_1utils_1_1DisposeVectorTypeFactory/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"cpp/Classes/structdatatypes_1_1utils_1_1DisposeVectorTypeFactory/#typedef-type","text":"typedef IfThenElse < std :: is_pointer < T >:: value , ValueTypeVectorDispose < T > , PointerTypeVectorDispose < T > >:: ResultT datatypes :: utils :: DisposeVectorTypeFactory < T >:: type ; Updated on 2022-08-20 at 19:28:22 +1000","title":"typedef type"},{"location":"cpp/Classes/structmoirai_1_1known__conversions_3_01TimeSeriesProvider_3_01double_01_4_01_4/","text":"moirai::known_conversions< TimeSeriesProvider< double > > \u00b6 #include <shared_pointer_conversions.hpp> Public Functions \u00b6 Name TimeSeriesProvider< double > * dyn_cast (void * p, const typeinfo & tinfo) Public Functions Documentation \u00b6 function dyn_cast \u00b6 static inline TimeSeriesProvider < double > * dyn_cast ( void * p , const typeinfo & tinfo ) Updated on 2022-08-20 at 19:28:22 +1000","title":"moirai::known_conversions< TimeSeriesProvider< double > >"},{"location":"cpp/Classes/structmoirai_1_1known__conversions_3_01TimeSeriesProvider_3_01double_01_4_01_4/#moiraiknown_conversions-timeseriesprovider-double","text":"#include <shared_pointer_conversions.hpp>","title":"moirai::known_conversions&lt; TimeSeriesProvider&lt; double &gt; &gt;"},{"location":"cpp/Classes/structmoirai_1_1known__conversions_3_01TimeSeriesProvider_3_01double_01_4_01_4/#public-functions","text":"Name TimeSeriesProvider< double > * dyn_cast (void * p, const typeinfo & tinfo)","title":"Public Functions"},{"location":"cpp/Classes/structmoirai_1_1known__conversions_3_01TimeSeriesProvider_3_01double_01_4_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"cpp/Classes/structmoirai_1_1known__conversions_3_01TimeSeriesProvider_3_01double_01_4_01_4/#function-dyn_cast","text":"static inline TimeSeriesProvider < double > * dyn_cast ( void * p , const typeinfo & tinfo ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function dyn_cast"},{"location":"cpp/Examples/","text":"Examples \u00b6 Updated on 2022-08-20 at 19:28:22 +1000","title":"Examples"},{"location":"cpp/Examples/#examples","text":"Updated on 2022-08-20 at 19:28:22 +1000","title":"Examples"},{"location":"cpp/Files/","text":"Files \u00b6 dir datatypes dir datatypes dir include dir datatypes file datatypes/common.h file datatypes/datatypes_test_helpers.h file datatypes/datatypes_test_helpers.hpp file datatypes/exception_utilities.h file datatypes/extern_c_api.h file datatypes/extern_c_api_as_opaque.h file datatypes/extern_c_api_as_transparent.h file datatypes/extern_c_api_transparent_pointers.h file datatypes/internals_c_api.hpp file datatypes/interop_conversions.h file datatypes/interop_conversions.hpp file datatypes/interop_struct.h file datatypes/io_helper.h file datatypes/setup_exports.h file datatypes/shared_pointer_conversions.hpp file datatypes/time_series.hpp file datatypes/time_series_io.hpp file datatypes/time_series_store.hpp file datatypes/time_series_strategies.hpp file datatypes/time_step.h file datatypes/time_step_implementation.h Updated on 2022-08-20 at 19:28:22 +1000","title":"Files"},{"location":"cpp/Files/#files","text":"dir datatypes dir datatypes dir include dir datatypes file datatypes/common.h file datatypes/datatypes_test_helpers.h file datatypes/datatypes_test_helpers.hpp file datatypes/exception_utilities.h file datatypes/extern_c_api.h file datatypes/extern_c_api_as_opaque.h file datatypes/extern_c_api_as_transparent.h file datatypes/extern_c_api_transparent_pointers.h file datatypes/internals_c_api.hpp file datatypes/interop_conversions.h file datatypes/interop_conversions.hpp file datatypes/interop_struct.h file datatypes/io_helper.h file datatypes/setup_exports.h file datatypes/shared_pointer_conversions.hpp file datatypes/time_series.hpp file datatypes/time_series_io.hpp file datatypes/time_series_store.hpp file datatypes/time_series_strategies.hpp file datatypes/time_step.h file datatypes/time_step_implementation.h Updated on 2022-08-20 at 19:28:22 +1000","title":"Files"},{"location":"cpp/Files/common_8h/","text":"datatypes/common.h \u00b6 Namespaces \u00b6 Name datatypes datatypes::utils datatypes::interop boost::posix_time boost::gregorian Classes \u00b6 Name class datatypes::utils::STLHelper class datatypes::utils::IfThenElse< true, Ta, Tb > class datatypes::utils::IfThenElse< false, Ta, Tb > class datatypes::utils::ValueTypeVectorDispose class datatypes::utils::PointerTypeVectorDispose struct datatypes::utils::DisposeVectorTypeFactory class datatypes::utils::bad_lexical_cast A bad_lexical_cast that inherits from std::exception, unlike Boost's. Needed for graceful C API interop. class datatypes::utils::StringProcessing class datatypes::interop::MissingValueHandling Defines \u00b6 Name DEFAULT_MISSING_DATA_VALUE DEFAULT_STATION_IDENTIFIER STRDUP STLSTR_TO_ANSISTR (x) DATATYPES_DOUBLE_PRECISION_ID DATATYPES_SINGLE_PRECISION_ID DATATYPES_FOUR_DIMENSIONS_DATA DATATYPES_THREE_DIMENSIONS_DATA DATATYPES_TWO_DIMENSIONS_DATA SWIFT_TIME_UNIT_MINUTE SWIFT_TIME_UNIT_HOUR SWIFT_TIME_UNIT_DAY SWIFT_TIME_UNIT_MONTH FILE_KEY ID_DATA_KEY VAR_KEY IDENTIFIER_KEY INDEX_KEY TYPE_KEY SINGLE_SERIES_COLLECTION_TYPE_ID A string identifier for a multivariate time series (structurally an ensemble, but not semantically, e.g. TS for multiple sites) SINGLE_SERIES_TYPE_ID A string identifier for a single univariate time series. ENSEMBLE_SERIES_TYPE_ID A string identifier for ensemble of time series (e.g. ensemble forecasts for one lead time) TIME_SERIES_ENSEMBLE_SERIES_TYPE_ID A string identifier for time series of ensemble of time series (e.g. ensemble forecasts time series) TIME_SERIES_SERIES_COLLECTION_TYPE_ID A string identifier for time series of collection of time series (e.g. forecasts for multiple sites) STORAGE_TYPE_SINGLE_NETCDF_FILE STORAGE_TYPE_MULTIPLE_NETCDF_FILES Macros Documentation \u00b6 define DEFAULT_MISSING_DATA_VALUE \u00b6 #define DEFAULT_MISSING_DATA_VALUE -9999.0 define DEFAULT_STATION_IDENTIFIER \u00b6 #define DEFAULT_STATION_IDENTIFIER { \"0\" } define STRDUP \u00b6 #define STRDUP strdup define STLSTR_TO_ANSISTR \u00b6 #define STLSTR_TO_ANSISTR( x ) STRDUP ( x . c_str ()) define DATATYPES_DOUBLE_PRECISION_ID \u00b6 #define DATATYPES_DOUBLE_PRECISION_ID \"double\" define DATATYPES_SINGLE_PRECISION_ID \u00b6 #define DATATYPES_SINGLE_PRECISION_ID \"single\" define DATATYPES_FOUR_DIMENSIONS_DATA \u00b6 #define DATATYPES_FOUR_DIMENSIONS_DATA \"4\" define DATATYPES_THREE_DIMENSIONS_DATA \u00b6 #define DATATYPES_THREE_DIMENSIONS_DATA \"3\" define DATATYPES_TWO_DIMENSIONS_DATA \u00b6 #define DATATYPES_TWO_DIMENSIONS_DATA \"2\" define SWIFT_TIME_UNIT_MINUTE \u00b6 #define SWIFT_TIME_UNIT_MINUTE string(\"minute\") define SWIFT_TIME_UNIT_HOUR \u00b6 #define SWIFT_TIME_UNIT_HOUR string(\"hour\") define SWIFT_TIME_UNIT_DAY \u00b6 #define SWIFT_TIME_UNIT_DAY string(\"day\") define SWIFT_TIME_UNIT_MONTH \u00b6 #define SWIFT_TIME_UNIT_MONTH string(\"month\") define FILE_KEY \u00b6 #define FILE_KEY \"File\" define ID_DATA_KEY \u00b6 #define ID_DATA_KEY \"Id\" define VAR_KEY \u00b6 #define VAR_KEY \"Var\" define IDENTIFIER_KEY \u00b6 #define IDENTIFIER_KEY \"Identifier\" define INDEX_KEY \u00b6 #define INDEX_KEY \"Index\" define TYPE_KEY \u00b6 #define TYPE_KEY \"Type\" define SINGLE_SERIES_COLLECTION_TYPE_ID \u00b6 #define SINGLE_SERIES_COLLECTION_TYPE_ID \"single_collection\" A string identifier for a multivariate time series (structurally an ensemble, but not semantically, e.g. TS for multiple sites) define SINGLE_SERIES_TYPE_ID \u00b6 #define SINGLE_SERIES_TYPE_ID \"single\" A string identifier for a single univariate time series. define ENSEMBLE_SERIES_TYPE_ID \u00b6 #define ENSEMBLE_SERIES_TYPE_ID \"ensemble_ts\" A string identifier for ensemble of time series (e.g. ensemble forecasts for one lead time) define TIME_SERIES_ENSEMBLE_SERIES_TYPE_ID \u00b6 #define TIME_SERIES_ENSEMBLE_SERIES_TYPE_ID \"ts_ensemble_ts\" A string identifier for time series of ensemble of time series (e.g. ensemble forecasts time series) define TIME_SERIES_SERIES_COLLECTION_TYPE_ID \u00b6 #define TIME_SERIES_SERIES_COLLECTION_TYPE_ID \"ts_ts_collection\" A string identifier for time series of collection of time series (e.g. forecasts for multiple sites) define STORAGE_TYPE_SINGLE_NETCDF_FILE \u00b6 #define STORAGE_TYPE_SINGLE_NETCDF_FILE \"single_nc_file\" define STORAGE_TYPE_MULTIPLE_NETCDF_FILES \u00b6 #define STORAGE_TYPE_MULTIPLE_NETCDF_FILES \"multiple_nc_files_filename_date_pattern\" Source code \u00b6 #pragma once #include <stdio.h> #include <atomic> #include <string> #include <vector> #include <map> #include <boost/function.hpp> #include <boost/lexical_cast.hpp> #include <boost/date_time/gregorian/gregorian.hpp> #include <boost/date_time/posix_time/posix_time.hpp> #include <datatypes/setup_exports.h> #ifdef _MSC_VER # pragma warning(push) // class blah needs to have dll-interface to be used by clients of class blah # pragma warning(disable : 4251 4231 4660 4275) #endif #define DEFAULT_MISSING_DATA_VALUE -9999.0 #define DEFAULT_STATION_IDENTIFIER { \"0\" } // You can define the following to activate the Visual Leak Detector tool for visual C++ // https://vld.codeplex.com //#define DATATYPES_USE_VLD #ifdef DATATYPES_USE_VLD #include <vld.h> #endif #ifdef _WIN32 #define STRDUP _strdup #else #define STRDUP strdup #endif #define STLSTR_TO_ANSISTR(x) STRDUP(x.c_str()) using std :: string ; using std :: vector ; using std :: map ; using std :: pair ; using namespace boost :: posix_time ; using namespace boost :: gregorian ; #define DATATYPES_DOUBLE_PRECISION_ID \"double\" #define DATATYPES_SINGLE_PRECISION_ID \"single\" #define DATATYPES_FOUR_DIMENSIONS_DATA \"4\" #define DATATYPES_THREE_DIMENSIONS_DATA \"3\" #define DATATYPES_TWO_DIMENSIONS_DATA \"2\" #define SWIFT_TIME_UNIT_MINUTE string(\"minute\") #define SWIFT_TIME_UNIT_HOUR string(\"hour\") #define SWIFT_TIME_UNIT_DAY string(\"day\") #define SWIFT_TIME_UNIT_MONTH string(\"month\") // macros for strings used as structuring identifiers or keys in std::map #define FILE_KEY \"File\" #define ID_DATA_KEY \"Id\" #define VAR_KEY \"Var\" #define IDENTIFIER_KEY \"Identifier\" #define INDEX_KEY \"Index\" #define TYPE_KEY \"Type\" #define SINGLE_SERIES_COLLECTION_TYPE_ID \"single_collection\" #define SINGLE_SERIES_TYPE_ID \"single\" #define ENSEMBLE_SERIES_TYPE_ID \"ensemble_ts\" #define TIME_SERIES_ENSEMBLE_SERIES_TYPE_ID \"ts_ensemble_ts\" #define TIME_SERIES_SERIES_COLLECTION_TYPE_ID \"ts_ts_collection\" #define STORAGE_TYPE_SINGLE_NETCDF_FILE \"single_nc_file\" #define STORAGE_TYPE_MULTIPLE_NETCDF_FILES \"multiple_nc_files_filename_date_pattern\" namespace datatypes { namespace utils { void datatypes_delete_ansi_string_array ( char ** values , int arrayLength ); class STLHelper { private : STLHelper (); template < typename U > class Comparer { std :: function < bool ( const U & , const U & ) >& valueCompare ; public : Comparer ( std :: function < bool ( const U & , const U & ) >& valueCompare ) : valueCompare ( valueCompare ) { } typedef typename vector < U >:: const_iterator const_iterator ; bool operator ()( const std :: pair < size_t , const_iterator >& a , const std :: pair < size_t , const_iterator >& b ) { return valueCompare ( * ( a . second ), * ( b . second )); } }; public : template < typename K = string , typename V = string > static bool HasKey ( const map < K , V >& dict , const string & key ) { return ( dict . find ( key ) != dict . end ()); } template < typename K = string , typename V = string > static vector < K > GetKeys ( const map < K , V >& dict ) { vector < K > res ; res . reserve ( dict . size ()); for ( auto & kvpair : dict ) res . push_back ( kvpair . first ); return res ; } template < typename K = string , typename V = string > static map < K , V > Remap ( const map < K , V >& dict , const map < K , K >& newKeys ) { map < K , V > res ; for ( const auto & kvpair : dict ) { K newKey = newKeys . at ( kvpair . first ); res [ newKey ] = kvpair . second ; } return res ; } template < typename K = string , typename V = string > static map < K , V > Zip ( const vector < K >& key , const vector < V >& values ) { map < K , V > res ; if ( key . size () > values . size ()) throw std :: logic_error ( \"Zip function must have less keys than values\" ); for ( size_t i = 0 ; i < key . size (); i ++ ) res [ key [ i ]] = values [ i ]; return res ; } template < typename K = string , typename V = string > static vector < V > GetValues ( const map < K , V >& dict ) { vector < V > res ; res . reserve ( dict . size ()); for ( auto & kvpair : dict ) res . push_back ( kvpair . second ); return res ; } template < typename K = string , typename V = string > static vector < V > GetValues ( const map < K , V >& dict , const vector < K >& keys ) { vector < V > res ; res . reserve ( keys . size ()); for ( auto & k : keys ) res . push_back ( dict . at ( k )); return res ; } template < typename U > static bool LessThan ( const U & first , const U & second ) { return first < second ; } template < typename U > static bool MoreThan ( const U & first , const U & second ) { return first > second ; } template < typename K , typename V > static vector < V > SortValues ( const std :: map < K , V >& in , const vector < K >& order ) { vector < V > result ; for ( auto & k : order ) { if ( ! HasKey ( in , k )) throw std :: logic_error ( \"No entry in std::map for key \" + k ); result . push_back ( in . at ( k )); } return result ; } template < typename T > static vector < T > Serialize ( const vector < vector < T >>& series ) { vector < T > result ; for ( size_t i = 0 ; i < series . size (); i ++ ) { auto & v = series [ i ]; auto n = result . size (); auto m = v . size (); result . resize ( n + m ); std :: copy ( v . begin (), v . end (), result . begin () + n ); } return result ; } template < typename T , typename U > static vector < T > SortFromRef ( const vector < T >& in , const vector < U >& reference , std :: function < bool ( const U & , const U & ) > comparer = STLHelper :: LessThan < U > ) { // Attribution: derived from http://stackoverflow.com/a/236199/2752565, Konrad Rudolph typedef typename vector < U >:: const_iterator myiter ; vector < std :: pair < size_t , myiter >> order ( reference . size ()); size_t n = 0 ; for ( myiter it = reference . begin (); it != reference . end (); ++ it , ++ n ) order [ n ] = std :: make_pair ( n , it ); Comparer < U > ordering ( comparer ); sort ( order . begin (), order . end (), ordering ); vector < T > ret ( in . size ()); size_t const size = in . size (); for ( size_t i = 0 ; i < size ; ++ i ) ret [ i ] = in [ order [ i ]. first ]; return ret ; } }; template < typename T = double > vector < T > SeqVec ( T from , T by , size_t num ) { vector < T > data ; data . resize ( num ); for ( size_t i = 0 ; i < num ; i ++ ) data [ i ] = from + (( T ) i ) * by ; return data ; } // Could not find an easy if_then_else in the STL or Boost. IfThenElse will probably be replaced. // primary template: yield second or third argument depending on first argument template < bool C , typename Ta , typename Tb > class IfThenElse ; // Credits: // C++ templates : the complete guide / David Vandevoorde, Nicolai M. Josuttis. // ISBN 0 - 201 - 73484 - 2 (alk.paper) // partial specialization: true yields second argument template < typename Ta , typename Tb > class IfThenElse < true , Ta , Tb > { public : typedef Ta ResultT ; }; // partial specialization: false yields third argument template < typename Ta , typename Tb > class IfThenElse < false , Ta , Tb > { public : typedef Tb ResultT ; }; template < typename T > class ValueTypeVectorDispose { public : static void Dispose ( vector < T >& a ) { a . clear (); } }; template < typename T > class PointerTypeVectorDispose { public : static void Dispose ( vector < T >& a ) { for ( size_t i = 0 ; i < a . size (); i ++ ) { auto p = a [ i ]; if ( p != nullptr ) delete p ; } a . clear (); } }; template < typename T > struct DisposeVectorTypeFactory { typedef typename IfThenElse < std :: is_pointer < T >:: value , ValueTypeVectorDispose < T > , PointerTypeVectorDispose < T > >:: ResultT type ; }; template < typename T > void DisposeVector ( vector < T >& v ) { using U = typename datatypes :: utils :: DisposeVectorTypeFactory < T >:: type ; U :: Dispose ( v ); } class DATATYPES_DLL_LIB bad_lexical_cast : public std :: invalid_argument { public : bad_lexical_cast ( const string & msg ); }; template < typename Target > static Target Parse ( const string & strId ) { try { return boost :: lexical_cast < Target > ( strId ); } catch ( boost :: bad_lexical_cast & ) { throw datatypes :: utils :: bad_lexical_cast ( string ( \"Failed to parse '\" ) + strId + string ( \"' as a \" ) + string ( typeid ( Target ). name ())); } } template < typename Source > static string ToString ( const Source & value ) { try { return boost :: lexical_cast < string > ( value ); } catch ( boost :: bad_lexical_cast & ) { throw datatypes :: utils :: bad_lexical_cast ( string ( \"Failed to convert a value of type '\" ) + string ( typeid ( Source ). name ()) + string ( \"' to a string\" )); } } template < class TTo > static TTo * ConvertToArray ( const vector < string >& src ) { string & strId ; TTo * result = new TTo [ src . size ()]; try { for ( int i = 0 ; i < src . size (); i ++ ) { strId = src [ i ]; result [ i ] = boost :: lexical_cast < TTo > ( strId ); } return result ; } catch ( boost :: bad_lexical_cast & c ) { delete result ; throw datatypes :: utils :: bad_lexical_cast ( string ( \"Failed to parse '\" ) + strId + string ( \"' in an vector as a \" ) + string ( typeid ( TTo ). name ())); } } template < class TFrom , class TTo > static TTo * ConvertToArray ( const vector < TFrom >& src ) { TTo * result = new TTo [ src . size ()]; try { for ( int i = 0 ; i < src . size (); i ++ ) { result [ i ] = ( TTo ) src [ i ]; } return result ; } catch ( std :: exception & c ) { delete result ; throw datatypes :: utils :: bad_lexical_cast ( string ( \"Failed to convert vector of \" ) + string ( typeid ( TFrom ). name ()) + string ( \" to an array of \" ) + string ( typeid ( TTo ). name ())); } } template < class TFrom , class TTo > static vector < TTo > Convert ( const vector < TFrom >& src ) { vector < TTo > result ( src . size ()); try { for ( int i = 0 ; i < src . size (); i ++ ) result [ i ] = ( TTo ) src [ i ]; return result ; } catch ( std :: exception & ) { string msg = ( string ( \"Failed to convert vector of \" ) + string ( typeid ( TFrom ). name ()) + string ( \" to a vector of \" ) + string ( typeid ( TTo ). name ())); throw datatypes :: utils :: bad_lexical_cast ( msg ); } } template < class TTo > vector < TTo > Convert ( const vector < string > & src ) { string strId ; vector < TTo > result ( src . size ()); try { for ( int i = 0 ; i < src . size (); i ++ ) { strId = src [ i ]; result [ i ] = boost :: lexical_cast < TTo > ( strId ); } return result ; } catch ( boost :: bad_lexical_cast & ) { throw datatypes :: utils :: bad_lexical_cast ( string ( \"Failed to parse '\" ) + strId + string ( \"' in an vector as a \" ) + string ( typeid ( TTo ). name ())); } } class DATATYPES_DLL_LIB StringProcessing { public : static vector < string > Split ( const string & s , const string & separators ); static string TrimAny ( const string & s , const string & charactersToTrim ); static vector < string > SplitOnSpaces ( const string & s , bool removeEmptyEntries ); static vector < string > RemoveEmpty ( const vector < string >& s ); static vector < string > Concatenate ( const vector < vector < string >>& vars ); static void Concatenate ( vector < string >& a , const vector < string >& b ); // static bool Contains(const string& toTest, const vector<string>& toMatch, bool caseSensitive = true); static bool Contains ( const string & toTest , const string & toMatch , bool caseSensitive = true ); static bool StartsWith ( const string & toTest , const string & toMatch , bool caseSensitive = true ); static bool Equals ( const string & toTest , const string & toMatch , bool caseSensitive = true ); static bool EqualsAny ( const string & toTest , const vector < string >& toMatch , bool caseSensitive = true ); static bool StringPredicate ( const string & toTest , const string & toMatch , boost :: function < bool ( const string & , const string & ) > predicate , bool caseSensitive = true ); static string Paste ( const vector < string >& items , const string & sep = \"\" ); static vector < string > VPaste ( const vector < string >& prefixes , const string & postfix , const string & sep = \"\" ); static vector < string > VPaste ( const string & prefix , const vector < string >& postfixes , const string & sep = \"\" ); static bool ContainsAll ( const vector < string >& toTest , const vector < string >& toMatch , bool caseSensitive = true ); static bool SetEquals ( const vector < string >& toTest , const vector < string >& toMatch , bool caseSensitive = true ); static vector < string > SetDiff ( const vector < string >& toTest , const vector < string >& toRemove , bool caseSensitive = true ); static vector < string > Unique ( const vector < string >& set ); static const string kElementSeparatorToken ; static string BuildIdentifier ( vector < string > & tokens , int fromIndex , int toIndex = -1 , const string & sep = StringProcessing :: kElementSeparatorToken ); static string BuildIdentifier ( const string & a , const string & b , const string & sep = StringProcessing :: kElementSeparatorToken ); private : static bool funContains ( const string & toTest , const string & toMatch ); static bool funStartsWith ( const string & toTest , const string & toMatch ); static bool funEquals ( const string & toTest , const string & toMatch ); }; template < typename T = boost :: posix_time :: ptime > T CreateTime ( int year , int month , int day , int hour = 0 , int minute = 0 , int second = 0 ) { using namespace boost :: gregorian ; return T ( date ( year , month , day ), hours ( hour ) + minutes ( minute ) + seconds ( second )); } } namespace interop { class DATATYPES_DLL_LIB MissingValueHandling { // https://jira.csiro.au/browse/WIRADA-416 // Ways for wrappers to specify to this API what special numeric value to use // as 'missing value' code in time series interop. public : static std :: atomic < double > TimeSeriesMissingValueValue ; }; } } Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes/common.h"},{"location":"cpp/Files/common_8h/#datatypescommonh","text":"","title":"datatypes/common.h"},{"location":"cpp/Files/common_8h/#namespaces","text":"Name datatypes datatypes::utils datatypes::interop boost::posix_time boost::gregorian","title":"Namespaces"},{"location":"cpp/Files/common_8h/#classes","text":"Name class datatypes::utils::STLHelper class datatypes::utils::IfThenElse< true, Ta, Tb > class datatypes::utils::IfThenElse< false, Ta, Tb > class datatypes::utils::ValueTypeVectorDispose class datatypes::utils::PointerTypeVectorDispose struct datatypes::utils::DisposeVectorTypeFactory class datatypes::utils::bad_lexical_cast A bad_lexical_cast that inherits from std::exception, unlike Boost's. Needed for graceful C API interop. class datatypes::utils::StringProcessing class datatypes::interop::MissingValueHandling","title":"Classes"},{"location":"cpp/Files/common_8h/#defines","text":"Name DEFAULT_MISSING_DATA_VALUE DEFAULT_STATION_IDENTIFIER STRDUP STLSTR_TO_ANSISTR (x) DATATYPES_DOUBLE_PRECISION_ID DATATYPES_SINGLE_PRECISION_ID DATATYPES_FOUR_DIMENSIONS_DATA DATATYPES_THREE_DIMENSIONS_DATA DATATYPES_TWO_DIMENSIONS_DATA SWIFT_TIME_UNIT_MINUTE SWIFT_TIME_UNIT_HOUR SWIFT_TIME_UNIT_DAY SWIFT_TIME_UNIT_MONTH FILE_KEY ID_DATA_KEY VAR_KEY IDENTIFIER_KEY INDEX_KEY TYPE_KEY SINGLE_SERIES_COLLECTION_TYPE_ID A string identifier for a multivariate time series (structurally an ensemble, but not semantically, e.g. TS for multiple sites) SINGLE_SERIES_TYPE_ID A string identifier for a single univariate time series. ENSEMBLE_SERIES_TYPE_ID A string identifier for ensemble of time series (e.g. ensemble forecasts for one lead time) TIME_SERIES_ENSEMBLE_SERIES_TYPE_ID A string identifier for time series of ensemble of time series (e.g. ensemble forecasts time series) TIME_SERIES_SERIES_COLLECTION_TYPE_ID A string identifier for time series of collection of time series (e.g. forecasts for multiple sites) STORAGE_TYPE_SINGLE_NETCDF_FILE STORAGE_TYPE_MULTIPLE_NETCDF_FILES","title":"Defines"},{"location":"cpp/Files/common_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"cpp/Files/common_8h/#define-default_missing_data_value","text":"#define DEFAULT_MISSING_DATA_VALUE -9999.0","title":"define DEFAULT_MISSING_DATA_VALUE"},{"location":"cpp/Files/common_8h/#define-default_station_identifier","text":"#define DEFAULT_STATION_IDENTIFIER { \"0\" }","title":"define DEFAULT_STATION_IDENTIFIER"},{"location":"cpp/Files/common_8h/#define-strdup","text":"#define STRDUP strdup","title":"define STRDUP"},{"location":"cpp/Files/common_8h/#define-stlstr_to_ansistr","text":"#define STLSTR_TO_ANSISTR( x ) STRDUP ( x . c_str ())","title":"define STLSTR_TO_ANSISTR"},{"location":"cpp/Files/common_8h/#define-datatypes_double_precision_id","text":"#define DATATYPES_DOUBLE_PRECISION_ID \"double\"","title":"define DATATYPES_DOUBLE_PRECISION_ID"},{"location":"cpp/Files/common_8h/#define-datatypes_single_precision_id","text":"#define DATATYPES_SINGLE_PRECISION_ID \"single\"","title":"define DATATYPES_SINGLE_PRECISION_ID"},{"location":"cpp/Files/common_8h/#define-datatypes_four_dimensions_data","text":"#define DATATYPES_FOUR_DIMENSIONS_DATA \"4\"","title":"define DATATYPES_FOUR_DIMENSIONS_DATA"},{"location":"cpp/Files/common_8h/#define-datatypes_three_dimensions_data","text":"#define DATATYPES_THREE_DIMENSIONS_DATA \"3\"","title":"define DATATYPES_THREE_DIMENSIONS_DATA"},{"location":"cpp/Files/common_8h/#define-datatypes_two_dimensions_data","text":"#define DATATYPES_TWO_DIMENSIONS_DATA \"2\"","title":"define DATATYPES_TWO_DIMENSIONS_DATA"},{"location":"cpp/Files/common_8h/#define-swift_time_unit_minute","text":"#define SWIFT_TIME_UNIT_MINUTE string(\"minute\")","title":"define SWIFT_TIME_UNIT_MINUTE"},{"location":"cpp/Files/common_8h/#define-swift_time_unit_hour","text":"#define SWIFT_TIME_UNIT_HOUR string(\"hour\")","title":"define SWIFT_TIME_UNIT_HOUR"},{"location":"cpp/Files/common_8h/#define-swift_time_unit_day","text":"#define SWIFT_TIME_UNIT_DAY string(\"day\")","title":"define SWIFT_TIME_UNIT_DAY"},{"location":"cpp/Files/common_8h/#define-swift_time_unit_month","text":"#define SWIFT_TIME_UNIT_MONTH string(\"month\")","title":"define SWIFT_TIME_UNIT_MONTH"},{"location":"cpp/Files/common_8h/#define-file_key","text":"#define FILE_KEY \"File\"","title":"define FILE_KEY"},{"location":"cpp/Files/common_8h/#define-id_data_key","text":"#define ID_DATA_KEY \"Id\"","title":"define ID_DATA_KEY"},{"location":"cpp/Files/common_8h/#define-var_key","text":"#define VAR_KEY \"Var\"","title":"define VAR_KEY"},{"location":"cpp/Files/common_8h/#define-identifier_key","text":"#define IDENTIFIER_KEY \"Identifier\"","title":"define IDENTIFIER_KEY"},{"location":"cpp/Files/common_8h/#define-index_key","text":"#define INDEX_KEY \"Index\"","title":"define INDEX_KEY"},{"location":"cpp/Files/common_8h/#define-type_key","text":"#define TYPE_KEY \"Type\"","title":"define TYPE_KEY"},{"location":"cpp/Files/common_8h/#define-single_series_collection_type_id","text":"#define SINGLE_SERIES_COLLECTION_TYPE_ID \"single_collection\" A string identifier for a multivariate time series (structurally an ensemble, but not semantically, e.g. TS for multiple sites)","title":"define SINGLE_SERIES_COLLECTION_TYPE_ID"},{"location":"cpp/Files/common_8h/#define-single_series_type_id","text":"#define SINGLE_SERIES_TYPE_ID \"single\" A string identifier for a single univariate time series.","title":"define SINGLE_SERIES_TYPE_ID"},{"location":"cpp/Files/common_8h/#define-ensemble_series_type_id","text":"#define ENSEMBLE_SERIES_TYPE_ID \"ensemble_ts\" A string identifier for ensemble of time series (e.g. ensemble forecasts for one lead time)","title":"define ENSEMBLE_SERIES_TYPE_ID"},{"location":"cpp/Files/common_8h/#define-time_series_ensemble_series_type_id","text":"#define TIME_SERIES_ENSEMBLE_SERIES_TYPE_ID \"ts_ensemble_ts\" A string identifier for time series of ensemble of time series (e.g. ensemble forecasts time series)","title":"define TIME_SERIES_ENSEMBLE_SERIES_TYPE_ID"},{"location":"cpp/Files/common_8h/#define-time_series_series_collection_type_id","text":"#define TIME_SERIES_SERIES_COLLECTION_TYPE_ID \"ts_ts_collection\" A string identifier for time series of collection of time series (e.g. forecasts for multiple sites)","title":"define TIME_SERIES_SERIES_COLLECTION_TYPE_ID"},{"location":"cpp/Files/common_8h/#define-storage_type_single_netcdf_file","text":"#define STORAGE_TYPE_SINGLE_NETCDF_FILE \"single_nc_file\"","title":"define STORAGE_TYPE_SINGLE_NETCDF_FILE"},{"location":"cpp/Files/common_8h/#define-storage_type_multiple_netcdf_files","text":"#define STORAGE_TYPE_MULTIPLE_NETCDF_FILES \"multiple_nc_files_filename_date_pattern\"","title":"define STORAGE_TYPE_MULTIPLE_NETCDF_FILES"},{"location":"cpp/Files/common_8h/#source-code","text":"#pragma once #include <stdio.h> #include <atomic> #include <string> #include <vector> #include <map> #include <boost/function.hpp> #include <boost/lexical_cast.hpp> #include <boost/date_time/gregorian/gregorian.hpp> #include <boost/date_time/posix_time/posix_time.hpp> #include <datatypes/setup_exports.h> #ifdef _MSC_VER # pragma warning(push) // class blah needs to have dll-interface to be used by clients of class blah # pragma warning(disable : 4251 4231 4660 4275) #endif #define DEFAULT_MISSING_DATA_VALUE -9999.0 #define DEFAULT_STATION_IDENTIFIER { \"0\" } // You can define the following to activate the Visual Leak Detector tool for visual C++ // https://vld.codeplex.com //#define DATATYPES_USE_VLD #ifdef DATATYPES_USE_VLD #include <vld.h> #endif #ifdef _WIN32 #define STRDUP _strdup #else #define STRDUP strdup #endif #define STLSTR_TO_ANSISTR(x) STRDUP(x.c_str()) using std :: string ; using std :: vector ; using std :: map ; using std :: pair ; using namespace boost :: posix_time ; using namespace boost :: gregorian ; #define DATATYPES_DOUBLE_PRECISION_ID \"double\" #define DATATYPES_SINGLE_PRECISION_ID \"single\" #define DATATYPES_FOUR_DIMENSIONS_DATA \"4\" #define DATATYPES_THREE_DIMENSIONS_DATA \"3\" #define DATATYPES_TWO_DIMENSIONS_DATA \"2\" #define SWIFT_TIME_UNIT_MINUTE string(\"minute\") #define SWIFT_TIME_UNIT_HOUR string(\"hour\") #define SWIFT_TIME_UNIT_DAY string(\"day\") #define SWIFT_TIME_UNIT_MONTH string(\"month\") // macros for strings used as structuring identifiers or keys in std::map #define FILE_KEY \"File\" #define ID_DATA_KEY \"Id\" #define VAR_KEY \"Var\" #define IDENTIFIER_KEY \"Identifier\" #define INDEX_KEY \"Index\" #define TYPE_KEY \"Type\" #define SINGLE_SERIES_COLLECTION_TYPE_ID \"single_collection\" #define SINGLE_SERIES_TYPE_ID \"single\" #define ENSEMBLE_SERIES_TYPE_ID \"ensemble_ts\" #define TIME_SERIES_ENSEMBLE_SERIES_TYPE_ID \"ts_ensemble_ts\" #define TIME_SERIES_SERIES_COLLECTION_TYPE_ID \"ts_ts_collection\" #define STORAGE_TYPE_SINGLE_NETCDF_FILE \"single_nc_file\" #define STORAGE_TYPE_MULTIPLE_NETCDF_FILES \"multiple_nc_files_filename_date_pattern\" namespace datatypes { namespace utils { void datatypes_delete_ansi_string_array ( char ** values , int arrayLength ); class STLHelper { private : STLHelper (); template < typename U > class Comparer { std :: function < bool ( const U & , const U & ) >& valueCompare ; public : Comparer ( std :: function < bool ( const U & , const U & ) >& valueCompare ) : valueCompare ( valueCompare ) { } typedef typename vector < U >:: const_iterator const_iterator ; bool operator ()( const std :: pair < size_t , const_iterator >& a , const std :: pair < size_t , const_iterator >& b ) { return valueCompare ( * ( a . second ), * ( b . second )); } }; public : template < typename K = string , typename V = string > static bool HasKey ( const map < K , V >& dict , const string & key ) { return ( dict . find ( key ) != dict . end ()); } template < typename K = string , typename V = string > static vector < K > GetKeys ( const map < K , V >& dict ) { vector < K > res ; res . reserve ( dict . size ()); for ( auto & kvpair : dict ) res . push_back ( kvpair . first ); return res ; } template < typename K = string , typename V = string > static map < K , V > Remap ( const map < K , V >& dict , const map < K , K >& newKeys ) { map < K , V > res ; for ( const auto & kvpair : dict ) { K newKey = newKeys . at ( kvpair . first ); res [ newKey ] = kvpair . second ; } return res ; } template < typename K = string , typename V = string > static map < K , V > Zip ( const vector < K >& key , const vector < V >& values ) { map < K , V > res ; if ( key . size () > values . size ()) throw std :: logic_error ( \"Zip function must have less keys than values\" ); for ( size_t i = 0 ; i < key . size (); i ++ ) res [ key [ i ]] = values [ i ]; return res ; } template < typename K = string , typename V = string > static vector < V > GetValues ( const map < K , V >& dict ) { vector < V > res ; res . reserve ( dict . size ()); for ( auto & kvpair : dict ) res . push_back ( kvpair . second ); return res ; } template < typename K = string , typename V = string > static vector < V > GetValues ( const map < K , V >& dict , const vector < K >& keys ) { vector < V > res ; res . reserve ( keys . size ()); for ( auto & k : keys ) res . push_back ( dict . at ( k )); return res ; } template < typename U > static bool LessThan ( const U & first , const U & second ) { return first < second ; } template < typename U > static bool MoreThan ( const U & first , const U & second ) { return first > second ; } template < typename K , typename V > static vector < V > SortValues ( const std :: map < K , V >& in , const vector < K >& order ) { vector < V > result ; for ( auto & k : order ) { if ( ! HasKey ( in , k )) throw std :: logic_error ( \"No entry in std::map for key \" + k ); result . push_back ( in . at ( k )); } return result ; } template < typename T > static vector < T > Serialize ( const vector < vector < T >>& series ) { vector < T > result ; for ( size_t i = 0 ; i < series . size (); i ++ ) { auto & v = series [ i ]; auto n = result . size (); auto m = v . size (); result . resize ( n + m ); std :: copy ( v . begin (), v . end (), result . begin () + n ); } return result ; } template < typename T , typename U > static vector < T > SortFromRef ( const vector < T >& in , const vector < U >& reference , std :: function < bool ( const U & , const U & ) > comparer = STLHelper :: LessThan < U > ) { // Attribution: derived from http://stackoverflow.com/a/236199/2752565, Konrad Rudolph typedef typename vector < U >:: const_iterator myiter ; vector < std :: pair < size_t , myiter >> order ( reference . size ()); size_t n = 0 ; for ( myiter it = reference . begin (); it != reference . end (); ++ it , ++ n ) order [ n ] = std :: make_pair ( n , it ); Comparer < U > ordering ( comparer ); sort ( order . begin (), order . end (), ordering ); vector < T > ret ( in . size ()); size_t const size = in . size (); for ( size_t i = 0 ; i < size ; ++ i ) ret [ i ] = in [ order [ i ]. first ]; return ret ; } }; template < typename T = double > vector < T > SeqVec ( T from , T by , size_t num ) { vector < T > data ; data . resize ( num ); for ( size_t i = 0 ; i < num ; i ++ ) data [ i ] = from + (( T ) i ) * by ; return data ; } // Could not find an easy if_then_else in the STL or Boost. IfThenElse will probably be replaced. // primary template: yield second or third argument depending on first argument template < bool C , typename Ta , typename Tb > class IfThenElse ; // Credits: // C++ templates : the complete guide / David Vandevoorde, Nicolai M. Josuttis. // ISBN 0 - 201 - 73484 - 2 (alk.paper) // partial specialization: true yields second argument template < typename Ta , typename Tb > class IfThenElse < true , Ta , Tb > { public : typedef Ta ResultT ; }; // partial specialization: false yields third argument template < typename Ta , typename Tb > class IfThenElse < false , Ta , Tb > { public : typedef Tb ResultT ; }; template < typename T > class ValueTypeVectorDispose { public : static void Dispose ( vector < T >& a ) { a . clear (); } }; template < typename T > class PointerTypeVectorDispose { public : static void Dispose ( vector < T >& a ) { for ( size_t i = 0 ; i < a . size (); i ++ ) { auto p = a [ i ]; if ( p != nullptr ) delete p ; } a . clear (); } }; template < typename T > struct DisposeVectorTypeFactory { typedef typename IfThenElse < std :: is_pointer < T >:: value , ValueTypeVectorDispose < T > , PointerTypeVectorDispose < T > >:: ResultT type ; }; template < typename T > void DisposeVector ( vector < T >& v ) { using U = typename datatypes :: utils :: DisposeVectorTypeFactory < T >:: type ; U :: Dispose ( v ); } class DATATYPES_DLL_LIB bad_lexical_cast : public std :: invalid_argument { public : bad_lexical_cast ( const string & msg ); }; template < typename Target > static Target Parse ( const string & strId ) { try { return boost :: lexical_cast < Target > ( strId ); } catch ( boost :: bad_lexical_cast & ) { throw datatypes :: utils :: bad_lexical_cast ( string ( \"Failed to parse '\" ) + strId + string ( \"' as a \" ) + string ( typeid ( Target ). name ())); } } template < typename Source > static string ToString ( const Source & value ) { try { return boost :: lexical_cast < string > ( value ); } catch ( boost :: bad_lexical_cast & ) { throw datatypes :: utils :: bad_lexical_cast ( string ( \"Failed to convert a value of type '\" ) + string ( typeid ( Source ). name ()) + string ( \"' to a string\" )); } } template < class TTo > static TTo * ConvertToArray ( const vector < string >& src ) { string & strId ; TTo * result = new TTo [ src . size ()]; try { for ( int i = 0 ; i < src . size (); i ++ ) { strId = src [ i ]; result [ i ] = boost :: lexical_cast < TTo > ( strId ); } return result ; } catch ( boost :: bad_lexical_cast & c ) { delete result ; throw datatypes :: utils :: bad_lexical_cast ( string ( \"Failed to parse '\" ) + strId + string ( \"' in an vector as a \" ) + string ( typeid ( TTo ). name ())); } } template < class TFrom , class TTo > static TTo * ConvertToArray ( const vector < TFrom >& src ) { TTo * result = new TTo [ src . size ()]; try { for ( int i = 0 ; i < src . size (); i ++ ) { result [ i ] = ( TTo ) src [ i ]; } return result ; } catch ( std :: exception & c ) { delete result ; throw datatypes :: utils :: bad_lexical_cast ( string ( \"Failed to convert vector of \" ) + string ( typeid ( TFrom ). name ()) + string ( \" to an array of \" ) + string ( typeid ( TTo ). name ())); } } template < class TFrom , class TTo > static vector < TTo > Convert ( const vector < TFrom >& src ) { vector < TTo > result ( src . size ()); try { for ( int i = 0 ; i < src . size (); i ++ ) result [ i ] = ( TTo ) src [ i ]; return result ; } catch ( std :: exception & ) { string msg = ( string ( \"Failed to convert vector of \" ) + string ( typeid ( TFrom ). name ()) + string ( \" to a vector of \" ) + string ( typeid ( TTo ). name ())); throw datatypes :: utils :: bad_lexical_cast ( msg ); } } template < class TTo > vector < TTo > Convert ( const vector < string > & src ) { string strId ; vector < TTo > result ( src . size ()); try { for ( int i = 0 ; i < src . size (); i ++ ) { strId = src [ i ]; result [ i ] = boost :: lexical_cast < TTo > ( strId ); } return result ; } catch ( boost :: bad_lexical_cast & ) { throw datatypes :: utils :: bad_lexical_cast ( string ( \"Failed to parse '\" ) + strId + string ( \"' in an vector as a \" ) + string ( typeid ( TTo ). name ())); } } class DATATYPES_DLL_LIB StringProcessing { public : static vector < string > Split ( const string & s , const string & separators ); static string TrimAny ( const string & s , const string & charactersToTrim ); static vector < string > SplitOnSpaces ( const string & s , bool removeEmptyEntries ); static vector < string > RemoveEmpty ( const vector < string >& s ); static vector < string > Concatenate ( const vector < vector < string >>& vars ); static void Concatenate ( vector < string >& a , const vector < string >& b ); // static bool Contains(const string& toTest, const vector<string>& toMatch, bool caseSensitive = true); static bool Contains ( const string & toTest , const string & toMatch , bool caseSensitive = true ); static bool StartsWith ( const string & toTest , const string & toMatch , bool caseSensitive = true ); static bool Equals ( const string & toTest , const string & toMatch , bool caseSensitive = true ); static bool EqualsAny ( const string & toTest , const vector < string >& toMatch , bool caseSensitive = true ); static bool StringPredicate ( const string & toTest , const string & toMatch , boost :: function < bool ( const string & , const string & ) > predicate , bool caseSensitive = true ); static string Paste ( const vector < string >& items , const string & sep = \"\" ); static vector < string > VPaste ( const vector < string >& prefixes , const string & postfix , const string & sep = \"\" ); static vector < string > VPaste ( const string & prefix , const vector < string >& postfixes , const string & sep = \"\" ); static bool ContainsAll ( const vector < string >& toTest , const vector < string >& toMatch , bool caseSensitive = true ); static bool SetEquals ( const vector < string >& toTest , const vector < string >& toMatch , bool caseSensitive = true ); static vector < string > SetDiff ( const vector < string >& toTest , const vector < string >& toRemove , bool caseSensitive = true ); static vector < string > Unique ( const vector < string >& set ); static const string kElementSeparatorToken ; static string BuildIdentifier ( vector < string > & tokens , int fromIndex , int toIndex = -1 , const string & sep = StringProcessing :: kElementSeparatorToken ); static string BuildIdentifier ( const string & a , const string & b , const string & sep = StringProcessing :: kElementSeparatorToken ); private : static bool funContains ( const string & toTest , const string & toMatch ); static bool funStartsWith ( const string & toTest , const string & toMatch ); static bool funEquals ( const string & toTest , const string & toMatch ); }; template < typename T = boost :: posix_time :: ptime > T CreateTime ( int year , int month , int day , int hour = 0 , int minute = 0 , int second = 0 ) { using namespace boost :: gregorian ; return T ( date ( year , month , day ), hours ( hour ) + minutes ( minute ) + seconds ( second )); } } namespace interop { class DATATYPES_DLL_LIB MissingValueHandling { // https://jira.csiro.au/browse/WIRADA-416 // Ways for wrappers to specify to this API what special numeric value to use // as 'missing value' code in time series interop. public : static std :: atomic < double > TimeSeriesMissingValueValue ; }; } } Updated on 2022-08-20 at 19:28:22 +1000","title":"Source code"},{"location":"cpp/Files/datatypes__test__helpers_8h/","text":"datatypes/datatypes_test_helpers.h \u00b6 Namespaces \u00b6 Name datatypes datatypes::tests Classes \u00b6 Name class datatypes::tests::FileSystemHelper class datatypes::tests::TempFileCleaner class datatypes::tests::TestDataLocationHelper class datatypes::tests::TestSingleTimeSeriesStore class datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore A time series store for unit tests. class datatypes::tests::TestEnsembleTimeSeriesStore class datatypes::tests::TestTimeSeriesStoreFactory Source code \u00b6 #pragma once #include \"datatypes/common.h\" #include \"datatypes/time_series_store.hpp\" using namespace datatypes :: timeseries ; namespace datatypes { namespace tests { template < typename T > bool AreEqual ( const vector < T >& a , const vector < T >& b , bool strict = false , double tolerance = 1e-12 ) { size_t lengthA = a . size (); size_t lengthB = b . size (); if ( lengthA != lengthB ) return false ; for ( size_t i = 0 ; i < lengthA ; i ++ ) { auto valA = a [ i ]; auto valB = b [ i ]; if ( strict && ( valA != valB )) return false ; else if ( std :: abs ( valA - valB ) > tolerance ) return false ; } return true ; } class DATATYPES_DLL_LIB FileSystemHelper { public : static boost :: filesystem :: path GetTempFile ( const string & format = \"%%%%%%%%%%%%.tmp\" ); static boost :: filesystem :: path GetTempDir ( const string & format = \"%%%%%%%%%%%%\" ); static void Remove ( const boost :: filesystem :: path & p ); static void Remove ( const string & p ); static bool Exists ( const string & p ); static bool Exists ( const boost :: filesystem :: path & p ); }; class DATATYPES_DLL_LIB TempFileCleaner { public : string uri ; TempFileCleaner ( const string uri ); ~ TempFileCleaner (); }; class DATATYPES_DLL_LIB TestDataLocationHelper { public : static string ReadEnvironmentVariable ( const string & envVar ); static string BuildPath ( const vector < string >& folders ); static TimeSeriesLibrary CreateEnsembleTimeSeriesLibrary ( string & rainObsId , string & petObsId , string & rainFcastId , string & petFcastId ); static TimeSeriesLibrary GetTestTimeSeriesLibrary (); static vector < string > TestTsLibraryIdentifiers (); static TimeSeriesLibrary * CreateTestTimeSeriesLibrary (); static void MakeTestTimeSeriesLibrary ( TimeSeriesLibrary & dataLibrary ); const static string kVarSingleStation ; const static string kVarMultiStations ; const static string kFileSingleStation ; const static string kFileMultiStations ; const static string kFileAllDataCases ; const static string kVar1FcastEns ; const static string kVar2FcastEns ; const static string kVar1Obs ; const static string kVar2Obs ; const static string kVar1Ens ; const static string kVar2Ens ; const static string kIdentifier1FcastEns ; const static string kIdentifier2FcastEns ; const static string kIdentifier1Obs ; const static string kIdentifier2Obs ; const static string kIdentifier1Ens ; const static string kIdentifier2Ens ; const static string kSingleStationId ; const static string kStationIdOne ; const static string kStationIdTwo ; const static size_t kTimeSeriesLength ; static vector < string > TestStationIds (); }; class DATATYPES_DLL_LIB TestSingleTimeSeriesStore : public SingleTimeSeriesStore < double > { public : TestSingleTimeSeriesStore ( const vector < double >& values , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly ()); TestSingleTimeSeriesStore ( const TimeSeries & series ); string GetDataSummary () const ; vector < DataDimensionDescriptor > GetDataDimensionsDescription () const ; TTimeSeries < double >* Read (); TTimeSeries < double >* Read ( const string & blah ); MultiTimeSeries < TTimeSeries < double >*>* ReadAllCollection (); std :: vector < std :: string > GetIdentifiers () const ; private : TTimeSeries < double > innerTs ; }; class DATATYPES_DLL_LIB TestTimeSeriesEnsembleTimeSeriesStore : public WritableTimeSeriesEnsembleTimeSeriesStore < double > { public : using T = double ; using SeriesType = CommonTypes < T >:: SeriesType ; using PtrSeriesType = CommonTypes < T >:: PtrSeriesType ; using EnsemblePtrType = CommonTypes < T >:: EnsemblePtrType ; using PtrEnsemblePtrType = CommonTypes < T >:: PtrEnsemblePtrType ; using TSeriesEnsemblePtrType = CommonTypes < T >:: TSeriesEnsemblePtrType ; using PtrTSeriesEnsemblePtrType = CommonTypes < T >:: PtrTSeriesEnsemblePtrType ; ~ TestTimeSeriesEnsembleTimeSeriesStore (); TestTimeSeriesEnsembleTimeSeriesStore ( const string & id = \"\" ); TestTimeSeriesEnsembleTimeSeriesStore ( const TSeriesEnsemblePtrType & ensFts , const string & id = \"\" ); PtrTSeriesEnsemblePtrType GetSeries ( const string & dataId ); PtrTSeriesEnsemblePtrType GetSeriesTestBackend ( const string & dataId ); PtrEnsemblePtrType Read ( const std :: string & ensembleIdentifier ); size_t GetLength () const ; ptime GetStart () const ; //vector<string> GetItemIdentifiers() const; string GetDataSummary () const ; vector < DataDimensionDescriptor > GetDataDimensionsDescription () const ; TimeStep GetTimeStep () const ; bool IsActive (); void Allocate ( size_t length , PtrEnsemblePtrType value ); void AllocateValues ( const vector < PtrEnsemblePtrType >& values ); void SetSeries ( const string & dataId , PtrTSeriesEnsemblePtrType value ); void SetItem ( const string & dataId , size_t index , PtrEnsemblePtrType value ); void SetItem ( const string & dataId , size_t index , const EnsemblePtrType & value ); //EnsemblePtrType Read(const string& ensembleIdentifier) = 0; void SetLength ( size_t ); void SetStart ( ptime ); //vector<string> GetItemIdentifiers() const = 0; void SetTimeStep ( const TimeStep & ); PtrEnsemblePtrType GetItem ( const string & dataId , size_t fcastIndex ) override ; PtrSeriesType GetItem ( const string & dataId , size_t fcastIndex , size_t ensIndex ) override ; size_t GetEnsembleSize ( const string & dataId , size_t fcastIndex ) const override ; private : PtrTSeriesEnsemblePtrType GetFirstTsEnsTs () const ; PtrTSeriesEnsemblePtrType CreateNewSeries (); std :: map < string , PtrTSeriesEnsemblePtrType > ensFcastsSeries ; bool allowDynamicCreation = false ; //PtrTSeriesEnsemblePtrType ensFts; //string id; }; class DATATYPES_DLL_LIB TestEnsembleTimeSeriesStore : public EnsembleTimeSeriesStore < double > { public : TestEnsembleTimeSeriesStore ( const MultiTimeSeries <>& data ); MultiTimeSeries < TTimeSeries < double >*>* Read (); string GetDataSummary () const ; vector < DataDimensionDescriptor > GetDataDimensionsDescription () const ; private : MultiTimeSeries <> data ; }; class DATATYPES_DLL_LIB TestTimeSeriesStoreFactory : public TimeSeriesStoreFactory { public : TestTimeSeriesStoreFactory (); ~ TestTimeSeriesStoreFactory (); TimeSeriesEnsembleTimeSeriesStore < double >* CreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ); bool CanCreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ); }; } } Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes/datatypes_test_helpers.h"},{"location":"cpp/Files/datatypes__test__helpers_8h/#datatypesdatatypes_test_helpersh","text":"","title":"datatypes/datatypes_test_helpers.h"},{"location":"cpp/Files/datatypes__test__helpers_8h/#namespaces","text":"Name datatypes datatypes::tests","title":"Namespaces"},{"location":"cpp/Files/datatypes__test__helpers_8h/#classes","text":"Name class datatypes::tests::FileSystemHelper class datatypes::tests::TempFileCleaner class datatypes::tests::TestDataLocationHelper class datatypes::tests::TestSingleTimeSeriesStore class datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore A time series store for unit tests. class datatypes::tests::TestEnsembleTimeSeriesStore class datatypes::tests::TestTimeSeriesStoreFactory","title":"Classes"},{"location":"cpp/Files/datatypes__test__helpers_8h/#source-code","text":"#pragma once #include \"datatypes/common.h\" #include \"datatypes/time_series_store.hpp\" using namespace datatypes :: timeseries ; namespace datatypes { namespace tests { template < typename T > bool AreEqual ( const vector < T >& a , const vector < T >& b , bool strict = false , double tolerance = 1e-12 ) { size_t lengthA = a . size (); size_t lengthB = b . size (); if ( lengthA != lengthB ) return false ; for ( size_t i = 0 ; i < lengthA ; i ++ ) { auto valA = a [ i ]; auto valB = b [ i ]; if ( strict && ( valA != valB )) return false ; else if ( std :: abs ( valA - valB ) > tolerance ) return false ; } return true ; } class DATATYPES_DLL_LIB FileSystemHelper { public : static boost :: filesystem :: path GetTempFile ( const string & format = \"%%%%%%%%%%%%.tmp\" ); static boost :: filesystem :: path GetTempDir ( const string & format = \"%%%%%%%%%%%%\" ); static void Remove ( const boost :: filesystem :: path & p ); static void Remove ( const string & p ); static bool Exists ( const string & p ); static bool Exists ( const boost :: filesystem :: path & p ); }; class DATATYPES_DLL_LIB TempFileCleaner { public : string uri ; TempFileCleaner ( const string uri ); ~ TempFileCleaner (); }; class DATATYPES_DLL_LIB TestDataLocationHelper { public : static string ReadEnvironmentVariable ( const string & envVar ); static string BuildPath ( const vector < string >& folders ); static TimeSeriesLibrary CreateEnsembleTimeSeriesLibrary ( string & rainObsId , string & petObsId , string & rainFcastId , string & petFcastId ); static TimeSeriesLibrary GetTestTimeSeriesLibrary (); static vector < string > TestTsLibraryIdentifiers (); static TimeSeriesLibrary * CreateTestTimeSeriesLibrary (); static void MakeTestTimeSeriesLibrary ( TimeSeriesLibrary & dataLibrary ); const static string kVarSingleStation ; const static string kVarMultiStations ; const static string kFileSingleStation ; const static string kFileMultiStations ; const static string kFileAllDataCases ; const static string kVar1FcastEns ; const static string kVar2FcastEns ; const static string kVar1Obs ; const static string kVar2Obs ; const static string kVar1Ens ; const static string kVar2Ens ; const static string kIdentifier1FcastEns ; const static string kIdentifier2FcastEns ; const static string kIdentifier1Obs ; const static string kIdentifier2Obs ; const static string kIdentifier1Ens ; const static string kIdentifier2Ens ; const static string kSingleStationId ; const static string kStationIdOne ; const static string kStationIdTwo ; const static size_t kTimeSeriesLength ; static vector < string > TestStationIds (); }; class DATATYPES_DLL_LIB TestSingleTimeSeriesStore : public SingleTimeSeriesStore < double > { public : TestSingleTimeSeriesStore ( const vector < double >& values , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly ()); TestSingleTimeSeriesStore ( const TimeSeries & series ); string GetDataSummary () const ; vector < DataDimensionDescriptor > GetDataDimensionsDescription () const ; TTimeSeries < double >* Read (); TTimeSeries < double >* Read ( const string & blah ); MultiTimeSeries < TTimeSeries < double >*>* ReadAllCollection (); std :: vector < std :: string > GetIdentifiers () const ; private : TTimeSeries < double > innerTs ; }; class DATATYPES_DLL_LIB TestTimeSeriesEnsembleTimeSeriesStore : public WritableTimeSeriesEnsembleTimeSeriesStore < double > { public : using T = double ; using SeriesType = CommonTypes < T >:: SeriesType ; using PtrSeriesType = CommonTypes < T >:: PtrSeriesType ; using EnsemblePtrType = CommonTypes < T >:: EnsemblePtrType ; using PtrEnsemblePtrType = CommonTypes < T >:: PtrEnsemblePtrType ; using TSeriesEnsemblePtrType = CommonTypes < T >:: TSeriesEnsemblePtrType ; using PtrTSeriesEnsemblePtrType = CommonTypes < T >:: PtrTSeriesEnsemblePtrType ; ~ TestTimeSeriesEnsembleTimeSeriesStore (); TestTimeSeriesEnsembleTimeSeriesStore ( const string & id = \"\" ); TestTimeSeriesEnsembleTimeSeriesStore ( const TSeriesEnsemblePtrType & ensFts , const string & id = \"\" ); PtrTSeriesEnsemblePtrType GetSeries ( const string & dataId ); PtrTSeriesEnsemblePtrType GetSeriesTestBackend ( const string & dataId ); PtrEnsemblePtrType Read ( const std :: string & ensembleIdentifier ); size_t GetLength () const ; ptime GetStart () const ; //vector<string> GetItemIdentifiers() const; string GetDataSummary () const ; vector < DataDimensionDescriptor > GetDataDimensionsDescription () const ; TimeStep GetTimeStep () const ; bool IsActive (); void Allocate ( size_t length , PtrEnsemblePtrType value ); void AllocateValues ( const vector < PtrEnsemblePtrType >& values ); void SetSeries ( const string & dataId , PtrTSeriesEnsemblePtrType value ); void SetItem ( const string & dataId , size_t index , PtrEnsemblePtrType value ); void SetItem ( const string & dataId , size_t index , const EnsemblePtrType & value ); //EnsemblePtrType Read(const string& ensembleIdentifier) = 0; void SetLength ( size_t ); void SetStart ( ptime ); //vector<string> GetItemIdentifiers() const = 0; void SetTimeStep ( const TimeStep & ); PtrEnsemblePtrType GetItem ( const string & dataId , size_t fcastIndex ) override ; PtrSeriesType GetItem ( const string & dataId , size_t fcastIndex , size_t ensIndex ) override ; size_t GetEnsembleSize ( const string & dataId , size_t fcastIndex ) const override ; private : PtrTSeriesEnsemblePtrType GetFirstTsEnsTs () const ; PtrTSeriesEnsemblePtrType CreateNewSeries (); std :: map < string , PtrTSeriesEnsemblePtrType > ensFcastsSeries ; bool allowDynamicCreation = false ; //PtrTSeriesEnsemblePtrType ensFts; //string id; }; class DATATYPES_DLL_LIB TestEnsembleTimeSeriesStore : public EnsembleTimeSeriesStore < double > { public : TestEnsembleTimeSeriesStore ( const MultiTimeSeries <>& data ); MultiTimeSeries < TTimeSeries < double >*>* Read (); string GetDataSummary () const ; vector < DataDimensionDescriptor > GetDataDimensionsDescription () const ; private : MultiTimeSeries <> data ; }; class DATATYPES_DLL_LIB TestTimeSeriesStoreFactory : public TimeSeriesStoreFactory { public : TestTimeSeriesStoreFactory (); ~ TestTimeSeriesStoreFactory (); TimeSeriesEnsembleTimeSeriesStore < double >* CreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ); bool CanCreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ); }; } } Updated on 2022-08-20 at 19:28:22 +1000","title":"Source code"},{"location":"cpp/Files/datatypes__test__helpers_8hpp/","text":"datatypes/datatypes_test_helpers.hpp \u00b6 Namespaces \u00b6 Name datatypes datatypes::tests std Classes \u00b6 Name class datatypes::tests::DataTestHelper Types \u00b6 Name using datatypes::tests::DataTestHelper < double > DTH Defines \u00b6 Name TEST_START_TIME Types Documentation \u00b6 using DTH \u00b6 using DTH = datatypes :: tests :: DataTestHelper < double > ; Macros Documentation \u00b6 define TEST_START_TIME \u00b6 #define TEST_START_TIME ptime(date(2010, 8, 1)) + hours(14) Source code \u00b6 #pragma once #include <boost/filesystem.hpp> #include \"datatypes/common.h\" #include \"datatypes/time_series.hpp\" #include \"datatypes/time_series_io.hpp\" #define TEST_START_TIME ptime(date(2010, 8, 1)) + hours(14) using namespace boost :: gregorian ; using namespace datatypes :: timeseries ; using namespace std ; namespace datatypes { namespace tests { template < typename T > bool AllEqual ( const vector < T >& values , T testValue ) { for ( int i = 0 ; i < values . size (); i ++ ) if ( values [ i ] != testValue ) return false ; return true ; } template < typename T > bool VectorEqual ( const vector < T >& a , const vector < T >& b ) { if ( a . size () != b . size ()) return false ; for ( int i = 0 ; i < a . size (); i ++ ) if ( a [ i ] != b [ i ]) return false ; return true ; } template < typename T > class DataTestHelper { public : using SeriesType = typename CommonTypes < T >:: SeriesType ; using PtrSeriesType = typename CommonTypes < T >:: PtrSeriesType ; using EnsembleType = typename CommonTypes < T >:: EnsembleType ; using EnsemblePtrType = typename CommonTypes < T >:: EnsemblePtrType ; using PtrEnsemblePtrType = typename CommonTypes < T >:: PtrEnsemblePtrType ; using TSeriesEnsemblePtrType = typename CommonTypes < T >:: TSeriesEnsemblePtrType ; using PtrTSeriesEnsemblePtrType = typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType ; static TTimeSeries < T > Create ( T * data , int num , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetHourly ()); static TTimeSeries < T > Ramp ( int num , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), double from = 0.0 , double increment = 1.0 ); static TTimeSeries < T > Pulse ( int length , T value = 1 , int firstPulse = 0 , int period = 2 , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetHourly ()); const static size_t kTimeSeriesLength = 48 ; static TTimeSeries < T > GetExpectedTestSingleTimeSeries ( size_t indexInEnsemble , size_t length = kTimeSeriesLength , double constOffset = 1 , const ptime & startDate = TEST_START_TIME , const TimeStep & timeStep = TimeStep :: GetHourly ()); static T * Seq ( T from , T by , size_t num ); static vector < T > SeqVec ( T from , T by , size_t num ); static vector < T > Rep ( T value , size_t num ); static vector < T > Add ( const vector < T >& a , const vector < T >& b ); static vector < T > Add ( const vector < T >& a , const T & b ); static vector < T > Add ( const T & a , const vector < T >& b ); static vector < T > Mult ( const vector < T >& a , const vector < T >& b ); static vector < T > Mult ( const vector < T >& a , const T & b ); static vector < T > Mult ( const T & a , const vector < T >& b ); static vector < T > Neg ( const vector < T >& a ); static vector < T *>* Seq ( T from , T by , size_t num , size_t vecSize ); static void DeleteElements ( vector < T *>& vec ); static bool AreEqual ( PtrSeriesType expected , PtrSeriesType actual ); static bool AreEqual ( PtrSeriesType actual , T expected ); // A function that generates a value in an ensemble fcast time series: (fcastIndex, ensIndex, seriesIndex) -> T typedef std :: function < T ( size_t /*fcastIndex*/ , size_t /*ensIndex*/ , size_t /*seriesIndex*/ ) > FullElementValueFunc ; // A function that generates an item for a time series: (seriesIndex) -> T typedef std :: function < T ( size_t /*seriesIndex*/ ) > ElementValueFunc ; // A function that generates a time series for an index in an ensemble: (ensembleIndex) -> TS typedef std :: function < SeriesType ( size_t /*ensembleIndex*/ ) > EnsembleValueFunc ; // A function that generates an ensemble given an index in the ens fcst TS: (index) -> EnsemblePtrType typedef std :: function < EnsemblePtrType ( size_t /*tsEnsTsItemIndex*/ ) > TsEnsembleValueFunc ; static T DecimalRamp ( size_t fcastIndex , size_t ensIndex , size_t seriesIndex ) { return ( T )( fcastIndex + 0.1 * ensIndex + 0.01 * seriesIndex ); } static ElementValueFunc CreateValueGen ( size_t fcastIndex , size_t ensIndex , FullElementValueFunc ffun = & DecimalRamp ) { ElementValueFunc valueGen = [ = ]( size_t seriesIndex ) { return ffun ( fcastIndex , ensIndex , seriesIndex ); }; return valueGen ; } static T Identity ( size_t i ) { return ( T ) i ; } static EnsembleValueFunc CreateTsGen ( const ptime & start , size_t tsLength , size_t fcastIndex , const TimeStep & timeStep = TimeStep :: GetHourly (), FullElementValueFunc ffun = & DecimalRamp ) { return [ = ]( size_t ensIndex ) { ElementValueFunc valueGen = CreateValueGen ( fcastIndex , ensIndex , ffun ); return TTimeSeries < T > ( valueGen , tsLength , start , timeStep ); }; } static TsEnsembleValueFunc CreateMtsGen ( size_t ensSize , size_t tsLength , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetDaily (), const TimeStep & timeStepFcasts = TimeStep :: GetHourly (), FullElementValueFunc ffun = & DecimalRamp , int forecastStartOffset = 1 ) { auto result = [ = ]( size_t fcastIndex ) { ptime fcastIssueDate = timeStep . AddSteps ( start , fcastIndex ); ptime fcastStart = timeStepFcasts . AddSteps ( fcastIssueDate , forecastStartOffset ); auto tsGen = CreateTsGen ( fcastStart , tsLength , fcastIndex , timeStepFcasts , ffun ); EnsemblePtrType mts ( tsGen , ensSize , fcastStart , timeStepFcasts ); return mts ; }; return result ; } static EnsembleValueFunc DefaultTsGen () { return CreateTsGen ( ptime ( date ( 2000 , 1 , 1 )), 5 /*tsLength*/ , 0 /*fcastIndex*/ ); } static EnsemblePtrType CreateEnsembleTs ( size_t ensSize , size_t length , const ptime & start , const TimeStep & timeStep , size_t fcastIndex = 0 , FullElementValueFunc ffun = & DecimalRamp ) { EnsembleValueFunc tsGen = CreateTsGen ( start , length /*tsLength*/ , fcastIndex /*fcastIndex*/ , timeStep , ffun ); vector < TTimeSeries < T >> values ( ensSize ); for ( size_t i = 0 ; i < ensSize ; i ++ ) { values [ i ] = tsGen ( i ); } return EnsemblePtrType ( values , start , timeStep ); } static EnsemblePtrType CreateEnsembleTs ( size_t ensSize , size_t length , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetDaily (), EnsembleValueFunc tsGen = DefaultTsGen ()) { vector < TTimeSeries < T >> values ( ensSize ); for ( size_t i = 0 ; i < ensSize ; i ++ ) { values [ i ] = tsGen ( i ); } return EnsemblePtrType ( values , start , timeStep ); } static TsEnsembleValueFunc DefaultMtsGen () { const size_t DefaultTestEnsembleSize = 3 ; const size_t DefaultTestTimeseriesLength = 5 ; return CreateMtsGen ( DefaultTestEnsembleSize /*ensSize*/ , DefaultTestTimeseriesLength /*tsLength*/ ); } static TSeriesEnsemblePtrType CreateTsEnsembleTs ( size_t length , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetDaily (), TsEnsembleValueFunc mtsGen = DefaultMtsGen () ) { TSeriesEnsemblePtrType e ( length , start , timeStep ); for ( size_t i = 0 ; i < length ; i ++ ) { EnsemblePtrType v = mtsGen ( i ); e [ i ] = new EnsemblePtrType ( v ); } return e ; } static TSeriesEnsemblePtrType CreateTsEnsembleTs ( size_t length , size_t ensSize , size_t tsLength , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetDaily (), const TimeStep & timeStepFcasts = TimeStep :: GetHourly (), FullElementValueFunc ffun = & DecimalRamp , int forecastStartOffset = 1 ) { TsEnsembleValueFunc mtsGen = CreateMtsGen ( ensSize , tsLength , start , timeStep , timeStepFcasts , ffun , forecastStartOffset ); return CreateTsEnsembleTs ( length , start , timeStep , mtsGen ); } }; template < typename T > TTimeSeries < T > DataTestHelper < T >:: Pulse ( int length , T value , int firstPulse , int period , const ptime & start , const TimeStep & timeStep ) { vector < T > values ( length ); for ( size_t i = 0 ; i < length ; i ++ ) values [ i ] = ((( i - firstPulse ) % period ) == 0 ? value : 0 ); return TTimeSeries < T > ( values , start , timeStep ); } template < typename T > TTimeSeries < T > DataTestHelper < T >:: Create ( T * data , int num , const ptime & start , const TimeStep & timeStep ) { return TTimeSeries < T > ( data , num , start , timeStep ); } template < typename T > vector < T > DataTestHelper < T >:: Add ( const vector < T >& a , const vector < T >& b ) { if ( a . size () != b . size ()) ExceptionUtilities :: ThrowInvalidOperation ( \"vector addition: vectors must be of the same size\" ); auto c = a ; for ( size_t i = 0 ; i < a . size (); i ++ ) { c [ i ] += b [ i ]; } return c ; } template < typename T > vector < T > DataTestHelper < T >:: Add ( const vector < T >& a , const T & b ) { auto c = a ; for ( size_t i = 0 ; i < a . size (); i ++ ) { c [ i ] += b ; } return c ; } template < typename T > vector < T > DataTestHelper < T >:: Add ( const T & a , const vector < T >& b ) { return Add ( b , a ); } template < typename T > vector < T > DataTestHelper < T >:: Rep ( T value , size_t num ) { vector < T > x ; x . assign ( num , value ); return x ; } template < typename T > vector < T > DataTestHelper < T >:: Mult ( const vector < T >& a , const vector < T >& b ) { if ( a . size () != b . size ()) ExceptionUtilities :: ThrowInvalidOperation ( \"vector addition: vectors must be of the same size\" ); auto c = a ; for ( size_t i = 0 ; i < a . size (); i ++ ) { c [ i ] *= b [ i ]; } return c ; } template < typename T > vector < T > DataTestHelper < T >:: Mult ( const vector < T >& a , const T & b ) { auto c = a ; for ( size_t i = 0 ; i < a . size (); i ++ ) { c [ i ] *= b ; } return c ; } template < typename T > vector < T > DataTestHelper < T >:: Mult ( const T & a , const vector < T >& b ) { return Mult ( b , a ); } template < typename T > vector < T > DataTestHelper < T >:: Neg ( const vector < T >& a ) { auto c = a ; for ( size_t i = 0 ; i < a . size (); i ++ ) { c [ i ] = - c [ i ]; } return c ; } } } using DTH = datatypes :: tests :: DataTestHelper < double > ; namespace datatypes { namespace tests { template < typename T > TTimeSeries < T > DataTestHelper < T >:: GetExpectedTestSingleTimeSeries ( size_t indexInEnsemble , size_t length , double constOffset , const ptime & startDate , const TimeStep & timeStep ) { //if(length(v2)>0) { // for (k in 1:length(v2)) { // # dummy <- k %% 2 # KLUDGE just for backward compat reasons - existing unit tests. // for (j in 1:length(stationIds)) { // varValues <- k + 0.1*j + 0.01 * timeSteps // station <- stationIds[j] // snc$putSingleSeries(varValues, varName = v2[k], identifier = station) // } // } // } T k = constOffset ; int j = indexInEnsemble + 1 ; auto varValues = DTH :: Rep ( k , length ); varValues = DTH :: Add ( varValues , DTH :: Rep ( j * 0.1 , length )); auto timeSteps = DTH :: SeqVec ( 1.0 , 1.0 , length ); varValues = DTH :: Add ( varValues , DTH :: Mult ( timeSteps , 0.01 )); return TTimeSeries < T > ( varValues , startDate , timeStep ); } template < typename T > void DataTestHelper < T >:: DeleteElements ( vector < T *>& vec ) { for ( int i = 0 ; i < vec . size (); i ++ ) delete [] vec [ i ]; } template < typename T > T * DataTestHelper < T >:: Seq ( T from , T by , size_t num ) { T * data = new T [ num ]; for ( size_t i = 0 ; i < num ; i ++ ) data [ i ] = from + i * by ; return data ; } template < typename T > vector < T > DataTestHelper < T >:: SeqVec ( T from , T by , size_t num ) { return datatypes :: utils :: SeqVec < T > ( from , by , num ); } template < typename T > vector < T *> * DataTestHelper < T >:: Seq ( T from , T by , size_t num , size_t vecSize ) { vector < T *> * result = new vector < T *> (); for ( size_t i = 0 ; i < vecSize ; i ++ ) result -> push_back ( Seq ( from + i * ( by * num ), by , num )); return result ; } template < typename T > TTimeSeries < T > DataTestHelper < T >:: Ramp ( int num , const ptime & start , double from , double increment ) { T * data = Seq ( from , increment , num ); auto ts = Create ( data , num , start ); delete data ; return ts ; } template < typename T > bool DataTestHelper < T >:: AreEqual ( PtrSeriesType expected , PtrSeriesType actual ) { if ( actual == nullptr ) return false ; if ( expected == nullptr ) return false ; return datatypes :: timeseries :: TimeSeriesOperations < TTimeSeries < T >>:: AreTimeSeriesEqual ( * expected , * actual ); } template < typename T > bool DataTestHelper < T >:: AreEqual ( PtrSeriesType actual , T expected ) { if ( actual == nullptr ) return false ; return datatypes :: timeseries :: TimeSeriesOperations < TTimeSeries < T >>:: template AreEqual < T > ( * actual , expected ); } } } Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes/datatypes_test_helpers.hpp"},{"location":"cpp/Files/datatypes__test__helpers_8hpp/#datatypesdatatypes_test_helpershpp","text":"","title":"datatypes/datatypes_test_helpers.hpp"},{"location":"cpp/Files/datatypes__test__helpers_8hpp/#namespaces","text":"Name datatypes datatypes::tests std","title":"Namespaces"},{"location":"cpp/Files/datatypes__test__helpers_8hpp/#classes","text":"Name class datatypes::tests::DataTestHelper","title":"Classes"},{"location":"cpp/Files/datatypes__test__helpers_8hpp/#types","text":"Name using datatypes::tests::DataTestHelper < double > DTH","title":"Types"},{"location":"cpp/Files/datatypes__test__helpers_8hpp/#defines","text":"Name TEST_START_TIME","title":"Defines"},{"location":"cpp/Files/datatypes__test__helpers_8hpp/#types-documentation","text":"","title":"Types Documentation"},{"location":"cpp/Files/datatypes__test__helpers_8hpp/#using-dth","text":"using DTH = datatypes :: tests :: DataTestHelper < double > ;","title":"using DTH"},{"location":"cpp/Files/datatypes__test__helpers_8hpp/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"cpp/Files/datatypes__test__helpers_8hpp/#define-test_start_time","text":"#define TEST_START_TIME ptime(date(2010, 8, 1)) + hours(14)","title":"define TEST_START_TIME"},{"location":"cpp/Files/datatypes__test__helpers_8hpp/#source-code","text":"#pragma once #include <boost/filesystem.hpp> #include \"datatypes/common.h\" #include \"datatypes/time_series.hpp\" #include \"datatypes/time_series_io.hpp\" #define TEST_START_TIME ptime(date(2010, 8, 1)) + hours(14) using namespace boost :: gregorian ; using namespace datatypes :: timeseries ; using namespace std ; namespace datatypes { namespace tests { template < typename T > bool AllEqual ( const vector < T >& values , T testValue ) { for ( int i = 0 ; i < values . size (); i ++ ) if ( values [ i ] != testValue ) return false ; return true ; } template < typename T > bool VectorEqual ( const vector < T >& a , const vector < T >& b ) { if ( a . size () != b . size ()) return false ; for ( int i = 0 ; i < a . size (); i ++ ) if ( a [ i ] != b [ i ]) return false ; return true ; } template < typename T > class DataTestHelper { public : using SeriesType = typename CommonTypes < T >:: SeriesType ; using PtrSeriesType = typename CommonTypes < T >:: PtrSeriesType ; using EnsembleType = typename CommonTypes < T >:: EnsembleType ; using EnsemblePtrType = typename CommonTypes < T >:: EnsemblePtrType ; using PtrEnsemblePtrType = typename CommonTypes < T >:: PtrEnsemblePtrType ; using TSeriesEnsemblePtrType = typename CommonTypes < T >:: TSeriesEnsemblePtrType ; using PtrTSeriesEnsemblePtrType = typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType ; static TTimeSeries < T > Create ( T * data , int num , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetHourly ()); static TTimeSeries < T > Ramp ( int num , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), double from = 0.0 , double increment = 1.0 ); static TTimeSeries < T > Pulse ( int length , T value = 1 , int firstPulse = 0 , int period = 2 , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetHourly ()); const static size_t kTimeSeriesLength = 48 ; static TTimeSeries < T > GetExpectedTestSingleTimeSeries ( size_t indexInEnsemble , size_t length = kTimeSeriesLength , double constOffset = 1 , const ptime & startDate = TEST_START_TIME , const TimeStep & timeStep = TimeStep :: GetHourly ()); static T * Seq ( T from , T by , size_t num ); static vector < T > SeqVec ( T from , T by , size_t num ); static vector < T > Rep ( T value , size_t num ); static vector < T > Add ( const vector < T >& a , const vector < T >& b ); static vector < T > Add ( const vector < T >& a , const T & b ); static vector < T > Add ( const T & a , const vector < T >& b ); static vector < T > Mult ( const vector < T >& a , const vector < T >& b ); static vector < T > Mult ( const vector < T >& a , const T & b ); static vector < T > Mult ( const T & a , const vector < T >& b ); static vector < T > Neg ( const vector < T >& a ); static vector < T *>* Seq ( T from , T by , size_t num , size_t vecSize ); static void DeleteElements ( vector < T *>& vec ); static bool AreEqual ( PtrSeriesType expected , PtrSeriesType actual ); static bool AreEqual ( PtrSeriesType actual , T expected ); // A function that generates a value in an ensemble fcast time series: (fcastIndex, ensIndex, seriesIndex) -> T typedef std :: function < T ( size_t /*fcastIndex*/ , size_t /*ensIndex*/ , size_t /*seriesIndex*/ ) > FullElementValueFunc ; // A function that generates an item for a time series: (seriesIndex) -> T typedef std :: function < T ( size_t /*seriesIndex*/ ) > ElementValueFunc ; // A function that generates a time series for an index in an ensemble: (ensembleIndex) -> TS typedef std :: function < SeriesType ( size_t /*ensembleIndex*/ ) > EnsembleValueFunc ; // A function that generates an ensemble given an index in the ens fcst TS: (index) -> EnsemblePtrType typedef std :: function < EnsemblePtrType ( size_t /*tsEnsTsItemIndex*/ ) > TsEnsembleValueFunc ; static T DecimalRamp ( size_t fcastIndex , size_t ensIndex , size_t seriesIndex ) { return ( T )( fcastIndex + 0.1 * ensIndex + 0.01 * seriesIndex ); } static ElementValueFunc CreateValueGen ( size_t fcastIndex , size_t ensIndex , FullElementValueFunc ffun = & DecimalRamp ) { ElementValueFunc valueGen = [ = ]( size_t seriesIndex ) { return ffun ( fcastIndex , ensIndex , seriesIndex ); }; return valueGen ; } static T Identity ( size_t i ) { return ( T ) i ; } static EnsembleValueFunc CreateTsGen ( const ptime & start , size_t tsLength , size_t fcastIndex , const TimeStep & timeStep = TimeStep :: GetHourly (), FullElementValueFunc ffun = & DecimalRamp ) { return [ = ]( size_t ensIndex ) { ElementValueFunc valueGen = CreateValueGen ( fcastIndex , ensIndex , ffun ); return TTimeSeries < T > ( valueGen , tsLength , start , timeStep ); }; } static TsEnsembleValueFunc CreateMtsGen ( size_t ensSize , size_t tsLength , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetDaily (), const TimeStep & timeStepFcasts = TimeStep :: GetHourly (), FullElementValueFunc ffun = & DecimalRamp , int forecastStartOffset = 1 ) { auto result = [ = ]( size_t fcastIndex ) { ptime fcastIssueDate = timeStep . AddSteps ( start , fcastIndex ); ptime fcastStart = timeStepFcasts . AddSteps ( fcastIssueDate , forecastStartOffset ); auto tsGen = CreateTsGen ( fcastStart , tsLength , fcastIndex , timeStepFcasts , ffun ); EnsemblePtrType mts ( tsGen , ensSize , fcastStart , timeStepFcasts ); return mts ; }; return result ; } static EnsembleValueFunc DefaultTsGen () { return CreateTsGen ( ptime ( date ( 2000 , 1 , 1 )), 5 /*tsLength*/ , 0 /*fcastIndex*/ ); } static EnsemblePtrType CreateEnsembleTs ( size_t ensSize , size_t length , const ptime & start , const TimeStep & timeStep , size_t fcastIndex = 0 , FullElementValueFunc ffun = & DecimalRamp ) { EnsembleValueFunc tsGen = CreateTsGen ( start , length /*tsLength*/ , fcastIndex /*fcastIndex*/ , timeStep , ffun ); vector < TTimeSeries < T >> values ( ensSize ); for ( size_t i = 0 ; i < ensSize ; i ++ ) { values [ i ] = tsGen ( i ); } return EnsemblePtrType ( values , start , timeStep ); } static EnsemblePtrType CreateEnsembleTs ( size_t ensSize , size_t length , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetDaily (), EnsembleValueFunc tsGen = DefaultTsGen ()) { vector < TTimeSeries < T >> values ( ensSize ); for ( size_t i = 0 ; i < ensSize ; i ++ ) { values [ i ] = tsGen ( i ); } return EnsemblePtrType ( values , start , timeStep ); } static TsEnsembleValueFunc DefaultMtsGen () { const size_t DefaultTestEnsembleSize = 3 ; const size_t DefaultTestTimeseriesLength = 5 ; return CreateMtsGen ( DefaultTestEnsembleSize /*ensSize*/ , DefaultTestTimeseriesLength /*tsLength*/ ); } static TSeriesEnsemblePtrType CreateTsEnsembleTs ( size_t length , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetDaily (), TsEnsembleValueFunc mtsGen = DefaultMtsGen () ) { TSeriesEnsemblePtrType e ( length , start , timeStep ); for ( size_t i = 0 ; i < length ; i ++ ) { EnsemblePtrType v = mtsGen ( i ); e [ i ] = new EnsemblePtrType ( v ); } return e ; } static TSeriesEnsemblePtrType CreateTsEnsembleTs ( size_t length , size_t ensSize , size_t tsLength , const ptime & start = ptime ( date ( 2000 , 1 , 1 )), const TimeStep & timeStep = TimeStep :: GetDaily (), const TimeStep & timeStepFcasts = TimeStep :: GetHourly (), FullElementValueFunc ffun = & DecimalRamp , int forecastStartOffset = 1 ) { TsEnsembleValueFunc mtsGen = CreateMtsGen ( ensSize , tsLength , start , timeStep , timeStepFcasts , ffun , forecastStartOffset ); return CreateTsEnsembleTs ( length , start , timeStep , mtsGen ); } }; template < typename T > TTimeSeries < T > DataTestHelper < T >:: Pulse ( int length , T value , int firstPulse , int period , const ptime & start , const TimeStep & timeStep ) { vector < T > values ( length ); for ( size_t i = 0 ; i < length ; i ++ ) values [ i ] = ((( i - firstPulse ) % period ) == 0 ? value : 0 ); return TTimeSeries < T > ( values , start , timeStep ); } template < typename T > TTimeSeries < T > DataTestHelper < T >:: Create ( T * data , int num , const ptime & start , const TimeStep & timeStep ) { return TTimeSeries < T > ( data , num , start , timeStep ); } template < typename T > vector < T > DataTestHelper < T >:: Add ( const vector < T >& a , const vector < T >& b ) { if ( a . size () != b . size ()) ExceptionUtilities :: ThrowInvalidOperation ( \"vector addition: vectors must be of the same size\" ); auto c = a ; for ( size_t i = 0 ; i < a . size (); i ++ ) { c [ i ] += b [ i ]; } return c ; } template < typename T > vector < T > DataTestHelper < T >:: Add ( const vector < T >& a , const T & b ) { auto c = a ; for ( size_t i = 0 ; i < a . size (); i ++ ) { c [ i ] += b ; } return c ; } template < typename T > vector < T > DataTestHelper < T >:: Add ( const T & a , const vector < T >& b ) { return Add ( b , a ); } template < typename T > vector < T > DataTestHelper < T >:: Rep ( T value , size_t num ) { vector < T > x ; x . assign ( num , value ); return x ; } template < typename T > vector < T > DataTestHelper < T >:: Mult ( const vector < T >& a , const vector < T >& b ) { if ( a . size () != b . size ()) ExceptionUtilities :: ThrowInvalidOperation ( \"vector addition: vectors must be of the same size\" ); auto c = a ; for ( size_t i = 0 ; i < a . size (); i ++ ) { c [ i ] *= b [ i ]; } return c ; } template < typename T > vector < T > DataTestHelper < T >:: Mult ( const vector < T >& a , const T & b ) { auto c = a ; for ( size_t i = 0 ; i < a . size (); i ++ ) { c [ i ] *= b ; } return c ; } template < typename T > vector < T > DataTestHelper < T >:: Mult ( const T & a , const vector < T >& b ) { return Mult ( b , a ); } template < typename T > vector < T > DataTestHelper < T >:: Neg ( const vector < T >& a ) { auto c = a ; for ( size_t i = 0 ; i < a . size (); i ++ ) { c [ i ] = - c [ i ]; } return c ; } } } using DTH = datatypes :: tests :: DataTestHelper < double > ; namespace datatypes { namespace tests { template < typename T > TTimeSeries < T > DataTestHelper < T >:: GetExpectedTestSingleTimeSeries ( size_t indexInEnsemble , size_t length , double constOffset , const ptime & startDate , const TimeStep & timeStep ) { //if(length(v2)>0) { // for (k in 1:length(v2)) { // # dummy <- k %% 2 # KLUDGE just for backward compat reasons - existing unit tests. // for (j in 1:length(stationIds)) { // varValues <- k + 0.1*j + 0.01 * timeSteps // station <- stationIds[j] // snc$putSingleSeries(varValues, varName = v2[k], identifier = station) // } // } // } T k = constOffset ; int j = indexInEnsemble + 1 ; auto varValues = DTH :: Rep ( k , length ); varValues = DTH :: Add ( varValues , DTH :: Rep ( j * 0.1 , length )); auto timeSteps = DTH :: SeqVec ( 1.0 , 1.0 , length ); varValues = DTH :: Add ( varValues , DTH :: Mult ( timeSteps , 0.01 )); return TTimeSeries < T > ( varValues , startDate , timeStep ); } template < typename T > void DataTestHelper < T >:: DeleteElements ( vector < T *>& vec ) { for ( int i = 0 ; i < vec . size (); i ++ ) delete [] vec [ i ]; } template < typename T > T * DataTestHelper < T >:: Seq ( T from , T by , size_t num ) { T * data = new T [ num ]; for ( size_t i = 0 ; i < num ; i ++ ) data [ i ] = from + i * by ; return data ; } template < typename T > vector < T > DataTestHelper < T >:: SeqVec ( T from , T by , size_t num ) { return datatypes :: utils :: SeqVec < T > ( from , by , num ); } template < typename T > vector < T *> * DataTestHelper < T >:: Seq ( T from , T by , size_t num , size_t vecSize ) { vector < T *> * result = new vector < T *> (); for ( size_t i = 0 ; i < vecSize ; i ++ ) result -> push_back ( Seq ( from + i * ( by * num ), by , num )); return result ; } template < typename T > TTimeSeries < T > DataTestHelper < T >:: Ramp ( int num , const ptime & start , double from , double increment ) { T * data = Seq ( from , increment , num ); auto ts = Create ( data , num , start ); delete data ; return ts ; } template < typename T > bool DataTestHelper < T >:: AreEqual ( PtrSeriesType expected , PtrSeriesType actual ) { if ( actual == nullptr ) return false ; if ( expected == nullptr ) return false ; return datatypes :: timeseries :: TimeSeriesOperations < TTimeSeries < T >>:: AreTimeSeriesEqual ( * expected , * actual ); } template < typename T > bool DataTestHelper < T >:: AreEqual ( PtrSeriesType actual , T expected ) { if ( actual == nullptr ) return false ; return datatypes :: timeseries :: TimeSeriesOperations < TTimeSeries < T >>:: template AreEqual < T > ( * actual , expected ); } } } Updated on 2022-08-20 at 19:28:22 +1000","title":"Source code"},{"location":"cpp/Files/dir_0c0283090ae1ae91fb4631a97d59a09f/","text":"include \u00b6 Directories \u00b6 Name datatypes Updated on 2022-08-20 at 19:28:22 +1000","title":"include"},{"location":"cpp/Files/dir_0c0283090ae1ae91fb4631a97d59a09f/#include","text":"","title":"include"},{"location":"cpp/Files/dir_0c0283090ae1ae91fb4631a97d59a09f/#directories","text":"Name datatypes Updated on 2022-08-20 at 19:28:22 +1000","title":"Directories"},{"location":"cpp/Files/dir_18b6d35ebdb182d50a05341eac4c9c15/","text":"datatypes \u00b6 Files \u00b6 Name datatypes/common.h datatypes/datatypes_test_helpers.h datatypes/datatypes_test_helpers.hpp datatypes/exception_utilities.h datatypes/extern_c_api.h datatypes/extern_c_api_as_opaque.h datatypes/extern_c_api_as_transparent.h datatypes/extern_c_api_transparent_pointers.h datatypes/internals_c_api.hpp datatypes/interop_conversions.h datatypes/interop_conversions.hpp datatypes/interop_struct.h datatypes/io_helper.h datatypes/setup_exports.h datatypes/shared_pointer_conversions.hpp datatypes/time_series.hpp datatypes/time_series_io.hpp datatypes/time_series_store.hpp datatypes/time_series_strategies.hpp datatypes/time_step.h datatypes/time_step_implementation.h Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes"},{"location":"cpp/Files/dir_18b6d35ebdb182d50a05341eac4c9c15/#datatypes","text":"","title":"datatypes"},{"location":"cpp/Files/dir_18b6d35ebdb182d50a05341eac4c9c15/#files","text":"Name datatypes/common.h datatypes/datatypes_test_helpers.h datatypes/datatypes_test_helpers.hpp datatypes/exception_utilities.h datatypes/extern_c_api.h datatypes/extern_c_api_as_opaque.h datatypes/extern_c_api_as_transparent.h datatypes/extern_c_api_transparent_pointers.h datatypes/internals_c_api.hpp datatypes/interop_conversions.h datatypes/interop_conversions.hpp datatypes/interop_struct.h datatypes/io_helper.h datatypes/setup_exports.h datatypes/shared_pointer_conversions.hpp datatypes/time_series.hpp datatypes/time_series_io.hpp datatypes/time_series_store.hpp datatypes/time_series_strategies.hpp datatypes/time_step.h datatypes/time_step_implementation.h Updated on 2022-08-20 at 19:28:22 +1000","title":"Files"},{"location":"cpp/Files/dir_1b70f9f628d353f28779bff85cfc8047/","text":"datatypes \u00b6 Directories \u00b6 Name include Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes"},{"location":"cpp/Files/dir_1b70f9f628d353f28779bff85cfc8047/#datatypes","text":"","title":"datatypes"},{"location":"cpp/Files/dir_1b70f9f628d353f28779bff85cfc8047/#directories","text":"Name include Updated on 2022-08-20 at 19:28:22 +1000","title":"Directories"},{"location":"cpp/Files/dir_3916de72b8b95e910c6a3b58752f61a8/","text":"datatypes \u00b6 Directories \u00b6 Name datatypes Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes"},{"location":"cpp/Files/dir_3916de72b8b95e910c6a3b58752f61a8/#datatypes","text":"","title":"datatypes"},{"location":"cpp/Files/dir_3916de72b8b95e910c6a3b58752f61a8/#directories","text":"Name datatypes Updated on 2022-08-20 at 19:28:22 +1000","title":"Directories"},{"location":"cpp/Files/exception__utilities_8h/","text":"datatypes/exception_utilities.h \u00b6 Namespaces \u00b6 Name datatypes datatypes::exceptions Classes \u00b6 Name struct datatypes::exceptions::RangeCheck struct datatypes::exceptions::RangeCheck< size_t > class datatypes::exceptions::ExceptionUtilities Source code \u00b6 #pragma once #include <string> #include <stdexcept> #include <boost/filesystem.hpp> #include \"datatypes/io_helper.h\" using std :: string ; using std :: vector ; using std :: map ; using std :: pair ; namespace datatypes { namespace exceptions { template < typename T > static void ThrowNotInRange ( T value , T bound , const string & variableName , const string & condition , const string & boundType ) { throw std :: out_of_range ( string ( \"variable '\" ) + variableName + \"' (=\" + datatypes :: utils :: ToString < T > ( value ) + \") is \" + condition + \" than its allowed \" + boundType + \" value \" + datatypes :: utils :: ToString < T > ( bound )); } template < typename T > struct RangeCheck { static void Check ( T value , T min , T max , const string & variableName ) { if ( value >= min && value <= max ) return ; else { if ( value < min ) ThrowNotInRange ( value , min , variableName , \"less\" , \"minimum\" ); if ( value > max ) ThrowNotInRange ( value , max , variableName , \"more\" , \"maximum\" ); } } }; template <> struct RangeCheck < size_t > { static size_t MaxIndexing () { return ( std :: numeric_limits < size_t >:: max () - 2 ); } static void Check ( size_t value , size_t min , size_t max , const string & variableName ) { if (( min > MaxIndexing ()) || ( max > MaxIndexing ())) throw std :: logic_error ( \"Range check is restricted to values less than <size_t>::max()-2\" ); if ( value >= min && value <= max ) return ; else { if ( value < min ) ThrowNotInRange ( value , min , variableName , \"less\" , \"minimum\" ); if ( value > max ) ThrowNotInRange ( value , max , variableName , \"more\" , \"maximum\" ); } } static void CheckTimeSeriesInterval ( const size_t & from , size_t & to , const size_t & tsLength ) { if ( tsLength == 0 ) throw std :: out_of_range ( \"Cannot have a valid index specified for an empty time series\" ); size_t maxIndex = tsLength - 1 ; if ( to > MaxIndexing ()) to = std :: min ( to , maxIndex ); Check ( from , 0 , maxIndex , \"from\" ); Check ( to , 0 , maxIndex , \"to\" ); } static void CheckTimeSeriesIndex ( const size_t & index , const size_t & tsLength , const string & variableName = \"index\" ) { if ( tsLength == 0 ) throw std :: out_of_range ( \"Cannot have a valid index specified for an empty time series\" ); size_t maxIndex = tsLength - 1 ; Check ( index , 0 , maxIndex , variableName ); } }; class ExceptionUtilities { public : static void ThrowInvalidArgument ( const string & msg = \"Invalid argument\" ) { throw std :: invalid_argument ( msg ); } static void ThrowInvalidOperation ( const string & msg = \"Invalid operation\" ) { throw std :: logic_error ( msg ); } static void ThrowInvalidArgumentModelVariableId ( const string & variableId ) { throw std :: invalid_argument ( string ( \"Unknown model variable identifier: \" ) + variableId ); } static void ThrowNotImplemented ( const string & msg = \"Not implemented\" ) { throw std :: logic_error ( msg ); } static void ThrowNotSupported ( const string & typeName , const string & methodName ) { throw std :: logic_error ( \"Type \" + typeName + \" does not support method \" + methodName ); } static void ThrowNotSupported ( const string & msg ) { throw std :: logic_error ( msg ); } static void ThrowOutOfRange ( const string & msg = \"Operation led to a state out of range\" ) { throw std :: out_of_range ( msg ); } template < typename T > static void CheckInRange ( T value , T min , T max , const string & variableName ) { RangeCheck < T >:: Check ( value , min , max , variableName ); } static void CheckFileExists ( const boost :: filesystem :: path & p ) { if ( ! boost :: filesystem :: exists ( p )) throw std :: invalid_argument ( string ( \"Path does not exist: \" ) + p . generic_string ()); if ( ! boost :: filesystem :: is_regular_file ( p )) throw std :: invalid_argument ( string ( \"Path exists but is not a regular file: \" ) + p . generic_string ()); } static void CheckFileDoesNotExist ( const boost :: filesystem :: path & p ) { if ( boost :: filesystem :: exists ( p )) throw std :: invalid_argument ( string ( \"Path already exists: \" ) + p . generic_string ()); } static void CheckExists ( const boost :: filesystem :: path & p ) { if ( ! boost :: filesystem :: exists ( p )) throw std :: invalid_argument ( string ( \"Path does not exist: \" ) + p . generic_string ()); } }; } } Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes/exception_utilities.h"},{"location":"cpp/Files/exception__utilities_8h/#datatypesexception_utilitiesh","text":"","title":"datatypes/exception_utilities.h"},{"location":"cpp/Files/exception__utilities_8h/#namespaces","text":"Name datatypes datatypes::exceptions","title":"Namespaces"},{"location":"cpp/Files/exception__utilities_8h/#classes","text":"Name struct datatypes::exceptions::RangeCheck struct datatypes::exceptions::RangeCheck< size_t > class datatypes::exceptions::ExceptionUtilities","title":"Classes"},{"location":"cpp/Files/exception__utilities_8h/#source-code","text":"#pragma once #include <string> #include <stdexcept> #include <boost/filesystem.hpp> #include \"datatypes/io_helper.h\" using std :: string ; using std :: vector ; using std :: map ; using std :: pair ; namespace datatypes { namespace exceptions { template < typename T > static void ThrowNotInRange ( T value , T bound , const string & variableName , const string & condition , const string & boundType ) { throw std :: out_of_range ( string ( \"variable '\" ) + variableName + \"' (=\" + datatypes :: utils :: ToString < T > ( value ) + \") is \" + condition + \" than its allowed \" + boundType + \" value \" + datatypes :: utils :: ToString < T > ( bound )); } template < typename T > struct RangeCheck { static void Check ( T value , T min , T max , const string & variableName ) { if ( value >= min && value <= max ) return ; else { if ( value < min ) ThrowNotInRange ( value , min , variableName , \"less\" , \"minimum\" ); if ( value > max ) ThrowNotInRange ( value , max , variableName , \"more\" , \"maximum\" ); } } }; template <> struct RangeCheck < size_t > { static size_t MaxIndexing () { return ( std :: numeric_limits < size_t >:: max () - 2 ); } static void Check ( size_t value , size_t min , size_t max , const string & variableName ) { if (( min > MaxIndexing ()) || ( max > MaxIndexing ())) throw std :: logic_error ( \"Range check is restricted to values less than <size_t>::max()-2\" ); if ( value >= min && value <= max ) return ; else { if ( value < min ) ThrowNotInRange ( value , min , variableName , \"less\" , \"minimum\" ); if ( value > max ) ThrowNotInRange ( value , max , variableName , \"more\" , \"maximum\" ); } } static void CheckTimeSeriesInterval ( const size_t & from , size_t & to , const size_t & tsLength ) { if ( tsLength == 0 ) throw std :: out_of_range ( \"Cannot have a valid index specified for an empty time series\" ); size_t maxIndex = tsLength - 1 ; if ( to > MaxIndexing ()) to = std :: min ( to , maxIndex ); Check ( from , 0 , maxIndex , \"from\" ); Check ( to , 0 , maxIndex , \"to\" ); } static void CheckTimeSeriesIndex ( const size_t & index , const size_t & tsLength , const string & variableName = \"index\" ) { if ( tsLength == 0 ) throw std :: out_of_range ( \"Cannot have a valid index specified for an empty time series\" ); size_t maxIndex = tsLength - 1 ; Check ( index , 0 , maxIndex , variableName ); } }; class ExceptionUtilities { public : static void ThrowInvalidArgument ( const string & msg = \"Invalid argument\" ) { throw std :: invalid_argument ( msg ); } static void ThrowInvalidOperation ( const string & msg = \"Invalid operation\" ) { throw std :: logic_error ( msg ); } static void ThrowInvalidArgumentModelVariableId ( const string & variableId ) { throw std :: invalid_argument ( string ( \"Unknown model variable identifier: \" ) + variableId ); } static void ThrowNotImplemented ( const string & msg = \"Not implemented\" ) { throw std :: logic_error ( msg ); } static void ThrowNotSupported ( const string & typeName , const string & methodName ) { throw std :: logic_error ( \"Type \" + typeName + \" does not support method \" + methodName ); } static void ThrowNotSupported ( const string & msg ) { throw std :: logic_error ( msg ); } static void ThrowOutOfRange ( const string & msg = \"Operation led to a state out of range\" ) { throw std :: out_of_range ( msg ); } template < typename T > static void CheckInRange ( T value , T min , T max , const string & variableName ) { RangeCheck < T >:: Check ( value , min , max , variableName ); } static void CheckFileExists ( const boost :: filesystem :: path & p ) { if ( ! boost :: filesystem :: exists ( p )) throw std :: invalid_argument ( string ( \"Path does not exist: \" ) + p . generic_string ()); if ( ! boost :: filesystem :: is_regular_file ( p )) throw std :: invalid_argument ( string ( \"Path exists but is not a regular file: \" ) + p . generic_string ()); } static void CheckFileDoesNotExist ( const boost :: filesystem :: path & p ) { if ( boost :: filesystem :: exists ( p )) throw std :: invalid_argument ( string ( \"Path already exists: \" ) + p . generic_string ()); } static void CheckExists ( const boost :: filesystem :: path & p ) { if ( ! boost :: filesystem :: exists ( p )) throw std :: invalid_argument ( string ( \"Path does not exist: \" ) + p . generic_string ()); } }; } } Updated on 2022-08-20 at 19:28:22 +1000","title":"Source code"},{"location":"cpp/Files/extern__c__api_8h/","text":"datatypes/extern_c_api.h \u00b6 More... Functions \u00b6 Name DATATYPES_API char * GetLastStdExceptionMessage () Gets the last message from an std::exception caught by the uchronia API. DATATYPES_API void RegisterExceptionCallback (const void * callback) DATATYPES_API void DisposeSharedPointer (VOID_PTR_PROVIDER_PTR ptr) Notifies uchronia that an object managed by an opaque pointer is not used by the caller anymore. DATATYPES_API void DeleteAnsiStringArray (char ** values, int arrayLength) Deletes the ANSI string array , which has been create by uchronia. Do not use for char** created outside libswift. DATATYPES_API void DeleteAnsiString (const char * value) Deletes the ANSI string which has been create by uchronia. Do not use for char* created outside libswift. DATATYPES_API void DeleteDoubleArray (double * value) Dispose of an array of double created via this C API. DATATYPES_API void SetTimeSeriesMissingValueValue (double missingValueValue) Sets a value whoch should be considered as a missing value when data is passed to this C API. DATATYPES_API ENSEMBLE_DATA_SET_PTR LoadEnsembleDataset (const char * libraryIdentifier, const char * dataPath) Creates a time series library, defined (for now) by a YAML descriptor. DATATYPES_API ENSEMBLE_DATA_SET_PTR CreateEnsembleDataset (const char * type) Creates a time series library. DATATYPES_API char ** GetEnsembleDatasetDataIdentifiers ( ENSEMBLE_DATA_SET_PTR dataLibrary, int * size) Gets the highest level datasets' IDs known to this library. DATATYPES_API char ** GetEnsembleDatasetDataSubIdentifiers ( ENSEMBLE_DATA_SET_PTR dataLibrary, const char * dataCollectionId, int * size) Gets sub identifiers, if any, in a hierarchical ID scheme (e.g. if a collection of streamflows is such that you can ID each series as \"streamflow.gauge_id\") DATATYPES_API char ** GetEnsembleDatasetDataSummaries ( ENSEMBLE_DATA_SET_PTR dataLibrary, int * size) DATATYPES_API time_series_dimensions_description * GetDataDimensionsDescription ( ENSEMBLE_DATA_SET_PTR dataLibrary, const char * dataId) Gets data dimensions description. This function is useful for wrappers to discover the dimensionality of a data set before trying to load it in memory. DATATYPES_API int EnsembleSizeEnsembleTimeSeries ( ENSEMBLE_PTR_TIME_SERIES_PTR ensSeries) DATATYPES_API void DisposeDataDimensionsDescriptions (time_series_dimensions_description * data) DATATYPES_API ENSEMBLE_FORECAST_TIME_SERIES_PTR CreateEnsembleForecastTimeSeries (date_time_to_second start, int length, const char * timeStepName) DATATYPES_API TIME_SERIES_PTR GetDatasetSingleTimeSeries ( ENSEMBLE_DATA_SET_PTR dataLibrary, const char * dataId) DATATYPES_API ENSEMBLE_PTR_TIME_SERIES_PTR GetDatasetEnsembleTimeSeries ( ENSEMBLE_DATA_SET_PTR dataLibrary, const char * dataEnsembleId) DATATYPES_API ENSEMBLE_FORECAST_TIME_SERIES_PTR GetDatasetEnsembleForecastTimeSeries ( ENSEMBLE_DATA_SET_PTR dataLibrary, const char * dataId) DATATYPES_API void SaveSingleTimeSeriesToNetcdf ( TIME_SERIES_PTR timeSeries, const char * filename, bool overwrite) DATATYPES_API void SaveEnsembleTimeSeriesToNetcdf ( ENSEMBLE_PTR_TIME_SERIES_PTR collection, const char * filename, bool overwrite) DATATYPES_API void SaveEnsembleForecastTimeSeriesToNetcdf ( ENSEMBLE_FORECAST_TIME_SERIES_PTR tsEnsTs, const char * filename, bool overwrite) DATATYPES_API bool IsMissingValueItemEnsembleForecastTimeSeries ( ENSEMBLE_FORECAST_TIME_SERIES_PTR series, int i) DATATYPES_API ENSEMBLE_PTR_TIME_SERIES_PTR GetItemEnsembleForecastTimeSeries ( ENSEMBLE_FORECAST_TIME_SERIES_PTR efts, int i) DATATYPES_API TIME_SERIES_PTR TimeSeriesFromEnsembleOfTimeSeries ( ENSEMBLE_PTR_TIME_SERIES_PTR collectionTs, int index) DATATYPES_API TIME_SERIES_PTR TimeSeriesFromTimeSeriesOfEnsembleOfTimeSeries ( ENSEMBLE_FORECAST_TIME_SERIES_PTR efts, int indexInIssueTime, int indexInForecastTime) DATATYPES_API double GetValueFromUnivariateTimeSeries ( TIME_SERIES_PTR ts, int index) DATATYPES_API void TransformEachItem ( ENSEMBLE_FORECAST_TIME_SERIES_PTR tsEnsTs, const char * method, const char * methodArgument) DATATYPES_API void SetValueToUnivariateTimeSeries ( TIME_SERIES_PTR ts, int index, double value) DATATYPES_API multi_regular_time_series_data * GetItemEnsembleForecastTimeSeriesAsStructure ( ENSEMBLE_FORECAST_TIME_SERIES_PTR series, int i) DATATYPES_API multi_regular_time_series_data * GetItemEnsembleTimeSeriesAsStructure ( ENSEMBLE_PTR_TIME_SERIES_PTR series, int i) DATATYPES_API void SetItemEnsembleForecastTimeSeriesAsStructure ( ENSEMBLE_FORECAST_TIME_SERIES_PTR series, int i, const multi_regular_time_series_data * values) DATATYPES_API void SetItemEnsembleTimeSeriesAsStructure ( ENSEMBLE_PTR_TIME_SERIES_PTR collection, int i, const multi_regular_time_series_data * values) DATATYPES_API ENSEMBLE_FORECAST_TIME_SERIES_PTR CreatePerfectForecastTimeSeries ( TIME_SERIES_PTR observations, date_time_to_second start, int length, const char * timeStepName, int offsetForecasts, int leadTime) DATATYPES_API multi_regular_time_series_data * ToStructEnsembleTimeSeriesData ( ENSEMBLE_PTR_TIME_SERIES_PTR ensSeries) DATATYPES_API multi_regular_time_series_data * ToStructSingleTimeSeriesData ( TIME_SERIES_PTR timeSeries) DATATYPES_API ENSEMBLE_PTR_TIME_SERIES_PTR CreateEnsembleTimeSeriesDataFromStruct (const multi_regular_time_series_data * ensSeries) DATATYPES_API TIME_SERIES_PTR CreateSingleTimeSeriesDataFromStruct (const multi_regular_time_series_data * timeSeries) DATATYPES_API void DisposeMultiTimeSeriesData (multi_regular_time_series_data * data) DATATYPES_API void GetTimeSeriesGeometry ( TIME_SERIES_PTR timeSeries, TS_GEOMETRY_PTR geom) DATATYPES_API void GetEnsembleForecastTimeSeriesGeometry ( ENSEMBLE_FORECAST_TIME_SERIES_PTR timeSeries, TS_GEOMETRY_PTR geom) DATATYPES_API void GetTimeSeriesValues ( TIME_SERIES_PTR timeSeries, double * values, int arrayLength) DATATYPES_API int GetNumTimeSeries () DATATYPES_API void GetProviderTsGeometry ( TIME_SERIES_PROVIDER_PTR dataLibrary, const char * variableIdentifier, TS_GEOMETRY_PTR geom) DATATYPES_API void GetProviderTimeSeriesValues ( TIME_SERIES_PROVIDER_PTR dataLibrary, const char * variableIdentifier, double * values, int arrayLength) DATATYPES_API char ** GetProviderTimeSeriesIdentifiers ( TIME_SERIES_PROVIDER_PTR dataLibrary, int * size) DATATYPES_API TIME_SERIES_PTR TimeSeriesFromProviderTs ( TIME_SERIES_PROVIDER_PTR dataLibrary, const char * variableIdentifier) Defines \u00b6 Name DATATYPES_USE_CPP_POINTERS DATATYPES_API Detailed Description \u00b6 API for libswift. This file exposes a common API for interacting with libswift from other tools. Functions Documentation \u00b6 function GetLastStdExceptionMessage \u00b6 DATATYPES_API char * GetLastStdExceptionMessage () Gets the last message from an std::exception caught by the uchronia API. Return : the last standard exception message. function RegisterExceptionCallback \u00b6 DATATYPES_API void RegisterExceptionCallback ( const void * callback ) function DisposeSharedPointer \u00b6 DATATYPES_API void DisposeSharedPointer ( VOID_PTR_PROVIDER_PTR ptr ) Notifies uchronia that an object managed by an opaque pointer is not used by the caller anymore. Parameters : ptr pointer obtained via the API, such as a MODEL_SIMULATION_PTR. function DeleteAnsiStringArray \u00b6 DATATYPES_API void DeleteAnsiStringArray ( char ** values , int arrayLength ) Deletes the ANSI string array , which has been create by uchronia. Do not use for char** created outside libswift. Parameters : values pointer to the array to delete (its elements and the array itself). arrayLength Length of the array. function DeleteAnsiString \u00b6 DATATYPES_API void DeleteAnsiString ( const char * value ) Deletes the ANSI string which has been create by uchronia. Do not use for char* created outside libswift. Parameters : value a C-style string, which has been create by uchronia. Do not use for char* created elsewhere. function DeleteDoubleArray \u00b6 DATATYPES_API void DeleteDoubleArray ( double * value ) Dispose of an array of double created via this C API. Parameters : value If non-null, the value. function SetTimeSeriesMissingValueValue \u00b6 DATATYPES_API void SetTimeSeriesMissingValueValue ( double missingValueValue ) Sets a value whoch should be considered as a missing value when data is passed to this C API. Parameters : missingValueValue The missing value. function LoadEnsembleDataset \u00b6 DATATYPES_APIENSEMBLE_DATA_SET_PTR LoadEnsembleDataset ( const char * libraryIdentifier , const char * dataPath ) Creates a time series library, defined (for now) by a YAML descriptor. Parameters : libraryIdentifier an ID for the library (currently path to a YAML file) dataPath optional root data path for on-disk data, if the YAML file uses relative paths. Return : The ensemble dataset. function CreateEnsembleDataset \u00b6 DATATYPES_APIENSEMBLE_DATA_SET_PTR CreateEnsembleDataset ( const char * type ) Creates a time series library. Parameters : type The type of library to create. Currently supports cases for unit tests and time series libraries that can be \"recorded to\" by modelling engines. Return : The new ensemble dataset. function GetEnsembleDatasetDataIdentifiers \u00b6 DATATYPES_API char ** GetEnsembleDatasetDataIdentifiers ( ENSEMBLE_DATA_SET_PTR dataLibrary , int * size ) Gets the highest level datasets' IDs known to this library. Parameters : dataLibrary The data library. size Size of the list of IDs Return : Null if it fails, else the ensemble dataset data identifiers. function GetEnsembleDatasetDataSubIdentifiers \u00b6 DATATYPES_API char ** GetEnsembleDatasetDataSubIdentifiers ( ENSEMBLE_DATA_SET_PTR dataLibrary , const char * dataCollectionId , int * size ) Gets sub identifiers, if any, in a hierarchical ID scheme (e.g. if a collection of streamflows is such that you can ID each series as \"streamflow.gauge_id\") Parameters : dataLibrary The data library. dataCollectionId Main identifier within which to query for sub-identifgiers size Size of the list of sub-IDs Return : Null if it fails, else the dataset data sub identifiers. (e.g. the streamflow gauge idenfiers) function GetEnsembleDatasetDataSummaries \u00b6 DATATYPES_API char ** GetEnsembleDatasetDataSummaries ( ENSEMBLE_DATA_SET_PTR dataLibrary , int * size ) function GetDataDimensionsDescription \u00b6 DATATYPES_API time_series_dimensions_description * GetDataDimensionsDescription ( ENSEMBLE_DATA_SET_PTR dataLibrary , const char * dataId ) Gets data dimensions description. This function is useful for wrappers to discover the dimensionality of a data set before trying to load it in memory. Parameters : dataLibrary The data library. dataId Identifier for the data. Return : A struct describing the dimensionality of the data set in the library. function EnsembleSizeEnsembleTimeSeries \u00b6 DATATYPES_API int EnsembleSizeEnsembleTimeSeries ( ENSEMBLE_PTR_TIME_SERIES_PTR ensSeries ) function DisposeDataDimensionsDescriptions \u00b6 DATATYPES_API void DisposeDataDimensionsDescriptions ( time_series_dimensions_description * data ) function CreateEnsembleForecastTimeSeries \u00b6 DATATYPES_APIENSEMBLE_FORECAST_TIME_SERIES_PTR CreateEnsembleForecastTimeSeries ( date_time_to_second start , int length , const char * timeStepName ) function GetDatasetSingleTimeSeries \u00b6 DATATYPES_APITIME_SERIES_PTR GetDatasetSingleTimeSeries ( ENSEMBLE_DATA_SET_PTR dataLibrary , const char * dataId ) function GetDatasetEnsembleTimeSeries \u00b6 DATATYPES_APIENSEMBLE_PTR_TIME_SERIES_PTR GetDatasetEnsembleTimeSeries ( ENSEMBLE_DATA_SET_PTR dataLibrary , const char * dataEnsembleId ) function GetDatasetEnsembleForecastTimeSeries \u00b6 DATATYPES_APIENSEMBLE_FORECAST_TIME_SERIES_PTR GetDatasetEnsembleForecastTimeSeries ( ENSEMBLE_DATA_SET_PTR dataLibrary , const char * dataId ) function SaveSingleTimeSeriesToNetcdf \u00b6 DATATYPES_API void SaveSingleTimeSeriesToNetcdf ( TIME_SERIES_PTR timeSeries , const char * filename , bool overwrite ) function SaveEnsembleTimeSeriesToNetcdf \u00b6 DATATYPES_API void SaveEnsembleTimeSeriesToNetcdf ( ENSEMBLE_PTR_TIME_SERIES_PTR collection , const char * filename , bool overwrite ) function SaveEnsembleForecastTimeSeriesToNetcdf \u00b6 DATATYPES_API void SaveEnsembleForecastTimeSeriesToNetcdf ( ENSEMBLE_FORECAST_TIME_SERIES_PTR tsEnsTs , const char * filename , bool overwrite ) function IsMissingValueItemEnsembleForecastTimeSeries \u00b6 DATATYPES_API bool IsMissingValueItemEnsembleForecastTimeSeries ( ENSEMBLE_FORECAST_TIME_SERIES_PTR series , int i ) function GetItemEnsembleForecastTimeSeries \u00b6 DATATYPES_APIENSEMBLE_PTR_TIME_SERIES_PTR GetItemEnsembleForecastTimeSeries ( ENSEMBLE_FORECAST_TIME_SERIES_PTR efts , int i ) function TimeSeriesFromEnsembleOfTimeSeries \u00b6 DATATYPES_APITIME_SERIES_PTR TimeSeriesFromEnsembleOfTimeSeries ( ENSEMBLE_PTR_TIME_SERIES_PTR collectionTs , int index ) function TimeSeriesFromTimeSeriesOfEnsembleOfTimeSeries \u00b6 DATATYPES_APITIME_SERIES_PTR TimeSeriesFromTimeSeriesOfEnsembleOfTimeSeries ( ENSEMBLE_FORECAST_TIME_SERIES_PTR efts , int indexInIssueTime , int indexInForecastTime ) function GetValueFromUnivariateTimeSeries \u00b6 DATATYPES_API double GetValueFromUnivariateTimeSeries ( TIME_SERIES_PTR ts , int index ) function TransformEachItem \u00b6 DATATYPES_API void TransformEachItem ( ENSEMBLE_FORECAST_TIME_SERIES_PTR tsEnsTs , const char * method , const char * methodArgument ) function SetValueToUnivariateTimeSeries \u00b6 DATATYPES_API void SetValueToUnivariateTimeSeries ( TIME_SERIES_PTR ts , int index , double value ) function GetItemEnsembleForecastTimeSeriesAsStructure \u00b6 DATATYPES_API multi_regular_time_series_data * GetItemEnsembleForecastTimeSeriesAsStructure ( ENSEMBLE_FORECAST_TIME_SERIES_PTR series , int i ) function GetItemEnsembleTimeSeriesAsStructure \u00b6 DATATYPES_API multi_regular_time_series_data * GetItemEnsembleTimeSeriesAsStructure ( ENSEMBLE_PTR_TIME_SERIES_PTR series , int i ) function SetItemEnsembleForecastTimeSeriesAsStructure \u00b6 DATATYPES_API void SetItemEnsembleForecastTimeSeriesAsStructure ( ENSEMBLE_FORECAST_TIME_SERIES_PTR series , int i , const multi_regular_time_series_data * values ) function SetItemEnsembleTimeSeriesAsStructure \u00b6 DATATYPES_API void SetItemEnsembleTimeSeriesAsStructure ( ENSEMBLE_PTR_TIME_SERIES_PTR collection , int i , const multi_regular_time_series_data * values ) function CreatePerfectForecastTimeSeries \u00b6 DATATYPES_APIENSEMBLE_FORECAST_TIME_SERIES_PTR CreatePerfectForecastTimeSeries ( TIME_SERIES_PTR observations , date_time_to_second start , int length , const char * timeStepName , int offsetForecasts , int leadTime ) function ToStructEnsembleTimeSeriesData \u00b6 DATATYPES_API multi_regular_time_series_data * ToStructEnsembleTimeSeriesData ( ENSEMBLE_PTR_TIME_SERIES_PTR ensSeries ) function ToStructSingleTimeSeriesData \u00b6 DATATYPES_API multi_regular_time_series_data * ToStructSingleTimeSeriesData ( TIME_SERIES_PTR timeSeries ) function CreateEnsembleTimeSeriesDataFromStruct \u00b6 DATATYPES_APIENSEMBLE_PTR_TIME_SERIES_PTR CreateEnsembleTimeSeriesDataFromStruct ( const multi_regular_time_series_data * ensSeries ) function CreateSingleTimeSeriesDataFromStruct \u00b6 DATATYPES_APITIME_SERIES_PTR CreateSingleTimeSeriesDataFromStruct ( const multi_regular_time_series_data * timeSeries ) function DisposeMultiTimeSeriesData \u00b6 DATATYPES_API void DisposeMultiTimeSeriesData ( multi_regular_time_series_data * data ) function GetTimeSeriesGeometry \u00b6 DATATYPES_API void GetTimeSeriesGeometry ( TIME_SERIES_PTR timeSeries , TS_GEOMETRY_PTR geom ) function GetEnsembleForecastTimeSeriesGeometry \u00b6 DATATYPES_API void GetEnsembleForecastTimeSeriesGeometry ( ENSEMBLE_FORECAST_TIME_SERIES_PTR timeSeries , TS_GEOMETRY_PTR geom ) function GetTimeSeriesValues \u00b6 DATATYPES_API void GetTimeSeriesValues ( TIME_SERIES_PTR timeSeries , double * values , int arrayLength ) function GetNumTimeSeries \u00b6 DATATYPES_API int GetNumTimeSeries () function GetProviderTsGeometry \u00b6 DATATYPES_API void GetProviderTsGeometry ( TIME_SERIES_PROVIDER_PTR dataLibrary , const char * variableIdentifier , TS_GEOMETRY_PTR geom ) function GetProviderTimeSeriesValues \u00b6 DATATYPES_API void GetProviderTimeSeriesValues ( TIME_SERIES_PROVIDER_PTR dataLibrary , const char * variableIdentifier , double * values , int arrayLength ) function GetProviderTimeSeriesIdentifiers \u00b6 DATATYPES_API char ** GetProviderTimeSeriesIdentifiers ( TIME_SERIES_PROVIDER_PTR dataLibrary , int * size ) function TimeSeriesFromProviderTs \u00b6 DATATYPES_APITIME_SERIES_PTR TimeSeriesFromProviderTs ( TIME_SERIES_PROVIDER_PTR dataLibrary , const char * variableIdentifier ) Macros Documentation \u00b6 define DATATYPES_USE_CPP_POINTERS \u00b6 #define DATATYPES_USE_CPP_POINTERS define DATATYPES_API \u00b6 #define DATATYPES_API DATATYPES_DLL_LIB Source code \u00b6 #pragma once #include \"setup_exports.h\" #ifndef DATATYPES_USE_OPAQUE_POINTERS #ifndef DATATYPES_USE_CPP_POINTERS #ifndef USING_DATATYPES_CORE #define DATATYPES_USE_CPP_POINTERS #endif #endif #endif #include \"interop_struct.h\" #if defined(DATATYPES_USE_CPP_POINTERS) #include \"datatypes/extern_c_api_as_transparent.h\" #elif defined(DATATYPES_USE_OPAQUE_POINTERS) #include \"datatypes/extern_c_api_as_opaque.h\" #else #error macro DATATYPES_USE_OPAQUE_POINTERS or DATATYPES_USE_CPP_POINTERS must be defined #endif // see http://msdn.microsoft.com/en-us/library/as6wyhwt.aspx, best practice #define DATATYPES_API DATATYPES_DLL_LIB #ifdef __cplusplus extern \"C\" { #endif // Error handling DATATYPES_API char * GetLastStdExceptionMessage (); DATATYPES_API void RegisterExceptionCallback ( const void * callback ); // Generic memory management. DATATYPES_API void DisposeSharedPointer ( VOID_PTR_PROVIDER_PTR ptr ); DATATYPES_API void DeleteAnsiStringArray ( char ** values , int arrayLength ); DATATYPES_API void DeleteAnsiString ( const char * value ); DATATYPES_API void DeleteDoubleArray ( double * value ); // Global settings for the C uchronia API DATATYPES_API void SetTimeSeriesMissingValueValue ( double missingValueValue ); DATATYPES_API ENSEMBLE_DATA_SET_PTR LoadEnsembleDataset ( const char * libraryIdentifier , const char * dataPath ); DATATYPES_API ENSEMBLE_DATA_SET_PTR CreateEnsembleDataset ( const char * type ); DATATYPES_API char ** GetEnsembleDatasetDataIdentifiers ( ENSEMBLE_DATA_SET_PTR dataLibrary , int * size ); DATATYPES_API char ** GetEnsembleDatasetDataSubIdentifiers ( ENSEMBLE_DATA_SET_PTR dataLibrary , const char * dataCollectionId , int * size ); DATATYPES_API char ** GetEnsembleDatasetDataSummaries ( ENSEMBLE_DATA_SET_PTR dataLibrary , int * size ); DATATYPES_API time_series_dimensions_description * GetDataDimensionsDescription ( ENSEMBLE_DATA_SET_PTR dataLibrary , const char * dataId ); DATATYPES_API int EnsembleSizeEnsembleTimeSeries ( ENSEMBLE_PTR_TIME_SERIES_PTR ensSeries ); DATATYPES_API void DisposeDataDimensionsDescriptions ( time_series_dimensions_description * data ); DATATYPES_API ENSEMBLE_FORECAST_TIME_SERIES_PTR CreateEnsembleForecastTimeSeries ( date_time_to_second start , int length , const char * timeStepName ); DATATYPES_API TIME_SERIES_PTR GetDatasetSingleTimeSeries ( ENSEMBLE_DATA_SET_PTR dataLibrary , const char * dataId ); DATATYPES_API ENSEMBLE_PTR_TIME_SERIES_PTR GetDatasetEnsembleTimeSeries ( ENSEMBLE_DATA_SET_PTR dataLibrary , const char * dataEnsembleId ); // DATATYPES_API FORECAST_TIME_SERIES_DOUBLE_PTR GetDatasetForecastTimeSeries(ENSEMBLE_DATA_SET_PTR dataLibrary, char** identifiers, char** dataId, int size); DATATYPES_API ENSEMBLE_FORECAST_TIME_SERIES_PTR GetDatasetEnsembleForecastTimeSeries ( ENSEMBLE_DATA_SET_PTR dataLibrary , const char * dataId ); // These api entry points are TEMPORARY: they must be phased out. DATATYPES_API void SaveSingleTimeSeriesToNetcdf ( TIME_SERIES_PTR timeSeries , const char * filename , bool overwrite ); DATATYPES_API void SaveEnsembleTimeSeriesToNetcdf ( ENSEMBLE_PTR_TIME_SERIES_PTR collection , const char * filename , bool overwrite ); DATATYPES_API void SaveEnsembleForecastTimeSeriesToNetcdf ( ENSEMBLE_FORECAST_TIME_SERIES_PTR tsEnsTs , const char * filename , bool overwrite ); DATATYPES_API bool IsMissingValueItemEnsembleForecastTimeSeries ( ENSEMBLE_FORECAST_TIME_SERIES_PTR series , int i ); //Functions that reduce the dimensionality of data, forms of splicing DATATYPES_API ENSEMBLE_PTR_TIME_SERIES_PTR GetItemEnsembleForecastTimeSeries ( ENSEMBLE_FORECAST_TIME_SERIES_PTR efts , int i ); DATATYPES_API TIME_SERIES_PTR TimeSeriesFromEnsembleOfTimeSeries ( ENSEMBLE_PTR_TIME_SERIES_PTR collectionTs , int index ); DATATYPES_API TIME_SERIES_PTR TimeSeriesFromTimeSeriesOfEnsembleOfTimeSeries ( ENSEMBLE_FORECAST_TIME_SERIES_PTR efts , int indexInIssueTime , int indexInForecastTime ); DATATYPES_API double GetValueFromUnivariateTimeSeries ( TIME_SERIES_PTR ts , int index ); DATATYPES_API void TransformEachItem ( ENSEMBLE_FORECAST_TIME_SERIES_PTR tsEnsTs , const char * method , const char * methodArgument ); //Functions that set items in data (along the 'first' dimension) DATATYPES_API void SetValueToUnivariateTimeSeries ( TIME_SERIES_PTR ts , int index , double value ); // Handling elements in ensemble time series forecasts. DATATYPES_API multi_regular_time_series_data * GetItemEnsembleForecastTimeSeriesAsStructure ( ENSEMBLE_FORECAST_TIME_SERIES_PTR series , int i ); DATATYPES_API multi_regular_time_series_data * GetItemEnsembleTimeSeriesAsStructure ( ENSEMBLE_PTR_TIME_SERIES_PTR series , int i ); //DATATYPES_API void SetItemEnsembleForecastTimeSeries(ENSEMBLE_FORECAST_TIME_SERIES_PTR series, int i, ENSEMBLE_FORECAST_TIME_SERIES_PTR data); DATATYPES_API void SetItemEnsembleForecastTimeSeriesAsStructure ( ENSEMBLE_FORECAST_TIME_SERIES_PTR series , int i , const multi_regular_time_series_data * values ); DATATYPES_API void SetItemEnsembleTimeSeriesAsStructure ( ENSEMBLE_PTR_TIME_SERIES_PTR collection , int i , const multi_regular_time_series_data * values ); // Functions that augment the dimensionality of data DATATYPES_API ENSEMBLE_FORECAST_TIME_SERIES_PTR CreatePerfectForecastTimeSeries ( TIME_SERIES_PTR observations , date_time_to_second start , int length , const char * timeStepName , int offsetForecasts , int leadTime ); // conversions to structures for conversions to other representations in the language using this C API DATATYPES_API multi_regular_time_series_data * ToStructEnsembleTimeSeriesData ( ENSEMBLE_PTR_TIME_SERIES_PTR ensSeries ); DATATYPES_API multi_regular_time_series_data * ToStructSingleTimeSeriesData ( TIME_SERIES_PTR timeSeries ); DATATYPES_API ENSEMBLE_PTR_TIME_SERIES_PTR CreateEnsembleTimeSeriesDataFromStruct ( const multi_regular_time_series_data * ensSeries ); DATATYPES_API TIME_SERIES_PTR CreateSingleTimeSeriesDataFromStruct ( const multi_regular_time_series_data * timeSeries ); DATATYPES_API void DisposeMultiTimeSeriesData ( multi_regular_time_series_data * data ); DATATYPES_API void GetTimeSeriesGeometry ( TIME_SERIES_PTR timeSeries , TS_GEOMETRY_PTR geom ); DATATYPES_API void GetEnsembleForecastTimeSeriesGeometry ( ENSEMBLE_FORECAST_TIME_SERIES_PTR timeSeries , TS_GEOMETRY_PTR geom ); DATATYPES_API void GetTimeSeriesValues ( TIME_SERIES_PTR timeSeries , double * values , int arrayLength ); DATATYPES_API int GetNumTimeSeries (); // Backward compatibility with SWIFTv1, but functions that may be generic to other persistent data sources DATATYPES_API void GetProviderTsGeometry ( TIME_SERIES_PROVIDER_PTR dataLibrary , const char * variableIdentifier , TS_GEOMETRY_PTR geom ); DATATYPES_API void GetProviderTimeSeriesValues ( TIME_SERIES_PROVIDER_PTR dataLibrary , const char * variableIdentifier , double * values , int arrayLength ); DATATYPES_API char ** GetProviderTimeSeriesIdentifiers ( TIME_SERIES_PROVIDER_PTR dataLibrary , int * size ); DATATYPES_API TIME_SERIES_PTR TimeSeriesFromProviderTs ( TIME_SERIES_PROVIDER_PTR dataLibrary , const char * variableIdentifier ); // Obsolete and deprecated functions #ifdef __cplusplus } #endif Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes/extern_c_api.h"},{"location":"cpp/Files/extern__c__api_8h/#datatypesextern_c_apih","text":"More...","title":"datatypes/extern_c_api.h"},{"location":"cpp/Files/extern__c__api_8h/#functions","text":"Name DATATYPES_API char * GetLastStdExceptionMessage () Gets the last message from an std::exception caught by the uchronia API. DATATYPES_API void RegisterExceptionCallback (const void * callback) DATATYPES_API void DisposeSharedPointer (VOID_PTR_PROVIDER_PTR ptr) Notifies uchronia that an object managed by an opaque pointer is not used by the caller anymore. DATATYPES_API void DeleteAnsiStringArray (char ** values, int arrayLength) Deletes the ANSI string array , which has been create by uchronia. Do not use for char** created outside libswift. DATATYPES_API void DeleteAnsiString (const char * value) Deletes the ANSI string which has been create by uchronia. Do not use for char* created outside libswift. DATATYPES_API void DeleteDoubleArray (double * value) Dispose of an array of double created via this C API. DATATYPES_API void SetTimeSeriesMissingValueValue (double missingValueValue) Sets a value whoch should be considered as a missing value when data is passed to this C API. DATATYPES_API ENSEMBLE_DATA_SET_PTR LoadEnsembleDataset (const char * libraryIdentifier, const char * dataPath) Creates a time series library, defined (for now) by a YAML descriptor. DATATYPES_API ENSEMBLE_DATA_SET_PTR CreateEnsembleDataset (const char * type) Creates a time series library. DATATYPES_API char ** GetEnsembleDatasetDataIdentifiers ( ENSEMBLE_DATA_SET_PTR dataLibrary, int * size) Gets the highest level datasets' IDs known to this library. DATATYPES_API char ** GetEnsembleDatasetDataSubIdentifiers ( ENSEMBLE_DATA_SET_PTR dataLibrary, const char * dataCollectionId, int * size) Gets sub identifiers, if any, in a hierarchical ID scheme (e.g. if a collection of streamflows is such that you can ID each series as \"streamflow.gauge_id\") DATATYPES_API char ** GetEnsembleDatasetDataSummaries ( ENSEMBLE_DATA_SET_PTR dataLibrary, int * size) DATATYPES_API time_series_dimensions_description * GetDataDimensionsDescription ( ENSEMBLE_DATA_SET_PTR dataLibrary, const char * dataId) Gets data dimensions description. This function is useful for wrappers to discover the dimensionality of a data set before trying to load it in memory. DATATYPES_API int EnsembleSizeEnsembleTimeSeries ( ENSEMBLE_PTR_TIME_SERIES_PTR ensSeries) DATATYPES_API void DisposeDataDimensionsDescriptions (time_series_dimensions_description * data) DATATYPES_API ENSEMBLE_FORECAST_TIME_SERIES_PTR CreateEnsembleForecastTimeSeries (date_time_to_second start, int length, const char * timeStepName) DATATYPES_API TIME_SERIES_PTR GetDatasetSingleTimeSeries ( ENSEMBLE_DATA_SET_PTR dataLibrary, const char * dataId) DATATYPES_API ENSEMBLE_PTR_TIME_SERIES_PTR GetDatasetEnsembleTimeSeries ( ENSEMBLE_DATA_SET_PTR dataLibrary, const char * dataEnsembleId) DATATYPES_API ENSEMBLE_FORECAST_TIME_SERIES_PTR GetDatasetEnsembleForecastTimeSeries ( ENSEMBLE_DATA_SET_PTR dataLibrary, const char * dataId) DATATYPES_API void SaveSingleTimeSeriesToNetcdf ( TIME_SERIES_PTR timeSeries, const char * filename, bool overwrite) DATATYPES_API void SaveEnsembleTimeSeriesToNetcdf ( ENSEMBLE_PTR_TIME_SERIES_PTR collection, const char * filename, bool overwrite) DATATYPES_API void SaveEnsembleForecastTimeSeriesToNetcdf ( ENSEMBLE_FORECAST_TIME_SERIES_PTR tsEnsTs, const char * filename, bool overwrite) DATATYPES_API bool IsMissingValueItemEnsembleForecastTimeSeries ( ENSEMBLE_FORECAST_TIME_SERIES_PTR series, int i) DATATYPES_API ENSEMBLE_PTR_TIME_SERIES_PTR GetItemEnsembleForecastTimeSeries ( ENSEMBLE_FORECAST_TIME_SERIES_PTR efts, int i) DATATYPES_API TIME_SERIES_PTR TimeSeriesFromEnsembleOfTimeSeries ( ENSEMBLE_PTR_TIME_SERIES_PTR collectionTs, int index) DATATYPES_API TIME_SERIES_PTR TimeSeriesFromTimeSeriesOfEnsembleOfTimeSeries ( ENSEMBLE_FORECAST_TIME_SERIES_PTR efts, int indexInIssueTime, int indexInForecastTime) DATATYPES_API double GetValueFromUnivariateTimeSeries ( TIME_SERIES_PTR ts, int index) DATATYPES_API void TransformEachItem ( ENSEMBLE_FORECAST_TIME_SERIES_PTR tsEnsTs, const char * method, const char * methodArgument) DATATYPES_API void SetValueToUnivariateTimeSeries ( TIME_SERIES_PTR ts, int index, double value) DATATYPES_API multi_regular_time_series_data * GetItemEnsembleForecastTimeSeriesAsStructure ( ENSEMBLE_FORECAST_TIME_SERIES_PTR series, int i) DATATYPES_API multi_regular_time_series_data * GetItemEnsembleTimeSeriesAsStructure ( ENSEMBLE_PTR_TIME_SERIES_PTR series, int i) DATATYPES_API void SetItemEnsembleForecastTimeSeriesAsStructure ( ENSEMBLE_FORECAST_TIME_SERIES_PTR series, int i, const multi_regular_time_series_data * values) DATATYPES_API void SetItemEnsembleTimeSeriesAsStructure ( ENSEMBLE_PTR_TIME_SERIES_PTR collection, int i, const multi_regular_time_series_data * values) DATATYPES_API ENSEMBLE_FORECAST_TIME_SERIES_PTR CreatePerfectForecastTimeSeries ( TIME_SERIES_PTR observations, date_time_to_second start, int length, const char * timeStepName, int offsetForecasts, int leadTime) DATATYPES_API multi_regular_time_series_data * ToStructEnsembleTimeSeriesData ( ENSEMBLE_PTR_TIME_SERIES_PTR ensSeries) DATATYPES_API multi_regular_time_series_data * ToStructSingleTimeSeriesData ( TIME_SERIES_PTR timeSeries) DATATYPES_API ENSEMBLE_PTR_TIME_SERIES_PTR CreateEnsembleTimeSeriesDataFromStruct (const multi_regular_time_series_data * ensSeries) DATATYPES_API TIME_SERIES_PTR CreateSingleTimeSeriesDataFromStruct (const multi_regular_time_series_data * timeSeries) DATATYPES_API void DisposeMultiTimeSeriesData (multi_regular_time_series_data * data) DATATYPES_API void GetTimeSeriesGeometry ( TIME_SERIES_PTR timeSeries, TS_GEOMETRY_PTR geom) DATATYPES_API void GetEnsembleForecastTimeSeriesGeometry ( ENSEMBLE_FORECAST_TIME_SERIES_PTR timeSeries, TS_GEOMETRY_PTR geom) DATATYPES_API void GetTimeSeriesValues ( TIME_SERIES_PTR timeSeries, double * values, int arrayLength) DATATYPES_API int GetNumTimeSeries () DATATYPES_API void GetProviderTsGeometry ( TIME_SERIES_PROVIDER_PTR dataLibrary, const char * variableIdentifier, TS_GEOMETRY_PTR geom) DATATYPES_API void GetProviderTimeSeriesValues ( TIME_SERIES_PROVIDER_PTR dataLibrary, const char * variableIdentifier, double * values, int arrayLength) DATATYPES_API char ** GetProviderTimeSeriesIdentifiers ( TIME_SERIES_PROVIDER_PTR dataLibrary, int * size) DATATYPES_API TIME_SERIES_PTR TimeSeriesFromProviderTs ( TIME_SERIES_PROVIDER_PTR dataLibrary, const char * variableIdentifier)","title":"Functions"},{"location":"cpp/Files/extern__c__api_8h/#defines","text":"Name DATATYPES_USE_CPP_POINTERS DATATYPES_API","title":"Defines"},{"location":"cpp/Files/extern__c__api_8h/#detailed-description","text":"API for libswift. This file exposes a common API for interacting with libswift from other tools.","title":"Detailed Description"},{"location":"cpp/Files/extern__c__api_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"cpp/Files/extern__c__api_8h/#function-getlaststdexceptionmessage","text":"DATATYPES_API char * GetLastStdExceptionMessage () Gets the last message from an std::exception caught by the uchronia API. Return : the last standard exception message.","title":"function GetLastStdExceptionMessage"},{"location":"cpp/Files/extern__c__api_8h/#function-registerexceptioncallback","text":"DATATYPES_API void RegisterExceptionCallback ( const void * callback )","title":"function RegisterExceptionCallback"},{"location":"cpp/Files/extern__c__api_8h/#function-disposesharedpointer","text":"DATATYPES_API void DisposeSharedPointer ( VOID_PTR_PROVIDER_PTR ptr ) Notifies uchronia that an object managed by an opaque pointer is not used by the caller anymore. Parameters : ptr pointer obtained via the API, such as a MODEL_SIMULATION_PTR.","title":"function DisposeSharedPointer"},{"location":"cpp/Files/extern__c__api_8h/#function-deleteansistringarray","text":"DATATYPES_API void DeleteAnsiStringArray ( char ** values , int arrayLength ) Deletes the ANSI string array , which has been create by uchronia. Do not use for char** created outside libswift. Parameters : values pointer to the array to delete (its elements and the array itself). arrayLength Length of the array.","title":"function DeleteAnsiStringArray"},{"location":"cpp/Files/extern__c__api_8h/#function-deleteansistring","text":"DATATYPES_API void DeleteAnsiString ( const char * value ) Deletes the ANSI string which has been create by uchronia. Do not use for char* created outside libswift. Parameters : value a C-style string, which has been create by uchronia. Do not use for char* created elsewhere.","title":"function DeleteAnsiString"},{"location":"cpp/Files/extern__c__api_8h/#function-deletedoublearray","text":"DATATYPES_API void DeleteDoubleArray ( double * value ) Dispose of an array of double created via this C API. Parameters : value If non-null, the value.","title":"function DeleteDoubleArray"},{"location":"cpp/Files/extern__c__api_8h/#function-settimeseriesmissingvaluevalue","text":"DATATYPES_API void SetTimeSeriesMissingValueValue ( double missingValueValue ) Sets a value whoch should be considered as a missing value when data is passed to this C API. Parameters : missingValueValue The missing value.","title":"function SetTimeSeriesMissingValueValue"},{"location":"cpp/Files/extern__c__api_8h/#function-loadensembledataset","text":"DATATYPES_APIENSEMBLE_DATA_SET_PTR LoadEnsembleDataset ( const char * libraryIdentifier , const char * dataPath ) Creates a time series library, defined (for now) by a YAML descriptor. Parameters : libraryIdentifier an ID for the library (currently path to a YAML file) dataPath optional root data path for on-disk data, if the YAML file uses relative paths. Return : The ensemble dataset.","title":"function LoadEnsembleDataset"},{"location":"cpp/Files/extern__c__api_8h/#function-createensembledataset","text":"DATATYPES_APIENSEMBLE_DATA_SET_PTR CreateEnsembleDataset ( const char * type ) Creates a time series library. Parameters : type The type of library to create. Currently supports cases for unit tests and time series libraries that can be \"recorded to\" by modelling engines. Return : The new ensemble dataset.","title":"function CreateEnsembleDataset"},{"location":"cpp/Files/extern__c__api_8h/#function-getensembledatasetdataidentifiers","text":"DATATYPES_API char ** GetEnsembleDatasetDataIdentifiers ( ENSEMBLE_DATA_SET_PTR dataLibrary , int * size ) Gets the highest level datasets' IDs known to this library. Parameters : dataLibrary The data library. size Size of the list of IDs Return : Null if it fails, else the ensemble dataset data identifiers.","title":"function GetEnsembleDatasetDataIdentifiers"},{"location":"cpp/Files/extern__c__api_8h/#function-getensembledatasetdatasubidentifiers","text":"DATATYPES_API char ** GetEnsembleDatasetDataSubIdentifiers ( ENSEMBLE_DATA_SET_PTR dataLibrary , const char * dataCollectionId , int * size ) Gets sub identifiers, if any, in a hierarchical ID scheme (e.g. if a collection of streamflows is such that you can ID each series as \"streamflow.gauge_id\") Parameters : dataLibrary The data library. dataCollectionId Main identifier within which to query for sub-identifgiers size Size of the list of sub-IDs Return : Null if it fails, else the dataset data sub identifiers. (e.g. the streamflow gauge idenfiers)","title":"function GetEnsembleDatasetDataSubIdentifiers"},{"location":"cpp/Files/extern__c__api_8h/#function-getensembledatasetdatasummaries","text":"DATATYPES_API char ** GetEnsembleDatasetDataSummaries ( ENSEMBLE_DATA_SET_PTR dataLibrary , int * size )","title":"function GetEnsembleDatasetDataSummaries"},{"location":"cpp/Files/extern__c__api_8h/#function-getdatadimensionsdescription","text":"DATATYPES_API time_series_dimensions_description * GetDataDimensionsDescription ( ENSEMBLE_DATA_SET_PTR dataLibrary , const char * dataId ) Gets data dimensions description. This function is useful for wrappers to discover the dimensionality of a data set before trying to load it in memory. Parameters : dataLibrary The data library. dataId Identifier for the data. Return : A struct describing the dimensionality of the data set in the library.","title":"function GetDataDimensionsDescription"},{"location":"cpp/Files/extern__c__api_8h/#function-ensemblesizeensembletimeseries","text":"DATATYPES_API int EnsembleSizeEnsembleTimeSeries ( ENSEMBLE_PTR_TIME_SERIES_PTR ensSeries )","title":"function EnsembleSizeEnsembleTimeSeries"},{"location":"cpp/Files/extern__c__api_8h/#function-disposedatadimensionsdescriptions","text":"DATATYPES_API void DisposeDataDimensionsDescriptions ( time_series_dimensions_description * data )","title":"function DisposeDataDimensionsDescriptions"},{"location":"cpp/Files/extern__c__api_8h/#function-createensembleforecasttimeseries","text":"DATATYPES_APIENSEMBLE_FORECAST_TIME_SERIES_PTR CreateEnsembleForecastTimeSeries ( date_time_to_second start , int length , const char * timeStepName )","title":"function CreateEnsembleForecastTimeSeries"},{"location":"cpp/Files/extern__c__api_8h/#function-getdatasetsingletimeseries","text":"DATATYPES_APITIME_SERIES_PTR GetDatasetSingleTimeSeries ( ENSEMBLE_DATA_SET_PTR dataLibrary , const char * dataId )","title":"function GetDatasetSingleTimeSeries"},{"location":"cpp/Files/extern__c__api_8h/#function-getdatasetensembletimeseries","text":"DATATYPES_APIENSEMBLE_PTR_TIME_SERIES_PTR GetDatasetEnsembleTimeSeries ( ENSEMBLE_DATA_SET_PTR dataLibrary , const char * dataEnsembleId )","title":"function GetDatasetEnsembleTimeSeries"},{"location":"cpp/Files/extern__c__api_8h/#function-getdatasetensembleforecasttimeseries","text":"DATATYPES_APIENSEMBLE_FORECAST_TIME_SERIES_PTR GetDatasetEnsembleForecastTimeSeries ( ENSEMBLE_DATA_SET_PTR dataLibrary , const char * dataId )","title":"function GetDatasetEnsembleForecastTimeSeries"},{"location":"cpp/Files/extern__c__api_8h/#function-savesingletimeseriestonetcdf","text":"DATATYPES_API void SaveSingleTimeSeriesToNetcdf ( TIME_SERIES_PTR timeSeries , const char * filename , bool overwrite )","title":"function SaveSingleTimeSeriesToNetcdf"},{"location":"cpp/Files/extern__c__api_8h/#function-saveensembletimeseriestonetcdf","text":"DATATYPES_API void SaveEnsembleTimeSeriesToNetcdf ( ENSEMBLE_PTR_TIME_SERIES_PTR collection , const char * filename , bool overwrite )","title":"function SaveEnsembleTimeSeriesToNetcdf"},{"location":"cpp/Files/extern__c__api_8h/#function-saveensembleforecasttimeseriestonetcdf","text":"DATATYPES_API void SaveEnsembleForecastTimeSeriesToNetcdf ( ENSEMBLE_FORECAST_TIME_SERIES_PTR tsEnsTs , const char * filename , bool overwrite )","title":"function SaveEnsembleForecastTimeSeriesToNetcdf"},{"location":"cpp/Files/extern__c__api_8h/#function-ismissingvalueitemensembleforecasttimeseries","text":"DATATYPES_API bool IsMissingValueItemEnsembleForecastTimeSeries ( ENSEMBLE_FORECAST_TIME_SERIES_PTR series , int i )","title":"function IsMissingValueItemEnsembleForecastTimeSeries"},{"location":"cpp/Files/extern__c__api_8h/#function-getitemensembleforecasttimeseries","text":"DATATYPES_APIENSEMBLE_PTR_TIME_SERIES_PTR GetItemEnsembleForecastTimeSeries ( ENSEMBLE_FORECAST_TIME_SERIES_PTR efts , int i )","title":"function GetItemEnsembleForecastTimeSeries"},{"location":"cpp/Files/extern__c__api_8h/#function-timeseriesfromensembleoftimeseries","text":"DATATYPES_APITIME_SERIES_PTR TimeSeriesFromEnsembleOfTimeSeries ( ENSEMBLE_PTR_TIME_SERIES_PTR collectionTs , int index )","title":"function TimeSeriesFromEnsembleOfTimeSeries"},{"location":"cpp/Files/extern__c__api_8h/#function-timeseriesfromtimeseriesofensembleoftimeseries","text":"DATATYPES_APITIME_SERIES_PTR TimeSeriesFromTimeSeriesOfEnsembleOfTimeSeries ( ENSEMBLE_FORECAST_TIME_SERIES_PTR efts , int indexInIssueTime , int indexInForecastTime )","title":"function TimeSeriesFromTimeSeriesOfEnsembleOfTimeSeries"},{"location":"cpp/Files/extern__c__api_8h/#function-getvaluefromunivariatetimeseries","text":"DATATYPES_API double GetValueFromUnivariateTimeSeries ( TIME_SERIES_PTR ts , int index )","title":"function GetValueFromUnivariateTimeSeries"},{"location":"cpp/Files/extern__c__api_8h/#function-transformeachitem","text":"DATATYPES_API void TransformEachItem ( ENSEMBLE_FORECAST_TIME_SERIES_PTR tsEnsTs , const char * method , const char * methodArgument )","title":"function TransformEachItem"},{"location":"cpp/Files/extern__c__api_8h/#function-setvaluetounivariatetimeseries","text":"DATATYPES_API void SetValueToUnivariateTimeSeries ( TIME_SERIES_PTR ts , int index , double value )","title":"function SetValueToUnivariateTimeSeries"},{"location":"cpp/Files/extern__c__api_8h/#function-getitemensembleforecasttimeseriesasstructure","text":"DATATYPES_API multi_regular_time_series_data * GetItemEnsembleForecastTimeSeriesAsStructure ( ENSEMBLE_FORECAST_TIME_SERIES_PTR series , int i )","title":"function GetItemEnsembleForecastTimeSeriesAsStructure"},{"location":"cpp/Files/extern__c__api_8h/#function-getitemensembletimeseriesasstructure","text":"DATATYPES_API multi_regular_time_series_data * GetItemEnsembleTimeSeriesAsStructure ( ENSEMBLE_PTR_TIME_SERIES_PTR series , int i )","title":"function GetItemEnsembleTimeSeriesAsStructure"},{"location":"cpp/Files/extern__c__api_8h/#function-setitemensembleforecasttimeseriesasstructure","text":"DATATYPES_API void SetItemEnsembleForecastTimeSeriesAsStructure ( ENSEMBLE_FORECAST_TIME_SERIES_PTR series , int i , const multi_regular_time_series_data * values )","title":"function SetItemEnsembleForecastTimeSeriesAsStructure"},{"location":"cpp/Files/extern__c__api_8h/#function-setitemensembletimeseriesasstructure","text":"DATATYPES_API void SetItemEnsembleTimeSeriesAsStructure ( ENSEMBLE_PTR_TIME_SERIES_PTR collection , int i , const multi_regular_time_series_data * values )","title":"function SetItemEnsembleTimeSeriesAsStructure"},{"location":"cpp/Files/extern__c__api_8h/#function-createperfectforecasttimeseries","text":"DATATYPES_APIENSEMBLE_FORECAST_TIME_SERIES_PTR CreatePerfectForecastTimeSeries ( TIME_SERIES_PTR observations , date_time_to_second start , int length , const char * timeStepName , int offsetForecasts , int leadTime )","title":"function CreatePerfectForecastTimeSeries"},{"location":"cpp/Files/extern__c__api_8h/#function-tostructensembletimeseriesdata","text":"DATATYPES_API multi_regular_time_series_data * ToStructEnsembleTimeSeriesData ( ENSEMBLE_PTR_TIME_SERIES_PTR ensSeries )","title":"function ToStructEnsembleTimeSeriesData"},{"location":"cpp/Files/extern__c__api_8h/#function-tostructsingletimeseriesdata","text":"DATATYPES_API multi_regular_time_series_data * ToStructSingleTimeSeriesData ( TIME_SERIES_PTR timeSeries )","title":"function ToStructSingleTimeSeriesData"},{"location":"cpp/Files/extern__c__api_8h/#function-createensembletimeseriesdatafromstruct","text":"DATATYPES_APIENSEMBLE_PTR_TIME_SERIES_PTR CreateEnsembleTimeSeriesDataFromStruct ( const multi_regular_time_series_data * ensSeries )","title":"function CreateEnsembleTimeSeriesDataFromStruct"},{"location":"cpp/Files/extern__c__api_8h/#function-createsingletimeseriesdatafromstruct","text":"DATATYPES_APITIME_SERIES_PTR CreateSingleTimeSeriesDataFromStruct ( const multi_regular_time_series_data * timeSeries )","title":"function CreateSingleTimeSeriesDataFromStruct"},{"location":"cpp/Files/extern__c__api_8h/#function-disposemultitimeseriesdata","text":"DATATYPES_API void DisposeMultiTimeSeriesData ( multi_regular_time_series_data * data )","title":"function DisposeMultiTimeSeriesData"},{"location":"cpp/Files/extern__c__api_8h/#function-gettimeseriesgeometry","text":"DATATYPES_API void GetTimeSeriesGeometry ( TIME_SERIES_PTR timeSeries , TS_GEOMETRY_PTR geom )","title":"function GetTimeSeriesGeometry"},{"location":"cpp/Files/extern__c__api_8h/#function-getensembleforecasttimeseriesgeometry","text":"DATATYPES_API void GetEnsembleForecastTimeSeriesGeometry ( ENSEMBLE_FORECAST_TIME_SERIES_PTR timeSeries , TS_GEOMETRY_PTR geom )","title":"function GetEnsembleForecastTimeSeriesGeometry"},{"location":"cpp/Files/extern__c__api_8h/#function-gettimeseriesvalues","text":"DATATYPES_API void GetTimeSeriesValues ( TIME_SERIES_PTR timeSeries , double * values , int arrayLength )","title":"function GetTimeSeriesValues"},{"location":"cpp/Files/extern__c__api_8h/#function-getnumtimeseries","text":"DATATYPES_API int GetNumTimeSeries ()","title":"function GetNumTimeSeries"},{"location":"cpp/Files/extern__c__api_8h/#function-getprovidertsgeometry","text":"DATATYPES_API void GetProviderTsGeometry ( TIME_SERIES_PROVIDER_PTR dataLibrary , const char * variableIdentifier , TS_GEOMETRY_PTR geom )","title":"function GetProviderTsGeometry"},{"location":"cpp/Files/extern__c__api_8h/#function-getprovidertimeseriesvalues","text":"DATATYPES_API void GetProviderTimeSeriesValues ( TIME_SERIES_PROVIDER_PTR dataLibrary , const char * variableIdentifier , double * values , int arrayLength )","title":"function GetProviderTimeSeriesValues"},{"location":"cpp/Files/extern__c__api_8h/#function-getprovidertimeseriesidentifiers","text":"DATATYPES_API char ** GetProviderTimeSeriesIdentifiers ( TIME_SERIES_PROVIDER_PTR dataLibrary , int * size )","title":"function GetProviderTimeSeriesIdentifiers"},{"location":"cpp/Files/extern__c__api_8h/#function-timeseriesfromproviderts","text":"DATATYPES_APITIME_SERIES_PTR TimeSeriesFromProviderTs ( TIME_SERIES_PROVIDER_PTR dataLibrary , const char * variableIdentifier )","title":"function TimeSeriesFromProviderTs"},{"location":"cpp/Files/extern__c__api_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"cpp/Files/extern__c__api_8h/#define-datatypes_use_cpp_pointers","text":"#define DATATYPES_USE_CPP_POINTERS","title":"define DATATYPES_USE_CPP_POINTERS"},{"location":"cpp/Files/extern__c__api_8h/#define-datatypes_api","text":"#define DATATYPES_API DATATYPES_DLL_LIB","title":"define DATATYPES_API"},{"location":"cpp/Files/extern__c__api_8h/#source-code","text":"#pragma once #include \"setup_exports.h\" #ifndef DATATYPES_USE_OPAQUE_POINTERS #ifndef DATATYPES_USE_CPP_POINTERS #ifndef USING_DATATYPES_CORE #define DATATYPES_USE_CPP_POINTERS #endif #endif #endif #include \"interop_struct.h\" #if defined(DATATYPES_USE_CPP_POINTERS) #include \"datatypes/extern_c_api_as_transparent.h\" #elif defined(DATATYPES_USE_OPAQUE_POINTERS) #include \"datatypes/extern_c_api_as_opaque.h\" #else #error macro DATATYPES_USE_OPAQUE_POINTERS or DATATYPES_USE_CPP_POINTERS must be defined #endif // see http://msdn.microsoft.com/en-us/library/as6wyhwt.aspx, best practice #define DATATYPES_API DATATYPES_DLL_LIB #ifdef __cplusplus extern \"C\" { #endif // Error handling DATATYPES_API char * GetLastStdExceptionMessage (); DATATYPES_API void RegisterExceptionCallback ( const void * callback ); // Generic memory management. DATATYPES_API void DisposeSharedPointer ( VOID_PTR_PROVIDER_PTR ptr ); DATATYPES_API void DeleteAnsiStringArray ( char ** values , int arrayLength ); DATATYPES_API void DeleteAnsiString ( const char * value ); DATATYPES_API void DeleteDoubleArray ( double * value ); // Global settings for the C uchronia API DATATYPES_API void SetTimeSeriesMissingValueValue ( double missingValueValue ); DATATYPES_API ENSEMBLE_DATA_SET_PTR LoadEnsembleDataset ( const char * libraryIdentifier , const char * dataPath ); DATATYPES_API ENSEMBLE_DATA_SET_PTR CreateEnsembleDataset ( const char * type ); DATATYPES_API char ** GetEnsembleDatasetDataIdentifiers ( ENSEMBLE_DATA_SET_PTR dataLibrary , int * size ); DATATYPES_API char ** GetEnsembleDatasetDataSubIdentifiers ( ENSEMBLE_DATA_SET_PTR dataLibrary , const char * dataCollectionId , int * size ); DATATYPES_API char ** GetEnsembleDatasetDataSummaries ( ENSEMBLE_DATA_SET_PTR dataLibrary , int * size ); DATATYPES_API time_series_dimensions_description * GetDataDimensionsDescription ( ENSEMBLE_DATA_SET_PTR dataLibrary , const char * dataId ); DATATYPES_API int EnsembleSizeEnsembleTimeSeries ( ENSEMBLE_PTR_TIME_SERIES_PTR ensSeries ); DATATYPES_API void DisposeDataDimensionsDescriptions ( time_series_dimensions_description * data ); DATATYPES_API ENSEMBLE_FORECAST_TIME_SERIES_PTR CreateEnsembleForecastTimeSeries ( date_time_to_second start , int length , const char * timeStepName ); DATATYPES_API TIME_SERIES_PTR GetDatasetSingleTimeSeries ( ENSEMBLE_DATA_SET_PTR dataLibrary , const char * dataId ); DATATYPES_API ENSEMBLE_PTR_TIME_SERIES_PTR GetDatasetEnsembleTimeSeries ( ENSEMBLE_DATA_SET_PTR dataLibrary , const char * dataEnsembleId ); // DATATYPES_API FORECAST_TIME_SERIES_DOUBLE_PTR GetDatasetForecastTimeSeries(ENSEMBLE_DATA_SET_PTR dataLibrary, char** identifiers, char** dataId, int size); DATATYPES_API ENSEMBLE_FORECAST_TIME_SERIES_PTR GetDatasetEnsembleForecastTimeSeries ( ENSEMBLE_DATA_SET_PTR dataLibrary , const char * dataId ); // These api entry points are TEMPORARY: they must be phased out. DATATYPES_API void SaveSingleTimeSeriesToNetcdf ( TIME_SERIES_PTR timeSeries , const char * filename , bool overwrite ); DATATYPES_API void SaveEnsembleTimeSeriesToNetcdf ( ENSEMBLE_PTR_TIME_SERIES_PTR collection , const char * filename , bool overwrite ); DATATYPES_API void SaveEnsembleForecastTimeSeriesToNetcdf ( ENSEMBLE_FORECAST_TIME_SERIES_PTR tsEnsTs , const char * filename , bool overwrite ); DATATYPES_API bool IsMissingValueItemEnsembleForecastTimeSeries ( ENSEMBLE_FORECAST_TIME_SERIES_PTR series , int i ); //Functions that reduce the dimensionality of data, forms of splicing DATATYPES_API ENSEMBLE_PTR_TIME_SERIES_PTR GetItemEnsembleForecastTimeSeries ( ENSEMBLE_FORECAST_TIME_SERIES_PTR efts , int i ); DATATYPES_API TIME_SERIES_PTR TimeSeriesFromEnsembleOfTimeSeries ( ENSEMBLE_PTR_TIME_SERIES_PTR collectionTs , int index ); DATATYPES_API TIME_SERIES_PTR TimeSeriesFromTimeSeriesOfEnsembleOfTimeSeries ( ENSEMBLE_FORECAST_TIME_SERIES_PTR efts , int indexInIssueTime , int indexInForecastTime ); DATATYPES_API double GetValueFromUnivariateTimeSeries ( TIME_SERIES_PTR ts , int index ); DATATYPES_API void TransformEachItem ( ENSEMBLE_FORECAST_TIME_SERIES_PTR tsEnsTs , const char * method , const char * methodArgument ); //Functions that set items in data (along the 'first' dimension) DATATYPES_API void SetValueToUnivariateTimeSeries ( TIME_SERIES_PTR ts , int index , double value ); // Handling elements in ensemble time series forecasts. DATATYPES_API multi_regular_time_series_data * GetItemEnsembleForecastTimeSeriesAsStructure ( ENSEMBLE_FORECAST_TIME_SERIES_PTR series , int i ); DATATYPES_API multi_regular_time_series_data * GetItemEnsembleTimeSeriesAsStructure ( ENSEMBLE_PTR_TIME_SERIES_PTR series , int i ); //DATATYPES_API void SetItemEnsembleForecastTimeSeries(ENSEMBLE_FORECAST_TIME_SERIES_PTR series, int i, ENSEMBLE_FORECAST_TIME_SERIES_PTR data); DATATYPES_API void SetItemEnsembleForecastTimeSeriesAsStructure ( ENSEMBLE_FORECAST_TIME_SERIES_PTR series , int i , const multi_regular_time_series_data * values ); DATATYPES_API void SetItemEnsembleTimeSeriesAsStructure ( ENSEMBLE_PTR_TIME_SERIES_PTR collection , int i , const multi_regular_time_series_data * values ); // Functions that augment the dimensionality of data DATATYPES_API ENSEMBLE_FORECAST_TIME_SERIES_PTR CreatePerfectForecastTimeSeries ( TIME_SERIES_PTR observations , date_time_to_second start , int length , const char * timeStepName , int offsetForecasts , int leadTime ); // conversions to structures for conversions to other representations in the language using this C API DATATYPES_API multi_regular_time_series_data * ToStructEnsembleTimeSeriesData ( ENSEMBLE_PTR_TIME_SERIES_PTR ensSeries ); DATATYPES_API multi_regular_time_series_data * ToStructSingleTimeSeriesData ( TIME_SERIES_PTR timeSeries ); DATATYPES_API ENSEMBLE_PTR_TIME_SERIES_PTR CreateEnsembleTimeSeriesDataFromStruct ( const multi_regular_time_series_data * ensSeries ); DATATYPES_API TIME_SERIES_PTR CreateSingleTimeSeriesDataFromStruct ( const multi_regular_time_series_data * timeSeries ); DATATYPES_API void DisposeMultiTimeSeriesData ( multi_regular_time_series_data * data ); DATATYPES_API void GetTimeSeriesGeometry ( TIME_SERIES_PTR timeSeries , TS_GEOMETRY_PTR geom ); DATATYPES_API void GetEnsembleForecastTimeSeriesGeometry ( ENSEMBLE_FORECAST_TIME_SERIES_PTR timeSeries , TS_GEOMETRY_PTR geom ); DATATYPES_API void GetTimeSeriesValues ( TIME_SERIES_PTR timeSeries , double * values , int arrayLength ); DATATYPES_API int GetNumTimeSeries (); // Backward compatibility with SWIFTv1, but functions that may be generic to other persistent data sources DATATYPES_API void GetProviderTsGeometry ( TIME_SERIES_PROVIDER_PTR dataLibrary , const char * variableIdentifier , TS_GEOMETRY_PTR geom ); DATATYPES_API void GetProviderTimeSeriesValues ( TIME_SERIES_PROVIDER_PTR dataLibrary , const char * variableIdentifier , double * values , int arrayLength ); DATATYPES_API char ** GetProviderTimeSeriesIdentifiers ( TIME_SERIES_PROVIDER_PTR dataLibrary , int * size ); DATATYPES_API TIME_SERIES_PTR TimeSeriesFromProviderTs ( TIME_SERIES_PROVIDER_PTR dataLibrary , const char * variableIdentifier ); // Obsolete and deprecated functions #ifdef __cplusplus } #endif Updated on 2022-08-20 at 19:28:22 +1000","title":"Source code"},{"location":"cpp/Files/extern__c__api__as__opaque_8h/","text":"datatypes/extern_c_api_as_opaque.h \u00b6 Defines \u00b6 Name DATATYPES_TIME_SERIES_DOUBLE_PTR DATATYPES_ENSEMBLE_TIME_SERIES_DOUBLE_PTR ENSEMBLE_DATA_SET_PTR ENSEMBLE_FORECAST_TIME_SERIES_PTR TIME_SERIES_PTR ENSEMBLE_TIME_SERIES_PTR ENSEMBLE_PTR_TIME_SERIES_PTR TIME_SERIES_PROVIDER_PTR TS_GEOMETRY_PTR DATE_TIME_INFO_PTR MULTI_REGULAR_SERIES_STRUCT_PTR Macros Documentation \u00b6 define DATATYPES_TIME_SERIES_DOUBLE_PTR \u00b6 #define DATATYPES_TIME_SERIES_DOUBLE_PTR void* define DATATYPES_ENSEMBLE_TIME_SERIES_DOUBLE_PTR \u00b6 #define DATATYPES_ENSEMBLE_TIME_SERIES_DOUBLE_PTR void* define ENSEMBLE_DATA_SET_PTR \u00b6 #define ENSEMBLE_DATA_SET_PTR void* define ENSEMBLE_FORECAST_TIME_SERIES_PTR \u00b6 #define ENSEMBLE_FORECAST_TIME_SERIES_PTR void* define TIME_SERIES_PTR \u00b6 #define TIME_SERIES_PTR void* define ENSEMBLE_TIME_SERIES_PTR \u00b6 #define ENSEMBLE_TIME_SERIES_PTR void* define ENSEMBLE_PTR_TIME_SERIES_PTR \u00b6 #define ENSEMBLE_PTR_TIME_SERIES_PTR void* define TIME_SERIES_PROVIDER_PTR \u00b6 #define TIME_SERIES_PROVIDER_PTR void* define TS_GEOMETRY_PTR \u00b6 #define TS_GEOMETRY_PTR void* define DATE_TIME_INFO_PTR \u00b6 #define DATE_TIME_INFO_PTR void* define MULTI_REGULAR_SERIES_STRUCT_PTR \u00b6 #define MULTI_REGULAR_SERIES_STRUCT_PTR void* Source code \u00b6 #pragma once #include \"moirai/extern_c_api_as_opaque.h\" #define DATATYPES_TIME_SERIES_DOUBLE_PTR void* #define DATATYPES_ENSEMBLE_TIME_SERIES_DOUBLE_PTR void* #define ENSEMBLE_DATA_SET_PTR void* #define ENSEMBLE_FORECAST_TIME_SERIES_PTR void* #define TIME_SERIES_PTR void* #define ENSEMBLE_TIME_SERIES_PTR void* #define ENSEMBLE_PTR_TIME_SERIES_PTR void* #define TIME_SERIES_PROVIDER_PTR void* #define TS_GEOMETRY_PTR void* #define DATE_TIME_INFO_PTR void* #define MULTI_REGULAR_SERIES_STRUCT_PTR void* Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes/extern_c_api_as_opaque.h"},{"location":"cpp/Files/extern__c__api__as__opaque_8h/#datatypesextern_c_api_as_opaqueh","text":"","title":"datatypes/extern_c_api_as_opaque.h"},{"location":"cpp/Files/extern__c__api__as__opaque_8h/#defines","text":"Name DATATYPES_TIME_SERIES_DOUBLE_PTR DATATYPES_ENSEMBLE_TIME_SERIES_DOUBLE_PTR ENSEMBLE_DATA_SET_PTR ENSEMBLE_FORECAST_TIME_SERIES_PTR TIME_SERIES_PTR ENSEMBLE_TIME_SERIES_PTR ENSEMBLE_PTR_TIME_SERIES_PTR TIME_SERIES_PROVIDER_PTR TS_GEOMETRY_PTR DATE_TIME_INFO_PTR MULTI_REGULAR_SERIES_STRUCT_PTR","title":"Defines"},{"location":"cpp/Files/extern__c__api__as__opaque_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"cpp/Files/extern__c__api__as__opaque_8h/#define-datatypes_time_series_double_ptr","text":"#define DATATYPES_TIME_SERIES_DOUBLE_PTR void*","title":"define DATATYPES_TIME_SERIES_DOUBLE_PTR"},{"location":"cpp/Files/extern__c__api__as__opaque_8h/#define-datatypes_ensemble_time_series_double_ptr","text":"#define DATATYPES_ENSEMBLE_TIME_SERIES_DOUBLE_PTR void*","title":"define DATATYPES_ENSEMBLE_TIME_SERIES_DOUBLE_PTR"},{"location":"cpp/Files/extern__c__api__as__opaque_8h/#define-ensemble_data_set_ptr","text":"#define ENSEMBLE_DATA_SET_PTR void*","title":"define ENSEMBLE_DATA_SET_PTR"},{"location":"cpp/Files/extern__c__api__as__opaque_8h/#define-ensemble_forecast_time_series_ptr","text":"#define ENSEMBLE_FORECAST_TIME_SERIES_PTR void*","title":"define ENSEMBLE_FORECAST_TIME_SERIES_PTR"},{"location":"cpp/Files/extern__c__api__as__opaque_8h/#define-time_series_ptr","text":"#define TIME_SERIES_PTR void*","title":"define TIME_SERIES_PTR"},{"location":"cpp/Files/extern__c__api__as__opaque_8h/#define-ensemble_time_series_ptr","text":"#define ENSEMBLE_TIME_SERIES_PTR void*","title":"define ENSEMBLE_TIME_SERIES_PTR"},{"location":"cpp/Files/extern__c__api__as__opaque_8h/#define-ensemble_ptr_time_series_ptr","text":"#define ENSEMBLE_PTR_TIME_SERIES_PTR void*","title":"define ENSEMBLE_PTR_TIME_SERIES_PTR"},{"location":"cpp/Files/extern__c__api__as__opaque_8h/#define-time_series_provider_ptr","text":"#define TIME_SERIES_PROVIDER_PTR void*","title":"define TIME_SERIES_PROVIDER_PTR"},{"location":"cpp/Files/extern__c__api__as__opaque_8h/#define-ts_geometry_ptr","text":"#define TS_GEOMETRY_PTR void*","title":"define TS_GEOMETRY_PTR"},{"location":"cpp/Files/extern__c__api__as__opaque_8h/#define-date_time_info_ptr","text":"#define DATE_TIME_INFO_PTR void*","title":"define DATE_TIME_INFO_PTR"},{"location":"cpp/Files/extern__c__api__as__opaque_8h/#define-multi_regular_series_struct_ptr","text":"#define MULTI_REGULAR_SERIES_STRUCT_PTR void*","title":"define MULTI_REGULAR_SERIES_STRUCT_PTR"},{"location":"cpp/Files/extern__c__api__as__opaque_8h/#source-code","text":"#pragma once #include \"moirai/extern_c_api_as_opaque.h\" #define DATATYPES_TIME_SERIES_DOUBLE_PTR void* #define DATATYPES_ENSEMBLE_TIME_SERIES_DOUBLE_PTR void* #define ENSEMBLE_DATA_SET_PTR void* #define ENSEMBLE_FORECAST_TIME_SERIES_PTR void* #define TIME_SERIES_PTR void* #define ENSEMBLE_TIME_SERIES_PTR void* #define ENSEMBLE_PTR_TIME_SERIES_PTR void* #define TIME_SERIES_PROVIDER_PTR void* #define TS_GEOMETRY_PTR void* #define DATE_TIME_INFO_PTR void* #define MULTI_REGULAR_SERIES_STRUCT_PTR void* Updated on 2022-08-20 at 19:28:22 +1000","title":"Source code"},{"location":"cpp/Files/extern__c__api__as__transparent_8h/","text":"datatypes/extern_c_api_as_transparent.h \u00b6 Defines \u00b6 Name TIME_SERIES_PTR ENSEMBLE_DATA_SET_PTR ENSEMBLE_FORECAST_TIME_SERIES_PTR ENSEMBLE_TIME_SERIES_PTR ENSEMBLE_PTR_TIME_SERIES_PTR TIME_SERIES_PROVIDER_PTR Macros Documentation \u00b6 define TIME_SERIES_PTR \u00b6 #define TIME_SERIES_PTR TIME_SERIES_TRANSPARENT_PTR define ENSEMBLE_DATA_SET_PTR \u00b6 #define ENSEMBLE_DATA_SET_PTR ENSEMBLE_DATA_SET_TRANSPARENT_PTR define ENSEMBLE_FORECAST_TIME_SERIES_PTR \u00b6 #define ENSEMBLE_FORECAST_TIME_SERIES_PTR ENSEMBLE_FORECAST_TIME_SERIES_TRANSPARENT_PTR define ENSEMBLE_TIME_SERIES_PTR \u00b6 #define ENSEMBLE_TIME_SERIES_PTR ENSEMBLE_TIME_SERIES_TRANSPARENT_PTR define ENSEMBLE_PTR_TIME_SERIES_PTR \u00b6 #define ENSEMBLE_PTR_TIME_SERIES_PTR ENSEMBLE_PTR_TIME_SERIES_TRANSPARENT_PTR define TIME_SERIES_PROVIDER_PTR \u00b6 #define TIME_SERIES_PROVIDER_PTR TIME_SERIES_PROVIDER_TRANSPARENT_PTR Source code \u00b6 #pragma once #include \"moirai/extern_c_api_as_transparent.h\" #include \"extern_c_api_transparent_pointers.h\" #define TIME_SERIES_PTR TIME_SERIES_TRANSPARENT_PTR #define ENSEMBLE_DATA_SET_PTR ENSEMBLE_DATA_SET_TRANSPARENT_PTR #define ENSEMBLE_FORECAST_TIME_SERIES_PTR ENSEMBLE_FORECAST_TIME_SERIES_TRANSPARENT_PTR #define ENSEMBLE_TIME_SERIES_PTR ENSEMBLE_TIME_SERIES_TRANSPARENT_PTR #define ENSEMBLE_PTR_TIME_SERIES_PTR ENSEMBLE_PTR_TIME_SERIES_TRANSPARENT_PTR #define TIME_SERIES_PROVIDER_PTR TIME_SERIES_PROVIDER_TRANSPARENT_PTR Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes/extern_c_api_as_transparent.h"},{"location":"cpp/Files/extern__c__api__as__transparent_8h/#datatypesextern_c_api_as_transparenth","text":"","title":"datatypes/extern_c_api_as_transparent.h"},{"location":"cpp/Files/extern__c__api__as__transparent_8h/#defines","text":"Name TIME_SERIES_PTR ENSEMBLE_DATA_SET_PTR ENSEMBLE_FORECAST_TIME_SERIES_PTR ENSEMBLE_TIME_SERIES_PTR ENSEMBLE_PTR_TIME_SERIES_PTR TIME_SERIES_PROVIDER_PTR","title":"Defines"},{"location":"cpp/Files/extern__c__api__as__transparent_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"cpp/Files/extern__c__api__as__transparent_8h/#define-time_series_ptr","text":"#define TIME_SERIES_PTR TIME_SERIES_TRANSPARENT_PTR","title":"define TIME_SERIES_PTR"},{"location":"cpp/Files/extern__c__api__as__transparent_8h/#define-ensemble_data_set_ptr","text":"#define ENSEMBLE_DATA_SET_PTR ENSEMBLE_DATA_SET_TRANSPARENT_PTR","title":"define ENSEMBLE_DATA_SET_PTR"},{"location":"cpp/Files/extern__c__api__as__transparent_8h/#define-ensemble_forecast_time_series_ptr","text":"#define ENSEMBLE_FORECAST_TIME_SERIES_PTR ENSEMBLE_FORECAST_TIME_SERIES_TRANSPARENT_PTR","title":"define ENSEMBLE_FORECAST_TIME_SERIES_PTR"},{"location":"cpp/Files/extern__c__api__as__transparent_8h/#define-ensemble_time_series_ptr","text":"#define ENSEMBLE_TIME_SERIES_PTR ENSEMBLE_TIME_SERIES_TRANSPARENT_PTR","title":"define ENSEMBLE_TIME_SERIES_PTR"},{"location":"cpp/Files/extern__c__api__as__transparent_8h/#define-ensemble_ptr_time_series_ptr","text":"#define ENSEMBLE_PTR_TIME_SERIES_PTR ENSEMBLE_PTR_TIME_SERIES_TRANSPARENT_PTR","title":"define ENSEMBLE_PTR_TIME_SERIES_PTR"},{"location":"cpp/Files/extern__c__api__as__transparent_8h/#define-time_series_provider_ptr","text":"#define TIME_SERIES_PROVIDER_PTR TIME_SERIES_PROVIDER_TRANSPARENT_PTR","title":"define TIME_SERIES_PROVIDER_PTR"},{"location":"cpp/Files/extern__c__api__as__transparent_8h/#source-code","text":"#pragma once #include \"moirai/extern_c_api_as_transparent.h\" #include \"extern_c_api_transparent_pointers.h\" #define TIME_SERIES_PTR TIME_SERIES_TRANSPARENT_PTR #define ENSEMBLE_DATA_SET_PTR ENSEMBLE_DATA_SET_TRANSPARENT_PTR #define ENSEMBLE_FORECAST_TIME_SERIES_PTR ENSEMBLE_FORECAST_TIME_SERIES_TRANSPARENT_PTR #define ENSEMBLE_TIME_SERIES_PTR ENSEMBLE_TIME_SERIES_TRANSPARENT_PTR #define ENSEMBLE_PTR_TIME_SERIES_PTR ENSEMBLE_PTR_TIME_SERIES_TRANSPARENT_PTR #define TIME_SERIES_PROVIDER_PTR TIME_SERIES_PROVIDER_TRANSPARENT_PTR Updated on 2022-08-20 at 19:28:22 +1000","title":"Source code"},{"location":"cpp/Files/extern__c__api__transparent__pointers_8h/","text":"datatypes/extern_c_api_transparent_pointers.h \u00b6 Defines \u00b6 Name DATATYPES_TIME_SERIES_DOUBLE DATATYPES_TIME_SERIES_DOUBLE_PTR DATATYPES_ENSEMBLE_TIME_SERIES_DOUBLE DATATYPES_ENSEMBLE_PTR_TIME_SERIES_DOUBLE ENSEMBLE_FORECAST_TIME_SERIES_DOUBLE TS_GEOMETRY_PTR MULTI_REGULAR_SERIES_STRUCT_PTR DATE_TIME_INFO_PTR TIME_SERIES_TRANSPARENT_PTR ENSEMBLE_DATA_SET_TRANSPARENT_PTR ENSEMBLE_FORECAST_TIME_SERIES_TRANSPARENT_PTR ENSEMBLE_TIME_SERIES_TRANSPARENT_PTR ENSEMBLE_PTR_TIME_SERIES_TRANSPARENT_PTR TIME_SERIES_PROVIDER_TRANSPARENT_PTR Macros Documentation \u00b6 define DATATYPES_TIME_SERIES_DOUBLE \u00b6 #define DATATYPES_TIME_SERIES_DOUBLE TimeSeries define DATATYPES_TIME_SERIES_DOUBLE_PTR \u00b6 #define DATATYPES_TIME_SERIES_DOUBLE_PTR DATATYPES_TIME_SERIES_DOUBLE* define DATATYPES_ENSEMBLE_TIME_SERIES_DOUBLE \u00b6 #define DATATYPES_ENSEMBLE_TIME_SERIES_DOUBLE MultiTimeSeries<DATATYPES_TIME_SERIES_DOUBLE> define DATATYPES_ENSEMBLE_PTR_TIME_SERIES_DOUBLE \u00b6 #define DATATYPES_ENSEMBLE_PTR_TIME_SERIES_DOUBLE MultiTimeSeries<DATATYPES_TIME_SERIES_DOUBLE_PTR> define ENSEMBLE_FORECAST_TIME_SERIES_DOUBLE \u00b6 #define ENSEMBLE_FORECAST_TIME_SERIES_DOUBLE EnsembleForecastTimeSeries<DATATYPES_TIME_SERIES_DOUBLE> define TS_GEOMETRY_PTR \u00b6 #define TS_GEOMETRY_PTR regular_time_series_geometry* define MULTI_REGULAR_SERIES_STRUCT_PTR \u00b6 #define MULTI_REGULAR_SERIES_STRUCT_PTR multi_regular_time_series_data* define DATE_TIME_INFO_PTR \u00b6 #define DATE_TIME_INFO_PTR date_time_to_second* define TIME_SERIES_TRANSPARENT_PTR \u00b6 #define TIME_SERIES_TRANSPARENT_PTR reference_handle<DATATYPES_TIME_SERIES_DOUBLE>* define ENSEMBLE_DATA_SET_TRANSPARENT_PTR \u00b6 #define ENSEMBLE_DATA_SET_TRANSPARENT_PTR reference_handle<TimeSeriesLibrary>* define ENSEMBLE_FORECAST_TIME_SERIES_TRANSPARENT_PTR \u00b6 #define ENSEMBLE_FORECAST_TIME_SERIES_TRANSPARENT_PTR reference_handle<ENSEMBLE_FORECAST_TIME_SERIES_DOUBLE>* define ENSEMBLE_TIME_SERIES_TRANSPARENT_PTR \u00b6 #define ENSEMBLE_TIME_SERIES_TRANSPARENT_PTR reference_handle<DATATYPES_ENSEMBLE_TIME_SERIES_DOUBLE>* define ENSEMBLE_PTR_TIME_SERIES_TRANSPARENT_PTR \u00b6 #define ENSEMBLE_PTR_TIME_SERIES_TRANSPARENT_PTR reference_handle<DATATYPES_ENSEMBLE_PTR_TIME_SERIES_DOUBLE>* define TIME_SERIES_PROVIDER_TRANSPARENT_PTR \u00b6 #define TIME_SERIES_PROVIDER_TRANSPARENT_PTR reference_handle<TimeSeriesProvider<double>>* Source code \u00b6 // This file deliberately does not have a #pragma once directive #include \"datatypes/setup_exports.h\" #include \"datatypes/interop_struct.h\" #include \"datatypes/time_series_store.hpp\" #include \"moirai/reference_handle.hpp\" using namespace datatypes :: timeseries ; #define DATATYPES_TIME_SERIES_DOUBLE TimeSeries #define DATATYPES_TIME_SERIES_DOUBLE_PTR DATATYPES_TIME_SERIES_DOUBLE* #define DATATYPES_ENSEMBLE_TIME_SERIES_DOUBLE MultiTimeSeries<DATATYPES_TIME_SERIES_DOUBLE> #define DATATYPES_ENSEMBLE_PTR_TIME_SERIES_DOUBLE MultiTimeSeries<DATATYPES_TIME_SERIES_DOUBLE_PTR> #define ENSEMBLE_FORECAST_TIME_SERIES_DOUBLE EnsembleForecastTimeSeries<DATATYPES_TIME_SERIES_DOUBLE> #define TS_GEOMETRY_PTR regular_time_series_geometry* #define MULTI_REGULAR_SERIES_STRUCT_PTR multi_regular_time_series_data* #define DATE_TIME_INFO_PTR date_time_to_second* // Definitions of macros for reference_handle<> using moirai :: reference_handle ; #define TIME_SERIES_TRANSPARENT_PTR reference_handle<DATATYPES_TIME_SERIES_DOUBLE>* #define ENSEMBLE_DATA_SET_TRANSPARENT_PTR reference_handle<TimeSeriesLibrary>* #define ENSEMBLE_FORECAST_TIME_SERIES_TRANSPARENT_PTR reference_handle<ENSEMBLE_FORECAST_TIME_SERIES_DOUBLE>* #define ENSEMBLE_TIME_SERIES_TRANSPARENT_PTR reference_handle<DATATYPES_ENSEMBLE_TIME_SERIES_DOUBLE>* #define ENSEMBLE_PTR_TIME_SERIES_TRANSPARENT_PTR reference_handle<DATATYPES_ENSEMBLE_PTR_TIME_SERIES_DOUBLE>* #define TIME_SERIES_PROVIDER_TRANSPARENT_PTR reference_handle<TimeSeriesProvider<double>>* Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes/extern_c_api_transparent_pointers.h"},{"location":"cpp/Files/extern__c__api__transparent__pointers_8h/#datatypesextern_c_api_transparent_pointersh","text":"","title":"datatypes/extern_c_api_transparent_pointers.h"},{"location":"cpp/Files/extern__c__api__transparent__pointers_8h/#defines","text":"Name DATATYPES_TIME_SERIES_DOUBLE DATATYPES_TIME_SERIES_DOUBLE_PTR DATATYPES_ENSEMBLE_TIME_SERIES_DOUBLE DATATYPES_ENSEMBLE_PTR_TIME_SERIES_DOUBLE ENSEMBLE_FORECAST_TIME_SERIES_DOUBLE TS_GEOMETRY_PTR MULTI_REGULAR_SERIES_STRUCT_PTR DATE_TIME_INFO_PTR TIME_SERIES_TRANSPARENT_PTR ENSEMBLE_DATA_SET_TRANSPARENT_PTR ENSEMBLE_FORECAST_TIME_SERIES_TRANSPARENT_PTR ENSEMBLE_TIME_SERIES_TRANSPARENT_PTR ENSEMBLE_PTR_TIME_SERIES_TRANSPARENT_PTR TIME_SERIES_PROVIDER_TRANSPARENT_PTR","title":"Defines"},{"location":"cpp/Files/extern__c__api__transparent__pointers_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"cpp/Files/extern__c__api__transparent__pointers_8h/#define-datatypes_time_series_double","text":"#define DATATYPES_TIME_SERIES_DOUBLE TimeSeries","title":"define DATATYPES_TIME_SERIES_DOUBLE"},{"location":"cpp/Files/extern__c__api__transparent__pointers_8h/#define-datatypes_time_series_double_ptr","text":"#define DATATYPES_TIME_SERIES_DOUBLE_PTR DATATYPES_TIME_SERIES_DOUBLE*","title":"define DATATYPES_TIME_SERIES_DOUBLE_PTR"},{"location":"cpp/Files/extern__c__api__transparent__pointers_8h/#define-datatypes_ensemble_time_series_double","text":"#define DATATYPES_ENSEMBLE_TIME_SERIES_DOUBLE MultiTimeSeries<DATATYPES_TIME_SERIES_DOUBLE>","title":"define DATATYPES_ENSEMBLE_TIME_SERIES_DOUBLE"},{"location":"cpp/Files/extern__c__api__transparent__pointers_8h/#define-datatypes_ensemble_ptr_time_series_double","text":"#define DATATYPES_ENSEMBLE_PTR_TIME_SERIES_DOUBLE MultiTimeSeries<DATATYPES_TIME_SERIES_DOUBLE_PTR>","title":"define DATATYPES_ENSEMBLE_PTR_TIME_SERIES_DOUBLE"},{"location":"cpp/Files/extern__c__api__transparent__pointers_8h/#define-ensemble_forecast_time_series_double","text":"#define ENSEMBLE_FORECAST_TIME_SERIES_DOUBLE EnsembleForecastTimeSeries<DATATYPES_TIME_SERIES_DOUBLE>","title":"define ENSEMBLE_FORECAST_TIME_SERIES_DOUBLE"},{"location":"cpp/Files/extern__c__api__transparent__pointers_8h/#define-ts_geometry_ptr","text":"#define TS_GEOMETRY_PTR regular_time_series_geometry*","title":"define TS_GEOMETRY_PTR"},{"location":"cpp/Files/extern__c__api__transparent__pointers_8h/#define-multi_regular_series_struct_ptr","text":"#define MULTI_REGULAR_SERIES_STRUCT_PTR multi_regular_time_series_data*","title":"define MULTI_REGULAR_SERIES_STRUCT_PTR"},{"location":"cpp/Files/extern__c__api__transparent__pointers_8h/#define-date_time_info_ptr","text":"#define DATE_TIME_INFO_PTR date_time_to_second*","title":"define DATE_TIME_INFO_PTR"},{"location":"cpp/Files/extern__c__api__transparent__pointers_8h/#define-time_series_transparent_ptr","text":"#define TIME_SERIES_TRANSPARENT_PTR reference_handle<DATATYPES_TIME_SERIES_DOUBLE>*","title":"define TIME_SERIES_TRANSPARENT_PTR"},{"location":"cpp/Files/extern__c__api__transparent__pointers_8h/#define-ensemble_data_set_transparent_ptr","text":"#define ENSEMBLE_DATA_SET_TRANSPARENT_PTR reference_handle<TimeSeriesLibrary>*","title":"define ENSEMBLE_DATA_SET_TRANSPARENT_PTR"},{"location":"cpp/Files/extern__c__api__transparent__pointers_8h/#define-ensemble_forecast_time_series_transparent_ptr","text":"#define ENSEMBLE_FORECAST_TIME_SERIES_TRANSPARENT_PTR reference_handle<ENSEMBLE_FORECAST_TIME_SERIES_DOUBLE>*","title":"define ENSEMBLE_FORECAST_TIME_SERIES_TRANSPARENT_PTR"},{"location":"cpp/Files/extern__c__api__transparent__pointers_8h/#define-ensemble_time_series_transparent_ptr","text":"#define ENSEMBLE_TIME_SERIES_TRANSPARENT_PTR reference_handle<DATATYPES_ENSEMBLE_TIME_SERIES_DOUBLE>*","title":"define ENSEMBLE_TIME_SERIES_TRANSPARENT_PTR"},{"location":"cpp/Files/extern__c__api__transparent__pointers_8h/#define-ensemble_ptr_time_series_transparent_ptr","text":"#define ENSEMBLE_PTR_TIME_SERIES_TRANSPARENT_PTR reference_handle<DATATYPES_ENSEMBLE_PTR_TIME_SERIES_DOUBLE>*","title":"define ENSEMBLE_PTR_TIME_SERIES_TRANSPARENT_PTR"},{"location":"cpp/Files/extern__c__api__transparent__pointers_8h/#define-time_series_provider_transparent_ptr","text":"#define TIME_SERIES_PROVIDER_TRANSPARENT_PTR reference_handle<TimeSeriesProvider<double>>*","title":"define TIME_SERIES_PROVIDER_TRANSPARENT_PTR"},{"location":"cpp/Files/extern__c__api__transparent__pointers_8h/#source-code","text":"// This file deliberately does not have a #pragma once directive #include \"datatypes/setup_exports.h\" #include \"datatypes/interop_struct.h\" #include \"datatypes/time_series_store.hpp\" #include \"moirai/reference_handle.hpp\" using namespace datatypes :: timeseries ; #define DATATYPES_TIME_SERIES_DOUBLE TimeSeries #define DATATYPES_TIME_SERIES_DOUBLE_PTR DATATYPES_TIME_SERIES_DOUBLE* #define DATATYPES_ENSEMBLE_TIME_SERIES_DOUBLE MultiTimeSeries<DATATYPES_TIME_SERIES_DOUBLE> #define DATATYPES_ENSEMBLE_PTR_TIME_SERIES_DOUBLE MultiTimeSeries<DATATYPES_TIME_SERIES_DOUBLE_PTR> #define ENSEMBLE_FORECAST_TIME_SERIES_DOUBLE EnsembleForecastTimeSeries<DATATYPES_TIME_SERIES_DOUBLE> #define TS_GEOMETRY_PTR regular_time_series_geometry* #define MULTI_REGULAR_SERIES_STRUCT_PTR multi_regular_time_series_data* #define DATE_TIME_INFO_PTR date_time_to_second* // Definitions of macros for reference_handle<> using moirai :: reference_handle ; #define TIME_SERIES_TRANSPARENT_PTR reference_handle<DATATYPES_TIME_SERIES_DOUBLE>* #define ENSEMBLE_DATA_SET_TRANSPARENT_PTR reference_handle<TimeSeriesLibrary>* #define ENSEMBLE_FORECAST_TIME_SERIES_TRANSPARENT_PTR reference_handle<ENSEMBLE_FORECAST_TIME_SERIES_DOUBLE>* #define ENSEMBLE_TIME_SERIES_TRANSPARENT_PTR reference_handle<DATATYPES_ENSEMBLE_TIME_SERIES_DOUBLE>* #define ENSEMBLE_PTR_TIME_SERIES_TRANSPARENT_PTR reference_handle<DATATYPES_ENSEMBLE_PTR_TIME_SERIES_DOUBLE>* #define TIME_SERIES_PROVIDER_TRANSPARENT_PTR reference_handle<TimeSeriesProvider<double>>* Updated on 2022-08-20 at 19:28:22 +1000","title":"Source code"},{"location":"cpp/Files/internals__c__api_8hpp/","text":"datatypes/internals_c_api.hpp \u00b6 Defines \u00b6 Name TIME_SERIES_DYNCAST (x) TIME_SERIES_PROVIDER_DYNCAST (x) ENSEMBLE_DATA_SET_DYNCAST (x) ENSEMBLE_FORECAST_TIME_SERIES_DYNCAST (x) ENSEMBLE_PTR_TIME_SERIES_DYNCAST (x) DATE_TIME_INFO_DYNCAST (x) TS_GEOMETRY_DYNCAST (x) FREE_ARRAY (x) WRAP_DATE_TIME_INFO_PTR (x) WRAP_TIME_SERIES_PROVIDER_PTR (x) WRAP_ENSEMBLE_DATA_SET_PTR (x) WRAP_TIME_SERIES_PTR (x) WRAP_ENSEMBLE_FORECAST_TIME_SERIES_PTR (x) WRAP_ENSEMBLE_TIME_SERIES_PTR (x) Macros Documentation \u00b6 define TIME_SERIES_DYNCAST \u00b6 #define TIME_SERIES_DYNCAST( x ) CHECKED_RETRIEVE_PTR ( DATATYPES_TIME_SERIES_DOUBLE , x ) define TIME_SERIES_PROVIDER_DYNCAST \u00b6 #define TIME_SERIES_PROVIDER_DYNCAST( x ) CHECKED_RETRIEVE_PTR ( TimeSeriesProvider < double > , x ) define ENSEMBLE_DATA_SET_DYNCAST \u00b6 #define ENSEMBLE_DATA_SET_DYNCAST( x ) CHECKED_RETRIEVE_PTR ( TimeSeriesLibrary , x ) define ENSEMBLE_FORECAST_TIME_SERIES_DYNCAST \u00b6 #define ENSEMBLE_FORECAST_TIME_SERIES_DYNCAST( x ) CHECKED_RETRIEVE_PTR ( ENSEMBLE_FORECAST_TIME_SERIES_DOUBLE , x ) define ENSEMBLE_PTR_TIME_SERIES_DYNCAST \u00b6 #define ENSEMBLE_PTR_TIME_SERIES_DYNCAST( x ) CHECKED_RETRIEVE_PTR ( DATATYPES_ENSEMBLE_PTR_TIME_SERIES_DOUBLE , x ) define DATE_TIME_INFO_DYNCAST \u00b6 #define DATE_TIME_INFO_DYNCAST( x ) ( date_time_to_second * ) x define TS_GEOMETRY_DYNCAST \u00b6 #define TS_GEOMETRY_DYNCAST( x ) x define FREE_ARRAY \u00b6 #define FREE_ARRAY( x ) delete [] x define WRAP_DATE_TIME_INFO_PTR \u00b6 #define WRAP_DATE_TIME_INFO_PTR( x ) new reference_handle < date_time_to_second > ( x ) define WRAP_TIME_SERIES_PROVIDER_PTR \u00b6 #define WRAP_TIME_SERIES_PROVIDER_PTR( x ) new reference_handle < TimeSeriesProvider < double >> ( x ) define WRAP_ENSEMBLE_DATA_SET_PTR \u00b6 #define WRAP_ENSEMBLE_DATA_SET_PTR( x ) new reference_handle < TimeSeriesLibrary > ( x ) define WRAP_TIME_SERIES_PTR \u00b6 #define WRAP_TIME_SERIES_PTR( x ) new reference_handle < DATATYPES_TIME_SERIES_DOUBLE > ( x ) define WRAP_ENSEMBLE_FORECAST_TIME_SERIES_PTR \u00b6 #define WRAP_ENSEMBLE_FORECAST_TIME_SERIES_PTR( x ) new reference_handle < EnsembleForecastTimeSeries < DATATYPES_TIME_SERIES_DOUBLE >> ( x ) define WRAP_ENSEMBLE_TIME_SERIES_PTR \u00b6 #define WRAP_ENSEMBLE_TIME_SERIES_PTR( x ) new reference_handle < DATATYPES_ENSEMBLE_PTR_TIME_SERIES_DOUBLE > ( x ) Source code \u00b6 #pragma once #include \"moirai/reference_handle.hpp\" #include \"datatypes/extern_c_api_transparent_pointers.h\" #define TIME_SERIES_DYNCAST(x) CHECKED_RETRIEVE_PTR(DATATYPES_TIME_SERIES_DOUBLE, x) #define TIME_SERIES_PROVIDER_DYNCAST(x) CHECKED_RETRIEVE_PTR(TimeSeriesProvider<double>, x) #define ENSEMBLE_DATA_SET_DYNCAST(x) CHECKED_RETRIEVE_PTR(TimeSeriesLibrary, x) #define ENSEMBLE_FORECAST_TIME_SERIES_DYNCAST(x) CHECKED_RETRIEVE_PTR(ENSEMBLE_FORECAST_TIME_SERIES_DOUBLE, x) #define ENSEMBLE_PTR_TIME_SERIES_DYNCAST(x) CHECKED_RETRIEVE_PTR(DATATYPES_ENSEMBLE_PTR_TIME_SERIES_DOUBLE, x) #define DATE_TIME_INFO_DYNCAST(x) (date_time_to_second*)x #define TS_GEOMETRY_DYNCAST(x) x #define FREE_ARRAY(x) delete[] x #define WRAP_DATE_TIME_INFO_PTR(x) new reference_handle<date_time_to_second>(x) #define WRAP_TIME_SERIES_PROVIDER_PTR(x) new reference_handle<TimeSeriesProvider<double>>(x) #define WRAP_ENSEMBLE_DATA_SET_PTR(x) new reference_handle<TimeSeriesLibrary>(x) #define WRAP_TIME_SERIES_PTR(x) new reference_handle<DATATYPES_TIME_SERIES_DOUBLE>(x) #define WRAP_ENSEMBLE_FORECAST_TIME_SERIES_PTR(x) new reference_handle<EnsembleForecastTimeSeries<DATATYPES_TIME_SERIES_DOUBLE>>(x) #define WRAP_ENSEMBLE_TIME_SERIES_PTR(x) new reference_handle<DATATYPES_ENSEMBLE_PTR_TIME_SERIES_DOUBLE>(x) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes/internals_c_api.hpp"},{"location":"cpp/Files/internals__c__api_8hpp/#datatypesinternals_c_apihpp","text":"","title":"datatypes/internals_c_api.hpp"},{"location":"cpp/Files/internals__c__api_8hpp/#defines","text":"Name TIME_SERIES_DYNCAST (x) TIME_SERIES_PROVIDER_DYNCAST (x) ENSEMBLE_DATA_SET_DYNCAST (x) ENSEMBLE_FORECAST_TIME_SERIES_DYNCAST (x) ENSEMBLE_PTR_TIME_SERIES_DYNCAST (x) DATE_TIME_INFO_DYNCAST (x) TS_GEOMETRY_DYNCAST (x) FREE_ARRAY (x) WRAP_DATE_TIME_INFO_PTR (x) WRAP_TIME_SERIES_PROVIDER_PTR (x) WRAP_ENSEMBLE_DATA_SET_PTR (x) WRAP_TIME_SERIES_PTR (x) WRAP_ENSEMBLE_FORECAST_TIME_SERIES_PTR (x) WRAP_ENSEMBLE_TIME_SERIES_PTR (x)","title":"Defines"},{"location":"cpp/Files/internals__c__api_8hpp/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"cpp/Files/internals__c__api_8hpp/#define-time_series_dyncast","text":"#define TIME_SERIES_DYNCAST( x ) CHECKED_RETRIEVE_PTR ( DATATYPES_TIME_SERIES_DOUBLE , x )","title":"define TIME_SERIES_DYNCAST"},{"location":"cpp/Files/internals__c__api_8hpp/#define-time_series_provider_dyncast","text":"#define TIME_SERIES_PROVIDER_DYNCAST( x ) CHECKED_RETRIEVE_PTR ( TimeSeriesProvider < double > , x )","title":"define TIME_SERIES_PROVIDER_DYNCAST"},{"location":"cpp/Files/internals__c__api_8hpp/#define-ensemble_data_set_dyncast","text":"#define ENSEMBLE_DATA_SET_DYNCAST( x ) CHECKED_RETRIEVE_PTR ( TimeSeriesLibrary , x )","title":"define ENSEMBLE_DATA_SET_DYNCAST"},{"location":"cpp/Files/internals__c__api_8hpp/#define-ensemble_forecast_time_series_dyncast","text":"#define ENSEMBLE_FORECAST_TIME_SERIES_DYNCAST( x ) CHECKED_RETRIEVE_PTR ( ENSEMBLE_FORECAST_TIME_SERIES_DOUBLE , x )","title":"define ENSEMBLE_FORECAST_TIME_SERIES_DYNCAST"},{"location":"cpp/Files/internals__c__api_8hpp/#define-ensemble_ptr_time_series_dyncast","text":"#define ENSEMBLE_PTR_TIME_SERIES_DYNCAST( x ) CHECKED_RETRIEVE_PTR ( DATATYPES_ENSEMBLE_PTR_TIME_SERIES_DOUBLE , x )","title":"define ENSEMBLE_PTR_TIME_SERIES_DYNCAST"},{"location":"cpp/Files/internals__c__api_8hpp/#define-date_time_info_dyncast","text":"#define DATE_TIME_INFO_DYNCAST( x ) ( date_time_to_second * ) x","title":"define DATE_TIME_INFO_DYNCAST"},{"location":"cpp/Files/internals__c__api_8hpp/#define-ts_geometry_dyncast","text":"#define TS_GEOMETRY_DYNCAST( x ) x","title":"define TS_GEOMETRY_DYNCAST"},{"location":"cpp/Files/internals__c__api_8hpp/#define-free_array","text":"#define FREE_ARRAY( x ) delete [] x","title":"define FREE_ARRAY"},{"location":"cpp/Files/internals__c__api_8hpp/#define-wrap_date_time_info_ptr","text":"#define WRAP_DATE_TIME_INFO_PTR( x ) new reference_handle < date_time_to_second > ( x )","title":"define WRAP_DATE_TIME_INFO_PTR"},{"location":"cpp/Files/internals__c__api_8hpp/#define-wrap_time_series_provider_ptr","text":"#define WRAP_TIME_SERIES_PROVIDER_PTR( x ) new reference_handle < TimeSeriesProvider < double >> ( x )","title":"define WRAP_TIME_SERIES_PROVIDER_PTR"},{"location":"cpp/Files/internals__c__api_8hpp/#define-wrap_ensemble_data_set_ptr","text":"#define WRAP_ENSEMBLE_DATA_SET_PTR( x ) new reference_handle < TimeSeriesLibrary > ( x )","title":"define WRAP_ENSEMBLE_DATA_SET_PTR"},{"location":"cpp/Files/internals__c__api_8hpp/#define-wrap_time_series_ptr","text":"#define WRAP_TIME_SERIES_PTR( x ) new reference_handle < DATATYPES_TIME_SERIES_DOUBLE > ( x )","title":"define WRAP_TIME_SERIES_PTR"},{"location":"cpp/Files/internals__c__api_8hpp/#define-wrap_ensemble_forecast_time_series_ptr","text":"#define WRAP_ENSEMBLE_FORECAST_TIME_SERIES_PTR( x ) new reference_handle < EnsembleForecastTimeSeries < DATATYPES_TIME_SERIES_DOUBLE >> ( x )","title":"define WRAP_ENSEMBLE_FORECAST_TIME_SERIES_PTR"},{"location":"cpp/Files/internals__c__api_8hpp/#define-wrap_ensemble_time_series_ptr","text":"#define WRAP_ENSEMBLE_TIME_SERIES_PTR( x ) new reference_handle < DATATYPES_ENSEMBLE_PTR_TIME_SERIES_DOUBLE > ( x )","title":"define WRAP_ENSEMBLE_TIME_SERIES_PTR"},{"location":"cpp/Files/internals__c__api_8hpp/#source-code","text":"#pragma once #include \"moirai/reference_handle.hpp\" #include \"datatypes/extern_c_api_transparent_pointers.h\" #define TIME_SERIES_DYNCAST(x) CHECKED_RETRIEVE_PTR(DATATYPES_TIME_SERIES_DOUBLE, x) #define TIME_SERIES_PROVIDER_DYNCAST(x) CHECKED_RETRIEVE_PTR(TimeSeriesProvider<double>, x) #define ENSEMBLE_DATA_SET_DYNCAST(x) CHECKED_RETRIEVE_PTR(TimeSeriesLibrary, x) #define ENSEMBLE_FORECAST_TIME_SERIES_DYNCAST(x) CHECKED_RETRIEVE_PTR(ENSEMBLE_FORECAST_TIME_SERIES_DOUBLE, x) #define ENSEMBLE_PTR_TIME_SERIES_DYNCAST(x) CHECKED_RETRIEVE_PTR(DATATYPES_ENSEMBLE_PTR_TIME_SERIES_DOUBLE, x) #define DATE_TIME_INFO_DYNCAST(x) (date_time_to_second*)x #define TS_GEOMETRY_DYNCAST(x) x #define FREE_ARRAY(x) delete[] x #define WRAP_DATE_TIME_INFO_PTR(x) new reference_handle<date_time_to_second>(x) #define WRAP_TIME_SERIES_PROVIDER_PTR(x) new reference_handle<TimeSeriesProvider<double>>(x) #define WRAP_ENSEMBLE_DATA_SET_PTR(x) new reference_handle<TimeSeriesLibrary>(x) #define WRAP_TIME_SERIES_PTR(x) new reference_handle<DATATYPES_TIME_SERIES_DOUBLE>(x) #define WRAP_ENSEMBLE_FORECAST_TIME_SERIES_PTR(x) new reference_handle<EnsembleForecastTimeSeries<DATATYPES_TIME_SERIES_DOUBLE>>(x) #define WRAP_ENSEMBLE_TIME_SERIES_PTR(x) new reference_handle<DATATYPES_ENSEMBLE_PTR_TIME_SERIES_DOUBLE>(x) Updated on 2022-08-20 at 19:28:22 +1000","title":"Source code"},{"location":"cpp/Files/interop__conversions_8h/","text":"datatypes/interop_conversions.h \u00b6 Namespaces \u00b6 Name cinterop::utils Functions \u00b6 Name DATATYPES_DLL_LIB TimeSeries CreateTimeSeries (double * values, const regular_time_series_geometry & g) DATATYPES_DLL_LIB TimeSeries CreateTimeSeries (double * values, TS_GEOMETRY_PTR geom) DATATYPES_DLL_LIB TimeSeries CreateTimeSeries (const multi_regular_time_series_data & g) DATATYPES_DLL_LIB TimeSeriesEnsemble < TimeSeries > ToTimeSeriesEnsemble (const multi_regular_time_series_data & rawData) DATATYPES_DLL_LIB TimeSeriesEnsemble < TimeSeries > * ToTimeSeriesEnsemblePtr (const multi_regular_time_series_data & rawData) DATATYPES_DLL_LIB multi_regular_time_series_data * ToMultiTimeSeriesDataPtr (const TimeSeriesEnsemble < TimeSeries > & mts) DATATYPES_DLL_LIB multi_regular_time_series_data * ToMultiTimeSeriesDataPtr (const TimeSeries & ts) DATATYPES_DLL_LIB TimeSeries * SingleTsPtrFromMultiTimeSeriesData (const multi_regular_time_series_data & ts) DATATYPES_DLL_LIB TimeSeriesEnsemble < TimeSeries > * MultiTsPtrFromMultiTimeSeriesData (const multi_regular_time_series_data & ts) DATATYPES_DLL_LIB TimeSeries SingleTsFromMultiTimeSeriesData (const multi_regular_time_series_data & ts) DATATYPES_DLL_LIB TimeSeriesEnsemble < TimeSeries > MultiTsFromMultiTimeSeriesData (const multi_regular_time_series_data & ts) DATATYPES_DLL_LIB time_series_dimensions_description * ToTimeSeriesDimensionDescriptions (vector< DataDimensionDescriptor > & mts) DATATYPES_DLL_LIB void CopyToMultiTimeSeriesData (const TimeSeriesEnsemble < TimeSeries > & mts, multi_regular_time_series_data & result) DATATYPES_DLL_LIB void CopyToMultiTimeSeriesData (const TimeSeries & ts, multi_regular_time_series_data & result) DATATYPES_DLL_LIB void CopyFromMultiTimeSeriesData (const multi_regular_time_series_data & interopdata, TimeSeries & ts) DATATYPES_DLL_LIB void CopyFromMultiTimeSeriesData (const multi_regular_time_series_data & interopdata, TimeSeriesEnsemble < TimeSeries > & mts) DATATYPES_DLL_LIB double ** ToRawData (const TimeSeriesEnsemble < TimeSeries > & mts) DATATYPES_DLL_LIB double * ToRawData (const TimeSeries & ts) DATATYPES_DLL_LIB void DisposeMultiTimeSeriesData (multi_regular_time_series_data * d) DATATYPES_DLL_LIB void DisposeTimeSeriesDimensionDescriptions (time_series_dimensions_description * d) Functions Documentation \u00b6 function CreateTimeSeries \u00b6 DATATYPES_DLL_LIBTimeSeries CreateTimeSeries ( double * values , const regular_time_series_geometry & g ) function CreateTimeSeries \u00b6 DATATYPES_DLL_LIBTimeSeries CreateTimeSeries ( double * values , TS_GEOMETRY_PTR geom ) function CreateTimeSeries \u00b6 DATATYPES_DLL_LIBTimeSeries CreateTimeSeries ( const multi_regular_time_series_data & g ) function ToTimeSeriesEnsemble \u00b6 DATATYPES_DLL_LIBTimeSeriesEnsemble < TimeSeries > ToTimeSeriesEnsemble ( const multi_regular_time_series_data & rawData ) function ToTimeSeriesEnsemblePtr \u00b6 DATATYPES_DLL_LIBTimeSeriesEnsemble < TimeSeries > * ToTimeSeriesEnsemblePtr ( const multi_regular_time_series_data & rawData ) function ToMultiTimeSeriesDataPtr \u00b6 DATATYPES_DLL_LIB multi_regular_time_series_data * ToMultiTimeSeriesDataPtr ( const TimeSeriesEnsemble < TimeSeries > & mts ) function ToMultiTimeSeriesDataPtr \u00b6 DATATYPES_DLL_LIB multi_regular_time_series_data * ToMultiTimeSeriesDataPtr ( const TimeSeries & ts ) function SingleTsPtrFromMultiTimeSeriesData \u00b6 DATATYPES_DLL_LIBTimeSeries * SingleTsPtrFromMultiTimeSeriesData ( const multi_regular_time_series_data & ts ) function MultiTsPtrFromMultiTimeSeriesData \u00b6 DATATYPES_DLL_LIBTimeSeriesEnsemble < TimeSeries > * MultiTsPtrFromMultiTimeSeriesData ( const multi_regular_time_series_data & ts ) function SingleTsFromMultiTimeSeriesData \u00b6 DATATYPES_DLL_LIBTimeSeries SingleTsFromMultiTimeSeriesData ( const multi_regular_time_series_data & ts ) function MultiTsFromMultiTimeSeriesData \u00b6 DATATYPES_DLL_LIBTimeSeriesEnsemble < TimeSeries > MultiTsFromMultiTimeSeriesData ( const multi_regular_time_series_data & ts ) function ToTimeSeriesDimensionDescriptions \u00b6 DATATYPES_DLL_LIB time_series_dimensions_description * ToTimeSeriesDimensionDescriptions ( vector < DataDimensionDescriptor > & mts ) function CopyToMultiTimeSeriesData \u00b6 DATATYPES_DLL_LIB void CopyToMultiTimeSeriesData ( const TimeSeriesEnsemble < TimeSeries > & mts , multi_regular_time_series_data & result ) function CopyToMultiTimeSeriesData \u00b6 DATATYPES_DLL_LIB void CopyToMultiTimeSeriesData ( const TimeSeries & ts , multi_regular_time_series_data & result ) function CopyFromMultiTimeSeriesData \u00b6 DATATYPES_DLL_LIB void CopyFromMultiTimeSeriesData ( const multi_regular_time_series_data & interopdata , TimeSeries & ts ) function CopyFromMultiTimeSeriesData \u00b6 DATATYPES_DLL_LIB void CopyFromMultiTimeSeriesData ( const multi_regular_time_series_data & interopdata , TimeSeriesEnsemble < TimeSeries > & mts ) function ToRawData \u00b6 DATATYPES_DLL_LIB double ** ToRawData ( const TimeSeriesEnsemble < TimeSeries > & mts ) function ToRawData \u00b6 DATATYPES_DLL_LIB double * ToRawData ( const TimeSeries & ts ) function DisposeMultiTimeSeriesData \u00b6 DATATYPES_DLL_LIB void DisposeMultiTimeSeriesData ( multi_regular_time_series_data * d ) function DisposeTimeSeriesDimensionDescriptions \u00b6 DATATYPES_DLL_LIB void DisposeTimeSeriesDimensionDescriptions ( time_series_dimensions_description * d ) Source code \u00b6 #pragma once #include \"cinterop/c_cpp_interop.hpp\" #include \"datatypes/common.h\" #include \"datatypes/time_series_io.hpp\" #include \"datatypes/internals_c_api.hpp\" using namespace cinterop :: utils ; using namespace datatypes :: timeseries ; DATATYPES_DLL_LIB TimeSeries CreateTimeSeries ( double * values , const regular_time_series_geometry & g ); DATATYPES_DLL_LIB TimeSeries CreateTimeSeries ( double * values , TS_GEOMETRY_PTR geom ); DATATYPES_DLL_LIB TimeSeries CreateTimeSeries ( const multi_regular_time_series_data & g ); DATATYPES_DLL_LIB TimeSeriesEnsemble < TimeSeries > ToTimeSeriesEnsemble ( const multi_regular_time_series_data & rawData ); DATATYPES_DLL_LIB TimeSeriesEnsemble < TimeSeries >* ToTimeSeriesEnsemblePtr ( const multi_regular_time_series_data & rawData ); DATATYPES_DLL_LIB multi_regular_time_series_data * ToMultiTimeSeriesDataPtr ( const TimeSeriesEnsemble < TimeSeries >& mts ); DATATYPES_DLL_LIB multi_regular_time_series_data * ToMultiTimeSeriesDataPtr ( const TimeSeries & ts ); DATATYPES_DLL_LIB TimeSeries * SingleTsPtrFromMultiTimeSeriesData ( const multi_regular_time_series_data & ts ); DATATYPES_DLL_LIB TimeSeriesEnsemble < TimeSeries >* MultiTsPtrFromMultiTimeSeriesData ( const multi_regular_time_series_data & ts ); DATATYPES_DLL_LIB TimeSeries SingleTsFromMultiTimeSeriesData ( const multi_regular_time_series_data & ts ); DATATYPES_DLL_LIB TimeSeriesEnsemble < TimeSeries > MultiTsFromMultiTimeSeriesData ( const multi_regular_time_series_data & ts ); DATATYPES_DLL_LIB time_series_dimensions_description * ToTimeSeriesDimensionDescriptions ( vector < DataDimensionDescriptor >& mts ); DATATYPES_DLL_LIB void CopyToMultiTimeSeriesData ( const TimeSeriesEnsemble < TimeSeries >& mts , multi_regular_time_series_data & result ); DATATYPES_DLL_LIB void CopyToMultiTimeSeriesData ( const TimeSeries & ts , multi_regular_time_series_data & result ); DATATYPES_DLL_LIB void CopyFromMultiTimeSeriesData ( const multi_regular_time_series_data & interopdata , TimeSeries & ts ); DATATYPES_DLL_LIB void CopyFromMultiTimeSeriesData ( const multi_regular_time_series_data & interopdata , TimeSeriesEnsemble < TimeSeries >& mts ); DATATYPES_DLL_LIB double ** ToRawData ( const TimeSeriesEnsemble < TimeSeries >& mts ); DATATYPES_DLL_LIB double * ToRawData ( const TimeSeries & ts ); DATATYPES_DLL_LIB void DisposeMultiTimeSeriesData ( multi_regular_time_series_data * d ); DATATYPES_DLL_LIB void DisposeTimeSeriesDimensionDescriptions ( time_series_dimensions_description * d ); Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes/interop_conversions.h"},{"location":"cpp/Files/interop__conversions_8h/#datatypesinterop_conversionsh","text":"","title":"datatypes/interop_conversions.h"},{"location":"cpp/Files/interop__conversions_8h/#namespaces","text":"Name cinterop::utils","title":"Namespaces"},{"location":"cpp/Files/interop__conversions_8h/#functions","text":"Name DATATYPES_DLL_LIB TimeSeries CreateTimeSeries (double * values, const regular_time_series_geometry & g) DATATYPES_DLL_LIB TimeSeries CreateTimeSeries (double * values, TS_GEOMETRY_PTR geom) DATATYPES_DLL_LIB TimeSeries CreateTimeSeries (const multi_regular_time_series_data & g) DATATYPES_DLL_LIB TimeSeriesEnsemble < TimeSeries > ToTimeSeriesEnsemble (const multi_regular_time_series_data & rawData) DATATYPES_DLL_LIB TimeSeriesEnsemble < TimeSeries > * ToTimeSeriesEnsemblePtr (const multi_regular_time_series_data & rawData) DATATYPES_DLL_LIB multi_regular_time_series_data * ToMultiTimeSeriesDataPtr (const TimeSeriesEnsemble < TimeSeries > & mts) DATATYPES_DLL_LIB multi_regular_time_series_data * ToMultiTimeSeriesDataPtr (const TimeSeries & ts) DATATYPES_DLL_LIB TimeSeries * SingleTsPtrFromMultiTimeSeriesData (const multi_regular_time_series_data & ts) DATATYPES_DLL_LIB TimeSeriesEnsemble < TimeSeries > * MultiTsPtrFromMultiTimeSeriesData (const multi_regular_time_series_data & ts) DATATYPES_DLL_LIB TimeSeries SingleTsFromMultiTimeSeriesData (const multi_regular_time_series_data & ts) DATATYPES_DLL_LIB TimeSeriesEnsemble < TimeSeries > MultiTsFromMultiTimeSeriesData (const multi_regular_time_series_data & ts) DATATYPES_DLL_LIB time_series_dimensions_description * ToTimeSeriesDimensionDescriptions (vector< DataDimensionDescriptor > & mts) DATATYPES_DLL_LIB void CopyToMultiTimeSeriesData (const TimeSeriesEnsemble < TimeSeries > & mts, multi_regular_time_series_data & result) DATATYPES_DLL_LIB void CopyToMultiTimeSeriesData (const TimeSeries & ts, multi_regular_time_series_data & result) DATATYPES_DLL_LIB void CopyFromMultiTimeSeriesData (const multi_regular_time_series_data & interopdata, TimeSeries & ts) DATATYPES_DLL_LIB void CopyFromMultiTimeSeriesData (const multi_regular_time_series_data & interopdata, TimeSeriesEnsemble < TimeSeries > & mts) DATATYPES_DLL_LIB double ** ToRawData (const TimeSeriesEnsemble < TimeSeries > & mts) DATATYPES_DLL_LIB double * ToRawData (const TimeSeries & ts) DATATYPES_DLL_LIB void DisposeMultiTimeSeriesData (multi_regular_time_series_data * d) DATATYPES_DLL_LIB void DisposeTimeSeriesDimensionDescriptions (time_series_dimensions_description * d)","title":"Functions"},{"location":"cpp/Files/interop__conversions_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"cpp/Files/interop__conversions_8h/#function-createtimeseries","text":"DATATYPES_DLL_LIBTimeSeries CreateTimeSeries ( double * values , const regular_time_series_geometry & g )","title":"function CreateTimeSeries"},{"location":"cpp/Files/interop__conversions_8h/#function-createtimeseries_1","text":"DATATYPES_DLL_LIBTimeSeries CreateTimeSeries ( double * values , TS_GEOMETRY_PTR geom )","title":"function CreateTimeSeries"},{"location":"cpp/Files/interop__conversions_8h/#function-createtimeseries_2","text":"DATATYPES_DLL_LIBTimeSeries CreateTimeSeries ( const multi_regular_time_series_data & g )","title":"function CreateTimeSeries"},{"location":"cpp/Files/interop__conversions_8h/#function-totimeseriesensemble","text":"DATATYPES_DLL_LIBTimeSeriesEnsemble < TimeSeries > ToTimeSeriesEnsemble ( const multi_regular_time_series_data & rawData )","title":"function ToTimeSeriesEnsemble"},{"location":"cpp/Files/interop__conversions_8h/#function-totimeseriesensembleptr","text":"DATATYPES_DLL_LIBTimeSeriesEnsemble < TimeSeries > * ToTimeSeriesEnsemblePtr ( const multi_regular_time_series_data & rawData )","title":"function ToTimeSeriesEnsemblePtr"},{"location":"cpp/Files/interop__conversions_8h/#function-tomultitimeseriesdataptr","text":"DATATYPES_DLL_LIB multi_regular_time_series_data * ToMultiTimeSeriesDataPtr ( const TimeSeriesEnsemble < TimeSeries > & mts )","title":"function ToMultiTimeSeriesDataPtr"},{"location":"cpp/Files/interop__conversions_8h/#function-tomultitimeseriesdataptr_1","text":"DATATYPES_DLL_LIB multi_regular_time_series_data * ToMultiTimeSeriesDataPtr ( const TimeSeries & ts )","title":"function ToMultiTimeSeriesDataPtr"},{"location":"cpp/Files/interop__conversions_8h/#function-singletsptrfrommultitimeseriesdata","text":"DATATYPES_DLL_LIBTimeSeries * SingleTsPtrFromMultiTimeSeriesData ( const multi_regular_time_series_data & ts )","title":"function SingleTsPtrFromMultiTimeSeriesData"},{"location":"cpp/Files/interop__conversions_8h/#function-multitsptrfrommultitimeseriesdata","text":"DATATYPES_DLL_LIBTimeSeriesEnsemble < TimeSeries > * MultiTsPtrFromMultiTimeSeriesData ( const multi_regular_time_series_data & ts )","title":"function MultiTsPtrFromMultiTimeSeriesData"},{"location":"cpp/Files/interop__conversions_8h/#function-singletsfrommultitimeseriesdata","text":"DATATYPES_DLL_LIBTimeSeries SingleTsFromMultiTimeSeriesData ( const multi_regular_time_series_data & ts )","title":"function SingleTsFromMultiTimeSeriesData"},{"location":"cpp/Files/interop__conversions_8h/#function-multitsfrommultitimeseriesdata","text":"DATATYPES_DLL_LIBTimeSeriesEnsemble < TimeSeries > MultiTsFromMultiTimeSeriesData ( const multi_regular_time_series_data & ts )","title":"function MultiTsFromMultiTimeSeriesData"},{"location":"cpp/Files/interop__conversions_8h/#function-totimeseriesdimensiondescriptions","text":"DATATYPES_DLL_LIB time_series_dimensions_description * ToTimeSeriesDimensionDescriptions ( vector < DataDimensionDescriptor > & mts )","title":"function ToTimeSeriesDimensionDescriptions"},{"location":"cpp/Files/interop__conversions_8h/#function-copytomultitimeseriesdata","text":"DATATYPES_DLL_LIB void CopyToMultiTimeSeriesData ( const TimeSeriesEnsemble < TimeSeries > & mts , multi_regular_time_series_data & result )","title":"function CopyToMultiTimeSeriesData"},{"location":"cpp/Files/interop__conversions_8h/#function-copytomultitimeseriesdata_1","text":"DATATYPES_DLL_LIB void CopyToMultiTimeSeriesData ( const TimeSeries & ts , multi_regular_time_series_data & result )","title":"function CopyToMultiTimeSeriesData"},{"location":"cpp/Files/interop__conversions_8h/#function-copyfrommultitimeseriesdata","text":"DATATYPES_DLL_LIB void CopyFromMultiTimeSeriesData ( const multi_regular_time_series_data & interopdata , TimeSeries & ts )","title":"function CopyFromMultiTimeSeriesData"},{"location":"cpp/Files/interop__conversions_8h/#function-copyfrommultitimeseriesdata_1","text":"DATATYPES_DLL_LIB void CopyFromMultiTimeSeriesData ( const multi_regular_time_series_data & interopdata , TimeSeriesEnsemble < TimeSeries > & mts )","title":"function CopyFromMultiTimeSeriesData"},{"location":"cpp/Files/interop__conversions_8h/#function-torawdata","text":"DATATYPES_DLL_LIB double ** ToRawData ( const TimeSeriesEnsemble < TimeSeries > & mts )","title":"function ToRawData"},{"location":"cpp/Files/interop__conversions_8h/#function-torawdata_1","text":"DATATYPES_DLL_LIB double * ToRawData ( const TimeSeries & ts )","title":"function ToRawData"},{"location":"cpp/Files/interop__conversions_8h/#function-disposemultitimeseriesdata","text":"DATATYPES_DLL_LIB void DisposeMultiTimeSeriesData ( multi_regular_time_series_data * d )","title":"function DisposeMultiTimeSeriesData"},{"location":"cpp/Files/interop__conversions_8h/#function-disposetimeseriesdimensiondescriptions","text":"DATATYPES_DLL_LIB void DisposeTimeSeriesDimensionDescriptions ( time_series_dimensions_description * d )","title":"function DisposeTimeSeriesDimensionDescriptions"},{"location":"cpp/Files/interop__conversions_8h/#source-code","text":"#pragma once #include \"cinterop/c_cpp_interop.hpp\" #include \"datatypes/common.h\" #include \"datatypes/time_series_io.hpp\" #include \"datatypes/internals_c_api.hpp\" using namespace cinterop :: utils ; using namespace datatypes :: timeseries ; DATATYPES_DLL_LIB TimeSeries CreateTimeSeries ( double * values , const regular_time_series_geometry & g ); DATATYPES_DLL_LIB TimeSeries CreateTimeSeries ( double * values , TS_GEOMETRY_PTR geom ); DATATYPES_DLL_LIB TimeSeries CreateTimeSeries ( const multi_regular_time_series_data & g ); DATATYPES_DLL_LIB TimeSeriesEnsemble < TimeSeries > ToTimeSeriesEnsemble ( const multi_regular_time_series_data & rawData ); DATATYPES_DLL_LIB TimeSeriesEnsemble < TimeSeries >* ToTimeSeriesEnsemblePtr ( const multi_regular_time_series_data & rawData ); DATATYPES_DLL_LIB multi_regular_time_series_data * ToMultiTimeSeriesDataPtr ( const TimeSeriesEnsemble < TimeSeries >& mts ); DATATYPES_DLL_LIB multi_regular_time_series_data * ToMultiTimeSeriesDataPtr ( const TimeSeries & ts ); DATATYPES_DLL_LIB TimeSeries * SingleTsPtrFromMultiTimeSeriesData ( const multi_regular_time_series_data & ts ); DATATYPES_DLL_LIB TimeSeriesEnsemble < TimeSeries >* MultiTsPtrFromMultiTimeSeriesData ( const multi_regular_time_series_data & ts ); DATATYPES_DLL_LIB TimeSeries SingleTsFromMultiTimeSeriesData ( const multi_regular_time_series_data & ts ); DATATYPES_DLL_LIB TimeSeriesEnsemble < TimeSeries > MultiTsFromMultiTimeSeriesData ( const multi_regular_time_series_data & ts ); DATATYPES_DLL_LIB time_series_dimensions_description * ToTimeSeriesDimensionDescriptions ( vector < DataDimensionDescriptor >& mts ); DATATYPES_DLL_LIB void CopyToMultiTimeSeriesData ( const TimeSeriesEnsemble < TimeSeries >& mts , multi_regular_time_series_data & result ); DATATYPES_DLL_LIB void CopyToMultiTimeSeriesData ( const TimeSeries & ts , multi_regular_time_series_data & result ); DATATYPES_DLL_LIB void CopyFromMultiTimeSeriesData ( const multi_regular_time_series_data & interopdata , TimeSeries & ts ); DATATYPES_DLL_LIB void CopyFromMultiTimeSeriesData ( const multi_regular_time_series_data & interopdata , TimeSeriesEnsemble < TimeSeries >& mts ); DATATYPES_DLL_LIB double ** ToRawData ( const TimeSeriesEnsemble < TimeSeries >& mts ); DATATYPES_DLL_LIB double * ToRawData ( const TimeSeries & ts ); DATATYPES_DLL_LIB void DisposeMultiTimeSeriesData ( multi_regular_time_series_data * d ); DATATYPES_DLL_LIB void DisposeTimeSeriesDimensionDescriptions ( time_series_dimensions_description * d ); Updated on 2022-08-20 at 19:28:22 +1000","title":"Source code"},{"location":"cpp/Files/interop__conversions_8hpp/","text":"datatypes/interop_conversions.hpp \u00b6 Namespaces \u00b6 Name cinterop cinterop::timeseries cinterop::statistics Functions \u00b6 Name template <typename Tts > void ToTimeSeriesGeomStruct (const Tts & ts, regular_time_series_geometry & g) template <typename Tts > regular_time_series_geometry ToTimeSeriesGeomStruct (const Tts & ts) Functions Documentation \u00b6 function ToTimeSeriesGeomStruct \u00b6 template < typename Tts > static void ToTimeSeriesGeomStruct ( const Tts & ts , regular_time_series_geometry & g ) function ToTimeSeriesGeomStruct \u00b6 template < typename Tts > static regular_time_series_geometry ToTimeSeriesGeomStruct ( const Tts & ts ) Source code \u00b6 #pragma once #include \"cinterop/c_cpp_interop.hpp\" #include \"datatypes/common.h\" #include \"datatypes/time_series_io.hpp\" #include \"datatypes/interop_conversions.h\" #include \"cinterop/timeseries_interop.hpp\" using namespace cinterop :: utils ; using namespace datatypes :: timeseries ; template < typename Tts > static void ToTimeSeriesGeomStruct ( const Tts & ts , regular_time_series_geometry & g ) { g . length = static_cast < int > ( ts . GetLength ()); ptime startpt = ts . GetStartDate (); TimeStep tstep = ts . GetTimeStep (); TimeStep m ( new MonthlyQppTimeStepImplementation ()); if ( tstep == m ) { g . time_step_code = time_step_code :: monthly_step ; g . time_step_seconds = -1 ; } else { g . time_step_code = time_step_code :: strictly_regular ; g . time_step_seconds = tstep . GetTimeStepDuration ( startpt ). total_seconds (); } to_date_time_to_second ( startpt , g . start ); } template < typename Tts > static regular_time_series_geometry ToTimeSeriesGeomStruct ( const Tts & ts ) { regular_time_series_geometry g ; ToTimeSeriesGeomStruct ( ts , g ); return g ; } namespace cinterop { namespace timeseries { template <> inline multi_regular_time_series_data * to_multi_regular_time_series_data_ptr < TimeSeries > ( const TimeSeries & ts ) { return ToMultiTimeSeriesDataPtr ( ts ); } } namespace statistics { template <> inline statistic_definition * to_statistic_definition_ptr < TimeSeries > ( const std :: string & model_variable_id , const std :: string & statistic_identifier , const std :: string & objective_identifier , const std :: string & objective_name , const date_time_to_second & start , const date_time_to_second & end , const TimeSeries & time_series_data ) // Tried to have a default implementation and relying on finding an implementation for to_multi_regular_time_series_data_ptr<From> but had issues getting this working. { using namespace cinterop :: timeseries ; statistic_definition * stat = new statistic_definition (); stat -> statistic_identifier = STRDUP ( statistic_identifier . c_str ()); stat -> start = start ; stat -> end = end ; stat -> model_variable_id = STRDUP ( model_variable_id . c_str ()); stat -> objective_identifier = STRDUP ( objective_identifier . c_str ()); stat -> objective_name = STRDUP ( objective_name . c_str ()); stat -> observations = to_multi_regular_time_series_data_ptr < TimeSeries > ( time_series_data ); return stat ; } } } Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes/interop_conversions.hpp"},{"location":"cpp/Files/interop__conversions_8hpp/#datatypesinterop_conversionshpp","text":"","title":"datatypes/interop_conversions.hpp"},{"location":"cpp/Files/interop__conversions_8hpp/#namespaces","text":"Name cinterop cinterop::timeseries cinterop::statistics","title":"Namespaces"},{"location":"cpp/Files/interop__conversions_8hpp/#functions","text":"Name template <typename Tts > void ToTimeSeriesGeomStruct (const Tts & ts, regular_time_series_geometry & g) template <typename Tts > regular_time_series_geometry ToTimeSeriesGeomStruct (const Tts & ts)","title":"Functions"},{"location":"cpp/Files/interop__conversions_8hpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"cpp/Files/interop__conversions_8hpp/#function-totimeseriesgeomstruct","text":"template < typename Tts > static void ToTimeSeriesGeomStruct ( const Tts & ts , regular_time_series_geometry & g )","title":"function ToTimeSeriesGeomStruct"},{"location":"cpp/Files/interop__conversions_8hpp/#function-totimeseriesgeomstruct_1","text":"template < typename Tts > static regular_time_series_geometry ToTimeSeriesGeomStruct ( const Tts & ts )","title":"function ToTimeSeriesGeomStruct"},{"location":"cpp/Files/interop__conversions_8hpp/#source-code","text":"#pragma once #include \"cinterop/c_cpp_interop.hpp\" #include \"datatypes/common.h\" #include \"datatypes/time_series_io.hpp\" #include \"datatypes/interop_conversions.h\" #include \"cinterop/timeseries_interop.hpp\" using namespace cinterop :: utils ; using namespace datatypes :: timeseries ; template < typename Tts > static void ToTimeSeriesGeomStruct ( const Tts & ts , regular_time_series_geometry & g ) { g . length = static_cast < int > ( ts . GetLength ()); ptime startpt = ts . GetStartDate (); TimeStep tstep = ts . GetTimeStep (); TimeStep m ( new MonthlyQppTimeStepImplementation ()); if ( tstep == m ) { g . time_step_code = time_step_code :: monthly_step ; g . time_step_seconds = -1 ; } else { g . time_step_code = time_step_code :: strictly_regular ; g . time_step_seconds = tstep . GetTimeStepDuration ( startpt ). total_seconds (); } to_date_time_to_second ( startpt , g . start ); } template < typename Tts > static regular_time_series_geometry ToTimeSeriesGeomStruct ( const Tts & ts ) { regular_time_series_geometry g ; ToTimeSeriesGeomStruct ( ts , g ); return g ; } namespace cinterop { namespace timeseries { template <> inline multi_regular_time_series_data * to_multi_regular_time_series_data_ptr < TimeSeries > ( const TimeSeries & ts ) { return ToMultiTimeSeriesDataPtr ( ts ); } } namespace statistics { template <> inline statistic_definition * to_statistic_definition_ptr < TimeSeries > ( const std :: string & model_variable_id , const std :: string & statistic_identifier , const std :: string & objective_identifier , const std :: string & objective_name , const date_time_to_second & start , const date_time_to_second & end , const TimeSeries & time_series_data ) // Tried to have a default implementation and relying on finding an implementation for to_multi_regular_time_series_data_ptr<From> but had issues getting this working. { using namespace cinterop :: timeseries ; statistic_definition * stat = new statistic_definition (); stat -> statistic_identifier = STRDUP ( statistic_identifier . c_str ()); stat -> start = start ; stat -> end = end ; stat -> model_variable_id = STRDUP ( model_variable_id . c_str ()); stat -> objective_identifier = STRDUP ( objective_identifier . c_str ()); stat -> objective_name = STRDUP ( objective_name . c_str ()); stat -> observations = to_multi_regular_time_series_data_ptr < TimeSeries > ( time_series_data ); return stat ; } } } Updated on 2022-08-20 at 19:28:22 +1000","title":"Source code"},{"location":"cpp/Files/interop__struct_8h/","text":"datatypes/interop_struct.h \u00b6 Source code \u00b6 #pragma once #include \"datatypes/setup_exports.h\" #include \"cinterop/timeseries_c_interop.h\" Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes/interop_struct.h"},{"location":"cpp/Files/interop__struct_8h/#datatypesinterop_structh","text":"","title":"datatypes/interop_struct.h"},{"location":"cpp/Files/interop__struct_8h/#source-code","text":"#pragma once #include \"datatypes/setup_exports.h\" #include \"cinterop/timeseries_c_interop.h\" Updated on 2022-08-20 at 19:28:22 +1000","title":"Source code"},{"location":"cpp/Files/io__helper_8h/","text":"datatypes/io_helper.h \u00b6 Namespaces \u00b6 Name datatypes datatypes::io Classes \u00b6 Name class datatypes::io::IoHelper Source code \u00b6 #pragma once #include <string> #include <stdexcept> #include <boost/filesystem.hpp> #include \"common.h\" using std :: string ; namespace datatypes { namespace io { class DATATYPES_DLL_LIB IoHelper { public : static const string DefaultFilePattern ; static bool FileExists ( const boost :: filesystem :: path & p ); static bool PathExists ( const boost :: filesystem :: path & p ); static bool DirExists ( const boost :: filesystem :: path & p ); static string MakeFileName ( const string & fileNamePattern , const string & id , const string & pattern = \"{0}\" ); static bool IsFileNamePattern ( const string & s ); }; } } Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes/io_helper.h"},{"location":"cpp/Files/io__helper_8h/#datatypesio_helperh","text":"","title":"datatypes/io_helper.h"},{"location":"cpp/Files/io__helper_8h/#namespaces","text":"Name datatypes datatypes::io","title":"Namespaces"},{"location":"cpp/Files/io__helper_8h/#classes","text":"Name class datatypes::io::IoHelper","title":"Classes"},{"location":"cpp/Files/io__helper_8h/#source-code","text":"#pragma once #include <string> #include <stdexcept> #include <boost/filesystem.hpp> #include \"common.h\" using std :: string ; namespace datatypes { namespace io { class DATATYPES_DLL_LIB IoHelper { public : static const string DefaultFilePattern ; static bool FileExists ( const boost :: filesystem :: path & p ); static bool PathExists ( const boost :: filesystem :: path & p ); static bool DirExists ( const boost :: filesystem :: path & p ); static string MakeFileName ( const string & fileNamePattern , const string & id , const string & pattern = \"{0}\" ); static bool IsFileNamePattern ( const string & s ); }; } } Updated on 2022-08-20 at 19:28:22 +1000","title":"Source code"},{"location":"cpp/Files/setup__exports_8h/","text":"datatypes/setup_exports.h \u00b6 Defines \u00b6 Name USING_MOIRAI DATATYPES_DLL_LIB TEMPLATE_SPECIALIZATION_EXTERN Macros Documentation \u00b6 define USING_MOIRAI \u00b6 #define USING_MOIRAI define DATATYPES_DLL_LIB \u00b6 #define DATATYPES_DLL_LIB define TEMPLATE_SPECIALIZATION_EXTERN \u00b6 #define TEMPLATE_SPECIALIZATION_EXTERN Source code \u00b6 #pragma once #define USING_MOIRAI #include \"moirai/setup_modifiers.h\" // Defining the macro following guidelines in e.g. https://msdn.microsoft.com/en-us/library/8fskxacy.aspx // The declaration modifiers can be overriden by the user by defining DATATYPES_DLL_LIB_MODIFIERS #ifndef DATATYPES_DLL_LIB_MODIFIERS #ifdef _WIN32 #ifdef USING_DATATYPES #define DATATYPES_DLL_LIB __declspec(dllimport) #define TEMPLATE_SPECIALIZATION_EXTERN extern #else #define DATATYPES_DLL_LIB __declspec(dllexport) #define TEMPLATE_SPECIALIZATION_EXTERN // TO prevent warnings such as: // Warning C4251 'datatypes::io::IoHelper::DefaultFilePattern' : class 'std::basic_string<char,std::char_traits<char>,std::allocator<char>>' needs to have dll - interface to be used by clients of class 'datatypes::io::IoHelper' #pragma warning (disable : 4251) #endif #else #define DATATYPES_DLL_LIB // nothing #define TEMPLATE_SPECIALIZATION_EXTERN #endif // You can define the following to activate the Visual Leak Detector tool for visual C++ // https://vld.codeplex.com //#define DATATYPES_USE_VLD #ifdef DATATYPES_USE_VLD #include <vld.h> #endif #else // DATATYPES_DLL_LIB_MODIFIERS is defined #define DATATYPES_DLL_LIB DATATYPES_DLL_LIB_MODIFIERS #endif Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes/setup_exports.h"},{"location":"cpp/Files/setup__exports_8h/#datatypessetup_exportsh","text":"","title":"datatypes/setup_exports.h"},{"location":"cpp/Files/setup__exports_8h/#defines","text":"Name USING_MOIRAI DATATYPES_DLL_LIB TEMPLATE_SPECIALIZATION_EXTERN","title":"Defines"},{"location":"cpp/Files/setup__exports_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"cpp/Files/setup__exports_8h/#define-using_moirai","text":"#define USING_MOIRAI","title":"define USING_MOIRAI"},{"location":"cpp/Files/setup__exports_8h/#define-datatypes_dll_lib","text":"#define DATATYPES_DLL_LIB","title":"define DATATYPES_DLL_LIB"},{"location":"cpp/Files/setup__exports_8h/#define-template_specialization_extern","text":"#define TEMPLATE_SPECIALIZATION_EXTERN","title":"define TEMPLATE_SPECIALIZATION_EXTERN"},{"location":"cpp/Files/setup__exports_8h/#source-code","text":"#pragma once #define USING_MOIRAI #include \"moirai/setup_modifiers.h\" // Defining the macro following guidelines in e.g. https://msdn.microsoft.com/en-us/library/8fskxacy.aspx // The declaration modifiers can be overriden by the user by defining DATATYPES_DLL_LIB_MODIFIERS #ifndef DATATYPES_DLL_LIB_MODIFIERS #ifdef _WIN32 #ifdef USING_DATATYPES #define DATATYPES_DLL_LIB __declspec(dllimport) #define TEMPLATE_SPECIALIZATION_EXTERN extern #else #define DATATYPES_DLL_LIB __declspec(dllexport) #define TEMPLATE_SPECIALIZATION_EXTERN // TO prevent warnings such as: // Warning C4251 'datatypes::io::IoHelper::DefaultFilePattern' : class 'std::basic_string<char,std::char_traits<char>,std::allocator<char>>' needs to have dll - interface to be used by clients of class 'datatypes::io::IoHelper' #pragma warning (disable : 4251) #endif #else #define DATATYPES_DLL_LIB // nothing #define TEMPLATE_SPECIALIZATION_EXTERN #endif // You can define the following to activate the Visual Leak Detector tool for visual C++ // https://vld.codeplex.com //#define DATATYPES_USE_VLD #ifdef DATATYPES_USE_VLD #include <vld.h> #endif #else // DATATYPES_DLL_LIB_MODIFIERS is defined #define DATATYPES_DLL_LIB DATATYPES_DLL_LIB_MODIFIERS #endif Updated on 2022-08-20 at 19:28:22 +1000","title":"Source code"},{"location":"cpp/Files/shared__pointer__conversions_8hpp/","text":"datatypes/shared_pointer_conversions.hpp \u00b6 Namespaces \u00b6 Name moirai Classes \u00b6 Name struct moirai::known_conversions< TimeSeriesProvider< double > > Source code \u00b6 #pragma once #include \"datatypes/setup_exports.h\" #include \"moirai/reference_handle.hpp\" namespace moirai { template <> struct known_conversions < TimeSeriesProvider < double >> { static TimeSeriesProvider < double >* dyn_cast ( void * p , const typeinfo & tinfo ) { return as_type < TimeSeriesLibrary > ( p , tinfo ); } }; } Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes/shared_pointer_conversions.hpp"},{"location":"cpp/Files/shared__pointer__conversions_8hpp/#datatypesshared_pointer_conversionshpp","text":"","title":"datatypes/shared_pointer_conversions.hpp"},{"location":"cpp/Files/shared__pointer__conversions_8hpp/#namespaces","text":"Name moirai","title":"Namespaces"},{"location":"cpp/Files/shared__pointer__conversions_8hpp/#classes","text":"Name struct moirai::known_conversions< TimeSeriesProvider< double > >","title":"Classes"},{"location":"cpp/Files/shared__pointer__conversions_8hpp/#source-code","text":"#pragma once #include \"datatypes/setup_exports.h\" #include \"moirai/reference_handle.hpp\" namespace moirai { template <> struct known_conversions < TimeSeriesProvider < double >> { static TimeSeriesProvider < double >* dyn_cast ( void * p , const typeinfo & tinfo ) { return as_type < TimeSeriesLibrary > ( p , tinfo ); } }; } Updated on 2022-08-20 at 19:28:22 +1000","title":"Source code"},{"location":"cpp/Files/time__series_8hpp/","text":"datatypes/time_series.hpp \u00b6 Namespaces \u00b6 Name datatypes datatypes::timeseries datatypes::exceptions Classes \u00b6 Name struct datatypes::timeseries::DefaultMissingValuePolicyTypeFactory class datatypes::timeseries::TTimeSeries A template for univariate, single realisasion time series. class datatypes::timeseries::MultiTimeSeries Template for time series with multiple values at time point; e.g. to hold multiple realizations of time series in an ensemble. struct datatypes::timeseries::time_series_of struct datatypes::timeseries::ensemble_of struct datatypes::timeseries::item_type_of struct datatypes::timeseries::CommonTypes Typical ensemble and time series data types derived from a fundamental data type for each data item. class datatypes::timeseries::TimeSeriesOperations class datatypes::timeseries::TimeWindow An object that represents a time window, defining subset/trim operations on time series. class datatypes::exceptions::TimeSeriesChecks Source code \u00b6 #pragma once #include <iterator> #include \"boost/date_time/posix_time/posix_time.hpp\" #include <boost/function.hpp> #include \"datatypes/common.h\" #include \"datatypes/time_step.h\" #include \"datatypes/time_series_strategies.hpp\" #include \"datatypes/exception_utilities.h\" #include \"cinterop/common_c_interop.h\" using namespace boost :: posix_time ; using namespace boost :: gregorian ; using namespace datatypes :: utils ; namespace datatypes { namespace timeseries { template < typename T > struct DefaultMissingValuePolicyTypeFactory { typedef typename IfThenElse < std :: is_pointer < T >:: value , NullPointerIsMissingPolicy < T > , DefaultMissingFloatingPointPolicy < T >>:: ResultT type ; }; template < typename T > MissingValuePolicy < T >* DefaultMissingValuePolicy () { using U = typename DefaultMissingValuePolicyTypeFactory < T >:: type ; return new U (); } /* template <typename T> std::enable_if_t<std::is_pointer<T>::value, MissingValuePolicy<T>*> DefaultMissingValuePolicy() { return new NullPointerIsMissingPolicy<T>(); } template <typename T> std::enable_if_t<!std::is_pointer<T>::value, MissingValuePolicy<T>*> DefaultMissingValuePolicy() { return new DefaultMissingFloatingPointPolicy<T>(); } */ template < typename T > StoragePolicy < T >* DefaultStoragePolicy () { return new StlVectorStorage < T > (); } template < typename T = double > class TTimeSeries { public : using ElementType = T ; private : StoragePolicy < T >* storage = nullptr ; MissingValuePolicy < T >* mvp = nullptr ; void CheckConstructorReadonly () { if ( this -> storage -> ReadOnly ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"The storage for this time series is marked as read-only; there may be inconsistencies\" ); } protected : inline T GetNACode () const { return this -> mvp -> GetMissingValue (); } public : inline bool IsMissingValue ( const T & value ) const { return this -> mvp -> IsMissingValue ( value ); } inline T GetMissingValue () const { return this -> mvp -> GetMissingValue (); } TTimeSeries ( StoragePolicy < T >* storage = nullptr , MissingValuePolicy < T >* mvp = nullptr ) { SetDefaults ( storage , mvp ); if ( ! this -> storage -> ReadOnly ()) Reset ( 0 , not_a_date_time ); instances ++ ; } TTimeSeries ( T default_value , size_t length , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly (), StoragePolicy < T >* storage = nullptr , MissingValuePolicy < T >* mvp = nullptr ) { SetDefaults ( storage , mvp ); CheckConstructorReadonly (); this -> storage -> SetTimeStep ( timeStep ); Reset ( length , startDate , default_value ); instances ++ ; } TTimeSeries ( size_t length , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly (), StoragePolicy < T >* storage = nullptr , MissingValuePolicy < T >* mvp = nullptr ) { SetDefaults ( storage , mvp ); CheckConstructorReadonly (); this -> storage -> SetTimeStep ( timeStep ); Reset ( length , startDate , this -> mvp -> GetMissingValue ()); instances ++ ; } TTimeSeries ( const vector < T >& values , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly (), StoragePolicy < T >* storage = nullptr , MissingValuePolicy < T >* mvp = nullptr ) { SetDefaults ( storage , mvp ); CheckConstructorReadonly (); this -> storage -> SetTimeStep ( timeStep ); Reset ( values , startDate ); instances ++ ; } TTimeSeries ( const T * values , size_t length , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly (), StoragePolicy < T >* storage = nullptr , MissingValuePolicy < T >* mvp = nullptr ) { SetDefaults ( storage , mvp ); CheckConstructorReadonly (); this -> storage -> SetTimeStep ( timeStep ); Reset ( length , startDate , values ); instances ++ ; } // This constructor is initially intended only as a convenience for testing purposes. TTimeSeries ( std :: function < T ( size_t ) >& valueGen , size_t length , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly (), StoragePolicy < T >* storage = nullptr , MissingValuePolicy < T >* mvp = nullptr ) { SetDefaults ( storage , mvp ); CheckConstructorReadonly (); this -> storage -> SetTimeStep ( timeStep ); vector < T > values ( length ); for ( size_t i = 0 ; i < length ; i ++ ) values [ i ] = valueGen ( i ); Reset ( values , startDate ); instances ++ ; } TTimeSeries ( const TTimeSeries < T >& src ) { // (Deep) Copy constructor. * this = src ; instances ++ ; } TTimeSeries ( const TTimeSeries < T >& src , StoragePolicy < T >* storage ) { // (Deep) Copy constructor. Tag = src . Tag ; mvp = src . mvp -> Clone (); this -> storage = ( storage == nullptr ) ? DefaultStoragePolicy < T > () : storage ; src . storage -> CopyTo ( * ( this -> storage )); instances ++ ; } TTimeSeries ( const TTimeSeries < T >* src ) { // (Deep) Copy constructor. * this = * src ; instances ++ ; } TTimeSeries ( TTimeSeries < T >&& src ) { // Move constructor. * this = std :: move ( src ); instances ++ ; } TTimeSeries < T >& operator = ( TTimeSeries < T >&& src ){ // Avoid self assignment if ( & src == this ){ return * this ; } std :: swap ( Tag , src . Tag ); std :: swap ( storage , src . storage ); std :: swap ( mvp , src . mvp ); return * this ; } TTimeSeries < T >& operator = ( const TTimeSeries < T >& src ) { if ( & src == this ){ return * this ; } DeepCopyFrom ( src ); return * this ; } virtual ~ TTimeSeries () { if ( storage != nullptr ) delete storage ; if ( mvp != nullptr ) delete mvp ; instances -- ; } T GetValueNoConst ( const size_t & index ) { if ( index < 0 || index >= GetLength ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowOutOfRange ( \"Trying to access a time series value with an index outside of its bounds\" ); return storage -> operator []( index ); } const T & GetValueConst ( const size_t & index ) const { if ( index < 0 || index >= GetLength ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowOutOfRange ( \"Trying to access a time series value with an index outside of its bounds\" ); return storage -> operator []( index ); } T GetValue ( const size_t & index ) { return GetValueNoConst ( index ); } const T & GetValue ( const size_t & index ) const { return GetValueConst ( index ); } T GetValueNoConst ( const ptime & instant ) { return GetValueNoConst ( IndexForTime ( instant )); } T GetValue ( const ptime & instant ) { return GetValueNoConst ( IndexForTime ( instant )); } const T & GetValue ( const ptime & instant ) const { const size_t index = IndexForTime ( instant ); return GetValue ( index ); } T GetLastValue () { size_t length = GetLength (); if ( length == 0 ) datatypes :: exceptions :: ExceptionUtilities :: ThrowOutOfRange ( \"TimeSeries::GetLastValue cannot be called on an empty time series\" ); size_t index = length - 1 ; return GetValue ( index ); } void CopyTo ( T * dest , size_t from = 0 , size_t to = -1 ) const { CheckIntervalBounds ( from , to ); UncheckedCopyTo ( dest , from , to ); } void CopyWithMissingValueTo ( T * dest , const T & missingValueValue , size_t from = 0 , size_t to = -1 ) const { CheckIntervalBounds ( from , to ); UncheckedCopyTo ( dest , from , to , missingValueValue ); } void CopyValues ( const TTimeSeries < T >& src ) { if ( GetTimeStep () != src . GetTimeStep ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"time series copy values is only for identical time steps\" ); size_t from = IndexForTime ( src . GetStartDate ()); size_t to = IndexForTime ( src . GetEndDate ()); CheckIntervalBounds ( from , to ); for ( size_t i = from ; i <= to ; i ++ ) { T val = src . GetValue ( i - from ); this -> SetValue ( i , ( src . IsMissingValue ( val ) ? GetMissingValue () : val )); } } void CopyTo ( vector < T >& dest , size_t from = 0 , size_t to = -1 ) const { CheckIntervalBounds ( from , to ); storage -> CopyTo ( dest , from , to ); } T * GetValues ( size_t from = 0 , size_t to = std :: numeric_limits < size_t >:: max ()) const { CheckIntervalBounds ( from , to ); size_t len = ( to - from ) + 1 ; T * values = new T [ len ]; this -> UncheckedCopyTo ( values , from , to ); return values ; } vector < T > GetValuesVector ( size_t from = 0 , size_t to = std :: numeric_limits < size_t >:: max ()) const { CheckIntervalBounds ( from , to ); vector < T > values ; this -> CopyTo ( values , from , to ); return values ; } TTimeSeries < T > Subset ( size_t from = 0 , size_t to = std :: numeric_limits < size_t >:: max ()) const { CheckIntervalBounds ( from , to ); size_t len = ( to - from ) + 1 ; T * values = GetValues ( from , to ); // TODO: consider what to do with storage policy. MVP makes sense to keep the same. auto res = TTimeSeries < T > ( values , len , TimeForIndex ( from ), GetTimeStep (), nullptr , mvp -> Clone ()); delete [] values ; return res ; } void SetValue ( size_t index , T value ) { storage -> operator []( index ) = value ; } void SetValue ( const ptime & instant , T value ) { SetValue ( IndexForTime ( instant ), value ); } void Reset ( size_t length , const ptime & startDate , const TimeStep & timeStep ) { this -> storage -> SetStart ( startDate ); this -> storage -> SetTimeStep ( timeStep ); this -> storage -> Allocate ( length , mvp -> GetMissingValue ()); } void Reset ( size_t length , const ptime & startDate , const T * values = nullptr ) { if ( values == nullptr ) this -> storage -> Allocate ( length , mvp -> GetMissingValue ()); else this -> storage -> AllocateValues ( length , values ); this -> storage -> SetStart ( startDate ); } void Reset ( size_t length , const ptime & startDate , T value ) { this -> storage -> Allocate ( length , value ); this -> storage -> SetStart ( startDate ); } void Reset ( const vector < T >& values , const ptime & startDate ) { this -> storage -> AllocateValues ( values ); this -> storage -> SetStart ( startDate ); } void Reset ( const vector < T >& values , const ptime & startDate , const TimeStep & timeStep ) { this -> storage -> AllocateValues ( values ); this -> storage -> SetStart ( startDate ); this -> storage -> SetTimeStep ( timeStep ); } size_t GetLength () const { return storage -> Size (); } ptime GetStartDate () const { return storage -> GetStart (); } ptime GetEndDate () const { size_t n = GetLength (); if ( n == 0 ) return GetStartDate (); // what else? else return GetTimeStep (). AddSteps ( GetStartDate (), n -1 ); } TimeStep GetTimeStep () const { return storage -> GetTimeStep (); } void SetTimeStep ( const TimeStep & timeStep ) { this -> storage -> SetTimeStep ( timeStep ); } void SetStartDate ( const ptime & start ) { this -> storage -> SetStart ( start ); } ptime TimeForIndex ( size_t timeIndex ) const { return GetTimeStep (). AddSteps ( this -> GetStartDate (), timeIndex ); } vector < ptime > TimeIndices () const { auto tstep = GetTimeStep (); return tstep . AddSteps ( this -> GetStartDate (), SeqVec < double > ( 0 , 1 , GetLength ())); } size_t IndexForTime ( const ptime & instant ) const { return LowerIndexForTime ( instant ); } size_t UpperIndexForTime ( const ptime & instant ) const { auto uIndex = GetTimeStep (). GetUpperNumSteps ( GetStartDate (), instant ) - 1 ; datatypes :: exceptions :: ExceptionUtilities :: CheckInRange < ptrdiff_t > ( uIndex , 0 , GetLength () - 1 , \"UpperIndexForTime\" ); return ( size_t ) uIndex ; } size_t LowerIndexForTime ( const ptime & instant ) const { auto uIndex = GetTimeStep (). GetNumSteps ( GetStartDate (), instant ) - 1 ; datatypes :: exceptions :: ExceptionUtilities :: CheckInRange < ptrdiff_t > ( uIndex , 0 , GetLength () - 1 , \"LowerIndexForTime\" ); return ( size_t ) uIndex ; } string GetSummary () const { string result = \"[\" + to_iso_extended_string ( GetStartDate ()) + \"/\" + to_iso_extended_string ( GetEndDate ()) + \"];length=\" + std :: to_string ( GetLength ()) + \";time step=\" + GetTimeStep (). GetName (); return result ; } T & operator []( const ptime & instant ) { return storage -> operator []( IndexForTime ( instant )); } T & operator []( const size_t i ) { return storage -> operator []( i ); } const T & operator []( const ptime & instant ) const { return this -> operator []( IndexForTime ( instant )); } const T & operator []( const size_t i ) const { return storage -> operator []( i ); } TTimeSeries < T > operator + ( const TTimeSeries < T >& rhs ) const { // TODO check geometry compatibility T a , b ; T na = this -> mvp -> GetMissingValue (); size_t length = rhs . GetLength (); TTimeSeries < T > ts ( na , length , GetStartDate (), GetTimeStep (), nullptr , mvp -> Clone ()); //ts.naCode = this->naCode; for ( size_t i = 0 ; i < length ; i ++ ) { a = this -> operator []( i ); b = rhs . operator []( i ); if ( IsMissingValue ( a ) || rhs . IsMissingValue ( b )) ts . operator []( i ) = ts . GetNACode (); else ts . operator []( i ) = a + b ; } return ts ; } TTimeSeries < T > operator + ( T value ) const { T a ; T na = this -> mvp -> GetMissingValue (); size_t length = this -> GetLength (); TTimeSeries < T > ts ( na , length , GetStartDate (), GetTimeStep (), nullptr , mvp -> Clone ()); for ( size_t i = 0 ; i < length ; i ++ ) { a = this -> operator []( i ); if ( IsMissingValue ( a )) ts . operator []( i ) = ts . GetNACode (); else ts . operator []( i ) = a + value ; } return ts ; } template < typename M > TTimeSeries < T > operator * ( M multiplicator ) const { T a ; TTimeSeries < T > ts ( * this ); auto length = GetLength (); for ( size_t i = 0 ; i < length ; i ++ ) { a = this -> operator []( i ); if ( IsMissingValue ( a )) ts . operator []( i ) = ts . GetNACode (); else ts . operator []( i ) = a * multiplicator ; } return ts ; } string Tag ; private : void CheckIntervalBounds ( const size_t & from , size_t & to ) const { size_t tsLen = this -> GetLength (); datatypes :: exceptions :: RangeCheck < size_t >:: CheckTimeSeriesInterval ( from , to , tsLen ); } void UncheckedCopyTo ( T * dest , const size_t & from , const size_t & to ) const { // The following is neat and safe but not portable... //std::copy(data.begin() + from, data.begin() + to + 1, stdext::checked_array_iterator<T*>(dest, to - from + 1)); // so, looking potentially unsafe: for ( size_t i = from ; i <= to ; i ++ ) { dest [ i - from ] = storage -> operator []( i ); } } void UncheckedCopyTo ( T * dest , const size_t & from , const size_t & to , const T & missingValue ) const { for ( size_t i = from ; i <= to ; i ++ ) { T value = storage -> operator []( i ); dest [ i - from ] = IsMissingValue ( value ) ? missingValue : value ; } } void DeepCopyFrom ( const TTimeSeries < T >& src ) { Tag = src . Tag ; mvp = src . mvp -> Clone (); if ( storage == nullptr ) storage = src . storage -> Clone (); else src . storage -> CopyTo ( * ( this -> storage )); } //ptime startDate; //TimeStep timeStep; static std :: atomic < int > instances ; void SetDefaults ( StoragePolicy < T >* storage , MissingValuePolicy < T >* mvp ) { this -> mvp = ( mvp != nullptr ) ? mvp : DefaultMissingValuePolicy < T > (); this -> storage = ( storage != nullptr ) ? storage : DefaultStoragePolicy < T > (); if ( ! this -> storage -> ReadOnly ()) this -> SetTimeStep ( TimeStep :: GetHourly ()); } public : static int NumInstances () { return instances ; }; }; //template <typename T, template <typename> class StP, template <typename> class MvP> template < typename T > std :: atomic < int > TTimeSeries < T >:: instances ( 0 ); typedef TTimeSeries < double > TimeSeries ; template < typename TsType = TimeSeries > class MultiTimeSeries // This may become an abstract class with specializations for lazy loading time series from the data store. { private : EnsembleStoragePolicy < TsType >* store = nullptr ; protected : virtual void InitializeStorage () { if ( store == nullptr ) store = new StdVectorEnsembleStoragePolicy < TsType > (); } public : typedef typename std :: remove_pointer < TsType >:: type Type ; typedef typename std :: add_pointer < Type >:: type PtrType ; typedef TsType ItemType ; typedef typename Type :: ElementType ElementType ; MultiTimeSeries ( const vector < ElementType *>& values , size_t length , const ptime & startDate , const TimeStep & timeStep ) { Clear (); this -> startDate = startDate ; this -> timeStep = timeStep ; vector < PtrType > series ; for ( auto & d : values ) series . push_back ( new Type ( d , length , startDate , timeStep )); store -> Reset ( series , startDate , timeStep ); } MultiTimeSeries ( const vector < vector < ElementType >>& values , const ptime & startDate , const TimeStep & timeStep ) { Clear (); this -> startDate = startDate ; this -> timeStep = timeStep ; vector < PtrType > series ; for ( auto & d : values ) series . push_back ( new Type ( d , startDate , timeStep )); store -> Reset ( series , startDate , timeStep ); } MultiTimeSeries ( ElementType ** const values , size_t ensSize , size_t length , const ptime & startDate , const TimeStep & timeStep ) { Clear (); this -> startDate = startDate ; this -> timeStep = timeStep ; vector < PtrType > series ; for ( int i = 0 ; i < ensSize ; i ++ ) series . push_back ( new Type ( values [ i ], length , startDate , timeStep )); store -> Reset ( series , startDate , timeStep ); } MultiTimeSeries ( const vector < PtrType >& values , const ptime & startDate , const TimeStep & timeStep ) { Clear (); this -> startDate = startDate ; this -> timeStep = timeStep ; store -> Reset ( values , startDate , timeStep ); } MultiTimeSeries ( const Type & series ) { Clear (); this -> startDate = series . GetStartDate (); this -> timeStep = series . GetTimeStep (); vector < PtrType > s ; s . push_back ( new Type ( series )); store -> Reset ( s , startDate , timeStep ); } MultiTimeSeries ( const vector < Type >& values , const ptime & startDate , const TimeStep & timeStep ) { Clear (); this -> startDate = startDate ; this -> timeStep = timeStep ; vector < PtrType > series ; for ( const Type & d : values ) series . push_back ( new Type ( d )); store -> Reset ( series , startDate , timeStep ); } // This constructor is initially intended only as a convenience for testing purposes. MultiTimeSeries ( std :: function < Type ( size_t ) >& valueGen , size_t ensSize , const ptime & startDate , const TimeStep & timeStep ) { Clear (); this -> startDate = startDate ; this -> timeStep = timeStep ; vector < PtrType > series ; for ( size_t i = 0 ; i < ensSize ; i ++ ) series . push_back ( new Type ( valueGen ( i ))); store -> Reset ( series , startDate , timeStep ); } MultiTimeSeries ( const MultiTimeSeries < TsType >& src ) { * this = src ; } MultiTimeSeries ( EnsembleStoragePolicy < TsType >* store ) { if ( store == nullptr ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"store must not be nullptr\" ); this -> store = store ; } MultiTimeSeries () { this -> startDate = ptime ( not_a_date_time ); this -> timeStep = TimeStep :: GetHourly (); } MultiTimeSeries < PtrType >* AsPointerSeries () { return new MultiTimeSeries < PtrType > ( store -> AsReadonlyVector (), startDate , timeStep ); } MultiTimeSeries < Type > AsValueSeries () { return MultiTimeSeries < Type > ( store -> AsReadonlyVector (), startDate , timeStep ); } ~ MultiTimeSeries () { Clear (); } MultiTimeSeries & operator = ( const MultiTimeSeries & src ) { if ( & src == this ) { return * this ; } OperatorEqualImpl ( src ); return * this ; } MultiTimeSeries & operator = ( MultiTimeSeries && src ) { if ( & src == this ) { return * this ; } std :: swap ( timeStep , src . timeStep ); std :: swap ( startDate , src . startDate ); std :: swap ( store , src . store ); return * this ; } void ResetSeries ( const size_t & numSeries , const size_t & lengthSeries , const ptime & startDate , const TimeStep & timeStep ) { Clear (); store -> ResetSeries ( numSeries , lengthSeries , startDate , timeStep ); this -> startDate = startDate ; this -> timeStep = timeStep ; } TsType Get ( size_t i ) { return store -> Get ( i ); } Type Get ( size_t i ) const { return store -> Get ( i ); } ElementType Get ( size_t i , size_t tsIndex ) { return store -> Get ( i , tsIndex ); } void Set ( size_t i , size_t tsIndex , ElementType val ) { store -> Set ( i , tsIndex , val ); } void Set ( size_t i , const Type & val ) { store -> Set ( i , val ); } vector < ElementType *>* GetValues () const { return store -> GetValues (); } void CopyTo ( ElementType ** dest ) const { store -> CopyTo ( dest ); } size_t Size () const { return store -> Size (); } size_t GetLength ( size_t i ) const { return store -> GetLength ( i ); } ptime GetStartDate () const { return startDate ; } void SetStartDate ( const ptime & start ) { startDate = start ; } TimeStep GetTimeStep () const { return timeStep ; } void Clear () { if ( store == nullptr ) InitializeStorage (); else store -> Clear (); } private : ptime startDate ; TimeStep timeStep ; void DeepCopyFrom ( const MultiTimeSeries < TsType >& src ) { this -> startDate = src . startDate ; this -> timeStep = src . timeStep ; if ( store == nullptr ) store = src . store -> Clone (); else * ( src . store ) = ( * ( this -> store )); } protected : virtual void OperatorEqualImpl ( const MultiTimeSeries < TsType >& src ) { DeepCopyFrom ( src ); } }; template < typename T > struct time_series_of { typedef TTimeSeries < T > type ; }; template < typename T > struct ensemble_of { typedef MultiTimeSeries < T > type ; }; template < typename T > struct item_type_of { typedef typename T :: ElementType type ; }; template < typename ElementType = double > struct CommonTypes { using SeriesType = typename time_series_of < ElementType >:: type ; using PtrSeriesType = typename std :: add_pointer < SeriesType >:: type ; using EnsembleType = typename ensemble_of < SeriesType >:: type ; using EnsemblePtrType = typename ensemble_of < PtrSeriesType >:: type ; using PtrEnsemblePtrType = typename std :: add_pointer < EnsemblePtrType >:: type ; using TSeriesEnsemblePtrType = typename time_series_of < PtrEnsemblePtrType >:: type ; using PtrTSeriesEnsemblePtrType = typename std :: add_pointer < TSeriesEnsemblePtrType >:: type ; }; template < typename ItemType > using PointerTypeTimeSeries = TTimeSeries < ItemType * > ; template < typename Tts = TimeSeries > using MultiTimeSeriesPtr = MultiTimeSeries < Tts * > ; template < typename Tts = TimeSeries > using ForecastTimeSeries = PointerTypeTimeSeries < Tts > ; template < typename Tts = TimeSeries > using TimeSeriesEnsemble = MultiTimeSeriesPtr < Tts > ; template < typename Tts = TimeSeries > using EnsembleForecastTimeSeries = PointerTypeTimeSeries < MultiTimeSeriesPtr < Tts > > ; template < typename Tts = TimeSeries > class TimeSeriesOperations { public : using ElementType = typename Tts :: ElementType ; using SeriesType = typename CommonTypes < ElementType >:: SeriesType ; using PtrSeriesType = typename CommonTypes < ElementType >:: PtrSeriesType ; using EnsembleType = typename CommonTypes < ElementType >:: EnsembleType ; using EnsemblePtrType = typename CommonTypes < ElementType >:: EnsemblePtrType ; using PtrEnsemblePtrType = typename CommonTypes < ElementType >:: PtrEnsemblePtrType ; using TSeriesEnsemblePtrType = typename CommonTypes < ElementType >:: TSeriesEnsemblePtrType ; using PtrTSeriesEnsemblePtrType = typename CommonTypes < ElementType >:: PtrTSeriesEnsemblePtrType ; static PtrSeriesType TrimTimeSeries ( const SeriesType & timeSeries , const ptime & startDate , const ptime & endDate ) { ptime sd = timeSeries . GetStartDate (); ptime ed = timeSeries . GetEndDate (); size_t sIndex = timeSeries . UpperIndexForTime ( startDate ); size_t eIndex = timeSeries . LowerIndexForTime ( endDate ); return new SeriesType ( timeSeries . Subset ( sIndex , eIndex )); } static PtrSeriesType Resample ( const SeriesType & timeSeries , const string & method ) { using namespace boost :: algorithm ; string m = method ; to_lower ( m ); if ( m == \"\" ) return new TimeSeries ( timeSeries ); else if ( m == \"daily_to_hourly\" ) return DailyToHourly ( timeSeries ); else { datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"Time series resampling method not known: \" + method ); return nullptr ; } } static PtrSeriesType DailyToHourly ( const SeriesType & dailyTimeSeries ) { using T = typename SeriesType :: ElementType ; size_t length = dailyTimeSeries . GetLength (); T * data = new T [ length * 24 ]; for ( size_t i = 0 ; i < length ; i ++ ) for ( size_t j = 0 ; j < 24 ; j ++ ) data [( i * 24 ) + j ] = ( dailyTimeSeries [ i ] / 24 ); PtrSeriesType result = new SeriesType ( data , length * 24 , dailyTimeSeries . GetStartDate ()); delete [] data ; return result ; } static PtrSeriesType JoinTimeSeries ( const SeriesType & head , const SeriesType & tail ) { using T = typename SeriesType :: ElementType ; ptime startDate = head . GetStartDate (); size_t headLength = head . GetLength (); size_t tailLength = tail . GetLength (); size_t length = headLength + tailLength ; T * data = new T [ length ]; for ( size_t i = 0 ; i < length ; i ++ ) { if ( i < headLength ) data [ i ] = head [ i ]; else data [ i ] = tail [ i - headLength ]; } PtrSeriesType result = new SeriesType ( data , length , startDate ); delete [] data ; return result ; } static SeriesType AggregateTimeStep ( const SeriesType & series , const string & argument ) { using sec_type = boost :: posix_time :: time_duration :: sec_type ; auto newTimeStep = TimeStep :: Parse ( argument ); sec_type deltaNew = newTimeStep . GetRegularStepDuration (). total_seconds (); sec_type delta = series . GetTimeStep (). GetRegularStepDuration (). total_seconds (); if ( deltaNew < delta ) throw std :: logic_error ( \"Cannot aggregate to a target time step finer than data source\" ); sec_type remainder = deltaNew % delta ; if ( remainder != 0 ) throw std :: logic_error ( \"Aggregate: target time step must be a multiple of the starting time step\" ); sec_type multiple = deltaNew / delta ; size_t targetSize = series . GetLength () / multiple ; if ( targetSize < 1 ) throw std :: logic_error ( \"Aggregate: source lenght too short to aggregate\" ); SeriesType newTs ( 0.0 , targetSize , series . TimeForIndex ( multiple -1 ), newTimeStep ); for ( size_t i = 0 ; i < targetSize ; i ++ ) { double accumulated = 0 ; for ( size_t j = 0 ; j < multiple ; j ++ ) { auto val = series . GetValue ( i * multiple + j ); if ( series . IsMissingValue ( val )) { newTs . SetValue ( i , newTs . GetMissingValue ()); accumulated = .0 ; break ; } else accumulated += val ; } newTs . SetValue ( i , accumulated ); accumulated = .0 ; } return newTs ; } static SeriesType DisaggregateTimeStep ( const SeriesType & series , const string & argument ) { using sec_type = boost :: posix_time :: time_duration :: sec_type ; TimeStep newTimeStep = TimeStep :: Parse ( argument ); sec_type deltaNew = newTimeStep . GetRegularStepDuration (). total_seconds (); sec_type delta = series . GetTimeStep (). GetRegularStepDuration (). total_seconds (); if ( deltaNew > delta ) throw std :: logic_error ( \"Cannot disaggregate to a target time step coarser than data source\" ); sec_type remainder = delta % deltaNew ; if ( remainder != 0 ) throw std :: logic_error ( \"Disaggregate: the starting time step must be a multiple of the target time step\" ); sec_type multiple_sc = delta / deltaNew ; // NOTE: I had changed from sec_type to size_t because of a compilation issue with gcc 8.3.0 (??), but this breaks the UT on calling AddSteps size_t multiple = ( size_t ) multiple_sc ; size_t srcSize = series . GetLength (); size_t targetSize = series . GetLength () * multiple ; if ( targetSize < 1 ) throw std :: logic_error ( \"Disaggregate: source lengh is too short to aggregate\" ); ptime newStartDate = newTimeStep . AddSteps ( series . GetStartDate (), - ( (( double ) multiple ) - 1 )); SeriesType newTs ( 0.0 , targetSize , newStartDate , newTimeStep ); for ( size_t i = 0 ; i < srcSize ; i ++ ) { auto val = series . GetValue ( i ); for ( size_t j = 0 ; j < multiple ; j ++ ) { if ( series . IsMissingValue ( val )) newTs . SetValue ( i * multiple + j , newTs . GetMissingValue ()); else newTs . SetValue ( i * multiple + j , val / multiple ); } } return newTs ; } static void AggregateTimeStep ( SeriesType & series , const string & argument ) { series = AggregateTimeStep (( const SeriesType & ) series , argument ); } static void DisaggregateTimeStep ( SeriesType & series , const string & argument ) { series = DisaggregateTimeStep (( const SeriesType & ) series , argument ); } static void TransformEachItem ( TSeriesEnsemblePtrType & efts , const string & method , const string & methodArgument ) { if ( method == string ( \"accumulate\" )) { auto n = efts . GetLength (); for ( size_t i = 0 ; i < n ; i ++ ) { PtrEnsemblePtrType item = efts . GetValue ( i ); EnsemblePtrType & y = * item ; for ( size_t j = 0 ; j < y . Size (); j ++ ) { PtrSeriesType t = y . Get ( j ); AggregateTimeStep ( * t , methodArgument ); if ( j == 0 ) y . SetStartDate ( t -> GetStartDate ()); } } } else if ( method == string ( \"disaggregate\" )) { auto n = efts . GetLength (); for ( size_t i = 0 ; i < n ; i ++ ) { PtrEnsemblePtrType item = efts . GetValue ( i ); EnsemblePtrType & y = * item ; for ( size_t j = 0 ; j < y . Size (); j ++ ) { PtrSeriesType t = y . Get ( j ); DisaggregateTimeStep ( * t , methodArgument ); if ( j == 0 ) y . SetStartDate ( t -> GetStartDate ()); } } } else throw std :: logic_error ( \"TransformEachItem is limited to 'accumulate' or 'disaggregate'\" ); } private : static const PtrEnsemblePtrType & GetEnsemble ( const TSeriesEnsemblePtrType & ensTs , size_t index = 0 ) { using datatypes :: exceptions :: ExceptionUtilities ; if ( ensTs . GetLength () == 0 ) ExceptionUtilities :: ThrowInvalidArgument ( \"ensemble time series is of length zero\" ); ExceptionUtilities :: CheckInRange < size_t > ( index , 0 , ensTs . GetLength (), \"index\" ); const PtrEnsemblePtrType & ens = ensTs . GetValue ( index ); //if (ens->Size() == 0) ExceptionUtilities::ThrowInvalidArgument(\"ensemble is of size zero\"); return ens ; } public : static ptime GetStart ( const TSeriesEnsemblePtrType & ensTs , size_t index = 0 ) { auto ens = GetEnsemble ( ensTs , index ); return ens -> GetStartDate (); } static ptime GetEnd ( const TSeriesEnsemblePtrType & ensTs , size_t index = 0 ) { auto ens = GetEnsemble ( ensTs , index ); return ens -> Get ( 0 ) -> GetEndDate (); } static void CreateForecast ( TSeriesEnsemblePtrType & forecast , const SeriesType & observations , const ptime & start , size_t length , const TimeStep & issueTimeStep , size_t leadTime , size_t offsetForecasts ) { forecast . Reset ( length , start , issueTimeStep ); TimeStep obsTstep = observations . GetTimeStep (); for ( size_t i = 0 ; i < length ; i ++ ) { // Index in the observation time series corresponding to the forecast issue time 'i' size_t obsIndex = observations . IndexForTime ( issueTimeStep . AddSteps ( start , i )); size_t from = obsIndex + offsetForecasts ; size_t to = from + ( leadTime -1 ); SeriesType fcast = observations . Subset ( from , to ); EnsemblePtrType * mts = new EnsemblePtrType ( fcast ); forecast . SetValue ( i , mts ); } } static TSeriesEnsemblePtrType * CreateForecastPtr ( const SeriesType & observations , const ptime & start , size_t length , const TimeStep & issueTimeStep , size_t leadTime , size_t offsetForecasts ) { TSeriesEnsemblePtrType * forecast = new TSeriesEnsemblePtrType ( length , start , issueTimeStep ); CreateForecast ( * forecast , observations , start , length , issueTimeStep , leadTime , offsetForecasts ); return forecast ; } static TSeriesEnsemblePtrType CreateForecast ( const SeriesType & observations , const ptime & start , size_t length , const TimeStep & issueTimeStep , size_t leadTime , size_t offsetForecasts ) { TSeriesEnsemblePtrType forecast ; CreateForecast ( forecast , observations , start , length , issueTimeStep , leadTime , offsetForecasts ); return forecast ; } template < typename U > static bool AreEqual ( const SeriesType & a , const U & b , bool strict = false , double tolerance = 1e-12 ) { size_t lengthA = a . GetLength (); for ( size_t i = 0 ; i < lengthA ; i ++ ) { auto valA = a [ i ]; if ( strict && ( valA != b )) return false ; else if ( std :: abs ( valA - b ) > tolerance ) return false ; } return true ; } static bool AreTimeSeriesEqual ( const SeriesType & a , const SeriesType & b , bool strict = false , double tolerance = 1e-12 ) { ptime startA = a . GetStartDate (); ptime startB = b . GetStartDate (); if ( startA != startB ) return false ; ptime endA = a . GetEndDate (); ptime endB = b . GetEndDate (); if ( endA != endB ) return false ; size_t lengthA = a . GetLength (); size_t lengthB = b . GetLength (); if ( lengthA != lengthB ) return false ; for ( size_t i = 0 ; i < lengthA ; i ++ ) { auto valA = a [ i ]; auto valB = b [ i ]; if ( strict && ( valA != valB )) return false ; else if ( std :: abs ( valA - valB ) > tolerance ) return false ; } return true ; } static bool AreTimeSeriesEqual ( const SeriesType & a , const SeriesType & b , const ptime & from , const ptime & to , bool strict = false , double tolerance = 1e-12 ) { TimeStep ta = a . GetTimeStep (); TimeStep tb = b . GetTimeStep (); if ( ta != tb ) return false ; auto n = ta . GetNumSteps ( from , to ); if ( n < 0 ) return false ; size_t s = ( size_t ) n ; auto offsetA = a . IndexForTime ( from ); auto offsetB = b . IndexForTime ( from ); for ( size_t i = 0 ; i < s ; i ++ ) { auto valA = a [ i + offsetA ]; auto valB = b [ i + offsetB ]; if ( strict && ( valA != valB )) return false ; else if ( std :: abs ( valA - valB ) > tolerance ) return false ; } return true ; } static bool AreValueEqual ( const SeriesType & a , const vector < ElementType >& b , size_t from = 0 , size_t to = std :: numeric_limits < size_t >:: max (), bool strict = false , double tolerance = 1e-12 ) { vector < ElementType > v = a . GetValuesVector ( from , to ); if ( v . size () != b . size ()) return false ; for ( size_t i = 0 ; i < v . size (); i ++ ) { auto valA = v [ i ]; auto valB = b [ i ]; if ( strict && ( valA != valB )) return false ; else if ( std :: abs ( valA - valB ) > tolerance ) return false ; } return true ; } static bool AreEnsembleTimeSeriesEqual ( EnsemblePtrType & a , EnsemblePtrType & b ) { size_t lengthA = a . Size (); size_t lengthB = b . Size (); if ( lengthA != lengthB ) return false ; for ( size_t i = 0 ; i < lengthA ; i ++ ) { auto valA = a . Get ( i ); auto valB = b . Get ( i ); if ( ! AreTimeSeriesEqual ( * valA , * valB )) return false ; } return true ; } static bool AreEnsembleTimeSeriesEqual ( EnsembleType & a , EnsembleType & b ) { size_t lengthA = a . Size (); size_t lengthB = b . Size (); if ( lengthA != lengthB ) return false ; for ( size_t i = 0 ; i < lengthA ; i ++ ) { auto valA = a . Get ( i ); auto valB = b . Get ( i ); if ( ! AreTimeSeriesEqual ( valA , valB )) return false ; } return true ; } static bool AreTimeSeriesEnsembleTimeSeriesEqual ( TSeriesEnsemblePtrType & a , TSeriesEnsemblePtrType & b ) { size_t lengthA = a . GetLength (); size_t lengthB = b . GetLength (); if ( lengthA != lengthB ) return false ; ptime startA = a . GetStartDate (); ptime startB = b . GetStartDate (); if ( startA != startB ) return false ; for ( size_t i = 0 ; i < lengthA ; i ++ ) { auto valA = a . GetValue ( i ); auto valB = b . GetValue ( i ); if ( ! AreEnsembleTimeSeriesEqual ( * valA , * valB )) return false ; } return true ; } template < typename T = typename Tts :: ElementType > static PtrSeriesType MaskTimeSeries ( const SeriesType & timeSeries , const ptime & start , const ptime & end , T maskValue ) { if ( start < timeSeries . GetStartDate ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"start needs to be greater than time series start\" ); if ( end > timeSeries . GetEndDate ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"end needs to be less than time series end\" ); size_t sIndex = timeSeries . UpperIndexForTime ( start ); size_t eIndex = timeSeries . LowerIndexForTime ( end ); size_t len = timeSeries . GetLength (); double * d = new double [ len ]; timeSeries . CopyTo ( d , 0 , len - 1 ); for ( size_t i = sIndex ; i <= eIndex ; i ++ ) d [ i ] = maskValue ; PtrSeriesType result = new SeriesType ( d , len , timeSeries . GetStartDate (), timeSeries . GetTimeStep ()); delete [] d ; return result ; } }; template < typename T > TTimeSeries < T > operator << ( const TTimeSeries < T >& a , const TTimeSeries < T >& b ) { using TsOps = TimeSeriesOperations < TTimeSeries < T >> ; if ( a . GetTimeStep () != b . GetTimeStep ()) // TODO: this is a minimum requirement datatypes :: exceptions :: ExceptionUtilities :: ThrowNotSupported ( \"operator<< requires identical time steps\" ); auto s = std :: min ( a . GetStartDate (), b . GetStartDate ()); auto e = std :: max ( a . GetEndDate (), b . GetEndDate ()); auto tstep = a . GetTimeStep (); auto length = tstep . GetNumSteps ( s , e ); TTimeSeries < T > result ( length , s , tstep ); result . CopyValues ( a ); result . CopyValues ( b ); return result ; } template < typename Tts = TimeSeries > class TimeWindow { public : TimeWindow ( const ptime & startDate , const ptime & endDate ) { this -> startDate = startDate ; this -> endDate = endDate ; } Tts * Trim ( const Tts & timeSeries ) const { return TimeSeriesOperations < Tts >:: TrimTimeSeries ( timeSeries , startDate , endDate ); } private : ptime startDate ; ptime endDate ; }; /******************* Below are implementations of the template code; they would normally be found in a .cpp file, but as templates putting them here makes it more reusable from other programs. ******************/ } namespace exceptions { class DATATYPES_DLL_LIB TimeSeriesChecks { public : static void CheckOutOfRange ( const string & msg , const datatypes :: timeseries :: TimeSeries & ts , const ptime & d ); }; } } Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes/time_series.hpp"},{"location":"cpp/Files/time__series_8hpp/#datatypestime_serieshpp","text":"","title":"datatypes/time_series.hpp"},{"location":"cpp/Files/time__series_8hpp/#namespaces","text":"Name datatypes datatypes::timeseries datatypes::exceptions","title":"Namespaces"},{"location":"cpp/Files/time__series_8hpp/#classes","text":"Name struct datatypes::timeseries::DefaultMissingValuePolicyTypeFactory class datatypes::timeseries::TTimeSeries A template for univariate, single realisasion time series. class datatypes::timeseries::MultiTimeSeries Template for time series with multiple values at time point; e.g. to hold multiple realizations of time series in an ensemble. struct datatypes::timeseries::time_series_of struct datatypes::timeseries::ensemble_of struct datatypes::timeseries::item_type_of struct datatypes::timeseries::CommonTypes Typical ensemble and time series data types derived from a fundamental data type for each data item. class datatypes::timeseries::TimeSeriesOperations class datatypes::timeseries::TimeWindow An object that represents a time window, defining subset/trim operations on time series. class datatypes::exceptions::TimeSeriesChecks","title":"Classes"},{"location":"cpp/Files/time__series_8hpp/#source-code","text":"#pragma once #include <iterator> #include \"boost/date_time/posix_time/posix_time.hpp\" #include <boost/function.hpp> #include \"datatypes/common.h\" #include \"datatypes/time_step.h\" #include \"datatypes/time_series_strategies.hpp\" #include \"datatypes/exception_utilities.h\" #include \"cinterop/common_c_interop.h\" using namespace boost :: posix_time ; using namespace boost :: gregorian ; using namespace datatypes :: utils ; namespace datatypes { namespace timeseries { template < typename T > struct DefaultMissingValuePolicyTypeFactory { typedef typename IfThenElse < std :: is_pointer < T >:: value , NullPointerIsMissingPolicy < T > , DefaultMissingFloatingPointPolicy < T >>:: ResultT type ; }; template < typename T > MissingValuePolicy < T >* DefaultMissingValuePolicy () { using U = typename DefaultMissingValuePolicyTypeFactory < T >:: type ; return new U (); } /* template <typename T> std::enable_if_t<std::is_pointer<T>::value, MissingValuePolicy<T>*> DefaultMissingValuePolicy() { return new NullPointerIsMissingPolicy<T>(); } template <typename T> std::enable_if_t<!std::is_pointer<T>::value, MissingValuePolicy<T>*> DefaultMissingValuePolicy() { return new DefaultMissingFloatingPointPolicy<T>(); } */ template < typename T > StoragePolicy < T >* DefaultStoragePolicy () { return new StlVectorStorage < T > (); } template < typename T = double > class TTimeSeries { public : using ElementType = T ; private : StoragePolicy < T >* storage = nullptr ; MissingValuePolicy < T >* mvp = nullptr ; void CheckConstructorReadonly () { if ( this -> storage -> ReadOnly ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"The storage for this time series is marked as read-only; there may be inconsistencies\" ); } protected : inline T GetNACode () const { return this -> mvp -> GetMissingValue (); } public : inline bool IsMissingValue ( const T & value ) const { return this -> mvp -> IsMissingValue ( value ); } inline T GetMissingValue () const { return this -> mvp -> GetMissingValue (); } TTimeSeries ( StoragePolicy < T >* storage = nullptr , MissingValuePolicy < T >* mvp = nullptr ) { SetDefaults ( storage , mvp ); if ( ! this -> storage -> ReadOnly ()) Reset ( 0 , not_a_date_time ); instances ++ ; } TTimeSeries ( T default_value , size_t length , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly (), StoragePolicy < T >* storage = nullptr , MissingValuePolicy < T >* mvp = nullptr ) { SetDefaults ( storage , mvp ); CheckConstructorReadonly (); this -> storage -> SetTimeStep ( timeStep ); Reset ( length , startDate , default_value ); instances ++ ; } TTimeSeries ( size_t length , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly (), StoragePolicy < T >* storage = nullptr , MissingValuePolicy < T >* mvp = nullptr ) { SetDefaults ( storage , mvp ); CheckConstructorReadonly (); this -> storage -> SetTimeStep ( timeStep ); Reset ( length , startDate , this -> mvp -> GetMissingValue ()); instances ++ ; } TTimeSeries ( const vector < T >& values , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly (), StoragePolicy < T >* storage = nullptr , MissingValuePolicy < T >* mvp = nullptr ) { SetDefaults ( storage , mvp ); CheckConstructorReadonly (); this -> storage -> SetTimeStep ( timeStep ); Reset ( values , startDate ); instances ++ ; } TTimeSeries ( const T * values , size_t length , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly (), StoragePolicy < T >* storage = nullptr , MissingValuePolicy < T >* mvp = nullptr ) { SetDefaults ( storage , mvp ); CheckConstructorReadonly (); this -> storage -> SetTimeStep ( timeStep ); Reset ( length , startDate , values ); instances ++ ; } // This constructor is initially intended only as a convenience for testing purposes. TTimeSeries ( std :: function < T ( size_t ) >& valueGen , size_t length , const ptime & startDate , const TimeStep & timeStep = TimeStep :: GetHourly (), StoragePolicy < T >* storage = nullptr , MissingValuePolicy < T >* mvp = nullptr ) { SetDefaults ( storage , mvp ); CheckConstructorReadonly (); this -> storage -> SetTimeStep ( timeStep ); vector < T > values ( length ); for ( size_t i = 0 ; i < length ; i ++ ) values [ i ] = valueGen ( i ); Reset ( values , startDate ); instances ++ ; } TTimeSeries ( const TTimeSeries < T >& src ) { // (Deep) Copy constructor. * this = src ; instances ++ ; } TTimeSeries ( const TTimeSeries < T >& src , StoragePolicy < T >* storage ) { // (Deep) Copy constructor. Tag = src . Tag ; mvp = src . mvp -> Clone (); this -> storage = ( storage == nullptr ) ? DefaultStoragePolicy < T > () : storage ; src . storage -> CopyTo ( * ( this -> storage )); instances ++ ; } TTimeSeries ( const TTimeSeries < T >* src ) { // (Deep) Copy constructor. * this = * src ; instances ++ ; } TTimeSeries ( TTimeSeries < T >&& src ) { // Move constructor. * this = std :: move ( src ); instances ++ ; } TTimeSeries < T >& operator = ( TTimeSeries < T >&& src ){ // Avoid self assignment if ( & src == this ){ return * this ; } std :: swap ( Tag , src . Tag ); std :: swap ( storage , src . storage ); std :: swap ( mvp , src . mvp ); return * this ; } TTimeSeries < T >& operator = ( const TTimeSeries < T >& src ) { if ( & src == this ){ return * this ; } DeepCopyFrom ( src ); return * this ; } virtual ~ TTimeSeries () { if ( storage != nullptr ) delete storage ; if ( mvp != nullptr ) delete mvp ; instances -- ; } T GetValueNoConst ( const size_t & index ) { if ( index < 0 || index >= GetLength ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowOutOfRange ( \"Trying to access a time series value with an index outside of its bounds\" ); return storage -> operator []( index ); } const T & GetValueConst ( const size_t & index ) const { if ( index < 0 || index >= GetLength ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowOutOfRange ( \"Trying to access a time series value with an index outside of its bounds\" ); return storage -> operator []( index ); } T GetValue ( const size_t & index ) { return GetValueNoConst ( index ); } const T & GetValue ( const size_t & index ) const { return GetValueConst ( index ); } T GetValueNoConst ( const ptime & instant ) { return GetValueNoConst ( IndexForTime ( instant )); } T GetValue ( const ptime & instant ) { return GetValueNoConst ( IndexForTime ( instant )); } const T & GetValue ( const ptime & instant ) const { const size_t index = IndexForTime ( instant ); return GetValue ( index ); } T GetLastValue () { size_t length = GetLength (); if ( length == 0 ) datatypes :: exceptions :: ExceptionUtilities :: ThrowOutOfRange ( \"TimeSeries::GetLastValue cannot be called on an empty time series\" ); size_t index = length - 1 ; return GetValue ( index ); } void CopyTo ( T * dest , size_t from = 0 , size_t to = -1 ) const { CheckIntervalBounds ( from , to ); UncheckedCopyTo ( dest , from , to ); } void CopyWithMissingValueTo ( T * dest , const T & missingValueValue , size_t from = 0 , size_t to = -1 ) const { CheckIntervalBounds ( from , to ); UncheckedCopyTo ( dest , from , to , missingValueValue ); } void CopyValues ( const TTimeSeries < T >& src ) { if ( GetTimeStep () != src . GetTimeStep ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"time series copy values is only for identical time steps\" ); size_t from = IndexForTime ( src . GetStartDate ()); size_t to = IndexForTime ( src . GetEndDate ()); CheckIntervalBounds ( from , to ); for ( size_t i = from ; i <= to ; i ++ ) { T val = src . GetValue ( i - from ); this -> SetValue ( i , ( src . IsMissingValue ( val ) ? GetMissingValue () : val )); } } void CopyTo ( vector < T >& dest , size_t from = 0 , size_t to = -1 ) const { CheckIntervalBounds ( from , to ); storage -> CopyTo ( dest , from , to ); } T * GetValues ( size_t from = 0 , size_t to = std :: numeric_limits < size_t >:: max ()) const { CheckIntervalBounds ( from , to ); size_t len = ( to - from ) + 1 ; T * values = new T [ len ]; this -> UncheckedCopyTo ( values , from , to ); return values ; } vector < T > GetValuesVector ( size_t from = 0 , size_t to = std :: numeric_limits < size_t >:: max ()) const { CheckIntervalBounds ( from , to ); vector < T > values ; this -> CopyTo ( values , from , to ); return values ; } TTimeSeries < T > Subset ( size_t from = 0 , size_t to = std :: numeric_limits < size_t >:: max ()) const { CheckIntervalBounds ( from , to ); size_t len = ( to - from ) + 1 ; T * values = GetValues ( from , to ); // TODO: consider what to do with storage policy. MVP makes sense to keep the same. auto res = TTimeSeries < T > ( values , len , TimeForIndex ( from ), GetTimeStep (), nullptr , mvp -> Clone ()); delete [] values ; return res ; } void SetValue ( size_t index , T value ) { storage -> operator []( index ) = value ; } void SetValue ( const ptime & instant , T value ) { SetValue ( IndexForTime ( instant ), value ); } void Reset ( size_t length , const ptime & startDate , const TimeStep & timeStep ) { this -> storage -> SetStart ( startDate ); this -> storage -> SetTimeStep ( timeStep ); this -> storage -> Allocate ( length , mvp -> GetMissingValue ()); } void Reset ( size_t length , const ptime & startDate , const T * values = nullptr ) { if ( values == nullptr ) this -> storage -> Allocate ( length , mvp -> GetMissingValue ()); else this -> storage -> AllocateValues ( length , values ); this -> storage -> SetStart ( startDate ); } void Reset ( size_t length , const ptime & startDate , T value ) { this -> storage -> Allocate ( length , value ); this -> storage -> SetStart ( startDate ); } void Reset ( const vector < T >& values , const ptime & startDate ) { this -> storage -> AllocateValues ( values ); this -> storage -> SetStart ( startDate ); } void Reset ( const vector < T >& values , const ptime & startDate , const TimeStep & timeStep ) { this -> storage -> AllocateValues ( values ); this -> storage -> SetStart ( startDate ); this -> storage -> SetTimeStep ( timeStep ); } size_t GetLength () const { return storage -> Size (); } ptime GetStartDate () const { return storage -> GetStart (); } ptime GetEndDate () const { size_t n = GetLength (); if ( n == 0 ) return GetStartDate (); // what else? else return GetTimeStep (). AddSteps ( GetStartDate (), n -1 ); } TimeStep GetTimeStep () const { return storage -> GetTimeStep (); } void SetTimeStep ( const TimeStep & timeStep ) { this -> storage -> SetTimeStep ( timeStep ); } void SetStartDate ( const ptime & start ) { this -> storage -> SetStart ( start ); } ptime TimeForIndex ( size_t timeIndex ) const { return GetTimeStep (). AddSteps ( this -> GetStartDate (), timeIndex ); } vector < ptime > TimeIndices () const { auto tstep = GetTimeStep (); return tstep . AddSteps ( this -> GetStartDate (), SeqVec < double > ( 0 , 1 , GetLength ())); } size_t IndexForTime ( const ptime & instant ) const { return LowerIndexForTime ( instant ); } size_t UpperIndexForTime ( const ptime & instant ) const { auto uIndex = GetTimeStep (). GetUpperNumSteps ( GetStartDate (), instant ) - 1 ; datatypes :: exceptions :: ExceptionUtilities :: CheckInRange < ptrdiff_t > ( uIndex , 0 , GetLength () - 1 , \"UpperIndexForTime\" ); return ( size_t ) uIndex ; } size_t LowerIndexForTime ( const ptime & instant ) const { auto uIndex = GetTimeStep (). GetNumSteps ( GetStartDate (), instant ) - 1 ; datatypes :: exceptions :: ExceptionUtilities :: CheckInRange < ptrdiff_t > ( uIndex , 0 , GetLength () - 1 , \"LowerIndexForTime\" ); return ( size_t ) uIndex ; } string GetSummary () const { string result = \"[\" + to_iso_extended_string ( GetStartDate ()) + \"/\" + to_iso_extended_string ( GetEndDate ()) + \"];length=\" + std :: to_string ( GetLength ()) + \";time step=\" + GetTimeStep (). GetName (); return result ; } T & operator []( const ptime & instant ) { return storage -> operator []( IndexForTime ( instant )); } T & operator []( const size_t i ) { return storage -> operator []( i ); } const T & operator []( const ptime & instant ) const { return this -> operator []( IndexForTime ( instant )); } const T & operator []( const size_t i ) const { return storage -> operator []( i ); } TTimeSeries < T > operator + ( const TTimeSeries < T >& rhs ) const { // TODO check geometry compatibility T a , b ; T na = this -> mvp -> GetMissingValue (); size_t length = rhs . GetLength (); TTimeSeries < T > ts ( na , length , GetStartDate (), GetTimeStep (), nullptr , mvp -> Clone ()); //ts.naCode = this->naCode; for ( size_t i = 0 ; i < length ; i ++ ) { a = this -> operator []( i ); b = rhs . operator []( i ); if ( IsMissingValue ( a ) || rhs . IsMissingValue ( b )) ts . operator []( i ) = ts . GetNACode (); else ts . operator []( i ) = a + b ; } return ts ; } TTimeSeries < T > operator + ( T value ) const { T a ; T na = this -> mvp -> GetMissingValue (); size_t length = this -> GetLength (); TTimeSeries < T > ts ( na , length , GetStartDate (), GetTimeStep (), nullptr , mvp -> Clone ()); for ( size_t i = 0 ; i < length ; i ++ ) { a = this -> operator []( i ); if ( IsMissingValue ( a )) ts . operator []( i ) = ts . GetNACode (); else ts . operator []( i ) = a + value ; } return ts ; } template < typename M > TTimeSeries < T > operator * ( M multiplicator ) const { T a ; TTimeSeries < T > ts ( * this ); auto length = GetLength (); for ( size_t i = 0 ; i < length ; i ++ ) { a = this -> operator []( i ); if ( IsMissingValue ( a )) ts . operator []( i ) = ts . GetNACode (); else ts . operator []( i ) = a * multiplicator ; } return ts ; } string Tag ; private : void CheckIntervalBounds ( const size_t & from , size_t & to ) const { size_t tsLen = this -> GetLength (); datatypes :: exceptions :: RangeCheck < size_t >:: CheckTimeSeriesInterval ( from , to , tsLen ); } void UncheckedCopyTo ( T * dest , const size_t & from , const size_t & to ) const { // The following is neat and safe but not portable... //std::copy(data.begin() + from, data.begin() + to + 1, stdext::checked_array_iterator<T*>(dest, to - from + 1)); // so, looking potentially unsafe: for ( size_t i = from ; i <= to ; i ++ ) { dest [ i - from ] = storage -> operator []( i ); } } void UncheckedCopyTo ( T * dest , const size_t & from , const size_t & to , const T & missingValue ) const { for ( size_t i = from ; i <= to ; i ++ ) { T value = storage -> operator []( i ); dest [ i - from ] = IsMissingValue ( value ) ? missingValue : value ; } } void DeepCopyFrom ( const TTimeSeries < T >& src ) { Tag = src . Tag ; mvp = src . mvp -> Clone (); if ( storage == nullptr ) storage = src . storage -> Clone (); else src . storage -> CopyTo ( * ( this -> storage )); } //ptime startDate; //TimeStep timeStep; static std :: atomic < int > instances ; void SetDefaults ( StoragePolicy < T >* storage , MissingValuePolicy < T >* mvp ) { this -> mvp = ( mvp != nullptr ) ? mvp : DefaultMissingValuePolicy < T > (); this -> storage = ( storage != nullptr ) ? storage : DefaultStoragePolicy < T > (); if ( ! this -> storage -> ReadOnly ()) this -> SetTimeStep ( TimeStep :: GetHourly ()); } public : static int NumInstances () { return instances ; }; }; //template <typename T, template <typename> class StP, template <typename> class MvP> template < typename T > std :: atomic < int > TTimeSeries < T >:: instances ( 0 ); typedef TTimeSeries < double > TimeSeries ; template < typename TsType = TimeSeries > class MultiTimeSeries // This may become an abstract class with specializations for lazy loading time series from the data store. { private : EnsembleStoragePolicy < TsType >* store = nullptr ; protected : virtual void InitializeStorage () { if ( store == nullptr ) store = new StdVectorEnsembleStoragePolicy < TsType > (); } public : typedef typename std :: remove_pointer < TsType >:: type Type ; typedef typename std :: add_pointer < Type >:: type PtrType ; typedef TsType ItemType ; typedef typename Type :: ElementType ElementType ; MultiTimeSeries ( const vector < ElementType *>& values , size_t length , const ptime & startDate , const TimeStep & timeStep ) { Clear (); this -> startDate = startDate ; this -> timeStep = timeStep ; vector < PtrType > series ; for ( auto & d : values ) series . push_back ( new Type ( d , length , startDate , timeStep )); store -> Reset ( series , startDate , timeStep ); } MultiTimeSeries ( const vector < vector < ElementType >>& values , const ptime & startDate , const TimeStep & timeStep ) { Clear (); this -> startDate = startDate ; this -> timeStep = timeStep ; vector < PtrType > series ; for ( auto & d : values ) series . push_back ( new Type ( d , startDate , timeStep )); store -> Reset ( series , startDate , timeStep ); } MultiTimeSeries ( ElementType ** const values , size_t ensSize , size_t length , const ptime & startDate , const TimeStep & timeStep ) { Clear (); this -> startDate = startDate ; this -> timeStep = timeStep ; vector < PtrType > series ; for ( int i = 0 ; i < ensSize ; i ++ ) series . push_back ( new Type ( values [ i ], length , startDate , timeStep )); store -> Reset ( series , startDate , timeStep ); } MultiTimeSeries ( const vector < PtrType >& values , const ptime & startDate , const TimeStep & timeStep ) { Clear (); this -> startDate = startDate ; this -> timeStep = timeStep ; store -> Reset ( values , startDate , timeStep ); } MultiTimeSeries ( const Type & series ) { Clear (); this -> startDate = series . GetStartDate (); this -> timeStep = series . GetTimeStep (); vector < PtrType > s ; s . push_back ( new Type ( series )); store -> Reset ( s , startDate , timeStep ); } MultiTimeSeries ( const vector < Type >& values , const ptime & startDate , const TimeStep & timeStep ) { Clear (); this -> startDate = startDate ; this -> timeStep = timeStep ; vector < PtrType > series ; for ( const Type & d : values ) series . push_back ( new Type ( d )); store -> Reset ( series , startDate , timeStep ); } // This constructor is initially intended only as a convenience for testing purposes. MultiTimeSeries ( std :: function < Type ( size_t ) >& valueGen , size_t ensSize , const ptime & startDate , const TimeStep & timeStep ) { Clear (); this -> startDate = startDate ; this -> timeStep = timeStep ; vector < PtrType > series ; for ( size_t i = 0 ; i < ensSize ; i ++ ) series . push_back ( new Type ( valueGen ( i ))); store -> Reset ( series , startDate , timeStep ); } MultiTimeSeries ( const MultiTimeSeries < TsType >& src ) { * this = src ; } MultiTimeSeries ( EnsembleStoragePolicy < TsType >* store ) { if ( store == nullptr ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"store must not be nullptr\" ); this -> store = store ; } MultiTimeSeries () { this -> startDate = ptime ( not_a_date_time ); this -> timeStep = TimeStep :: GetHourly (); } MultiTimeSeries < PtrType >* AsPointerSeries () { return new MultiTimeSeries < PtrType > ( store -> AsReadonlyVector (), startDate , timeStep ); } MultiTimeSeries < Type > AsValueSeries () { return MultiTimeSeries < Type > ( store -> AsReadonlyVector (), startDate , timeStep ); } ~ MultiTimeSeries () { Clear (); } MultiTimeSeries & operator = ( const MultiTimeSeries & src ) { if ( & src == this ) { return * this ; } OperatorEqualImpl ( src ); return * this ; } MultiTimeSeries & operator = ( MultiTimeSeries && src ) { if ( & src == this ) { return * this ; } std :: swap ( timeStep , src . timeStep ); std :: swap ( startDate , src . startDate ); std :: swap ( store , src . store ); return * this ; } void ResetSeries ( const size_t & numSeries , const size_t & lengthSeries , const ptime & startDate , const TimeStep & timeStep ) { Clear (); store -> ResetSeries ( numSeries , lengthSeries , startDate , timeStep ); this -> startDate = startDate ; this -> timeStep = timeStep ; } TsType Get ( size_t i ) { return store -> Get ( i ); } Type Get ( size_t i ) const { return store -> Get ( i ); } ElementType Get ( size_t i , size_t tsIndex ) { return store -> Get ( i , tsIndex ); } void Set ( size_t i , size_t tsIndex , ElementType val ) { store -> Set ( i , tsIndex , val ); } void Set ( size_t i , const Type & val ) { store -> Set ( i , val ); } vector < ElementType *>* GetValues () const { return store -> GetValues (); } void CopyTo ( ElementType ** dest ) const { store -> CopyTo ( dest ); } size_t Size () const { return store -> Size (); } size_t GetLength ( size_t i ) const { return store -> GetLength ( i ); } ptime GetStartDate () const { return startDate ; } void SetStartDate ( const ptime & start ) { startDate = start ; } TimeStep GetTimeStep () const { return timeStep ; } void Clear () { if ( store == nullptr ) InitializeStorage (); else store -> Clear (); } private : ptime startDate ; TimeStep timeStep ; void DeepCopyFrom ( const MultiTimeSeries < TsType >& src ) { this -> startDate = src . startDate ; this -> timeStep = src . timeStep ; if ( store == nullptr ) store = src . store -> Clone (); else * ( src . store ) = ( * ( this -> store )); } protected : virtual void OperatorEqualImpl ( const MultiTimeSeries < TsType >& src ) { DeepCopyFrom ( src ); } }; template < typename T > struct time_series_of { typedef TTimeSeries < T > type ; }; template < typename T > struct ensemble_of { typedef MultiTimeSeries < T > type ; }; template < typename T > struct item_type_of { typedef typename T :: ElementType type ; }; template < typename ElementType = double > struct CommonTypes { using SeriesType = typename time_series_of < ElementType >:: type ; using PtrSeriesType = typename std :: add_pointer < SeriesType >:: type ; using EnsembleType = typename ensemble_of < SeriesType >:: type ; using EnsemblePtrType = typename ensemble_of < PtrSeriesType >:: type ; using PtrEnsemblePtrType = typename std :: add_pointer < EnsemblePtrType >:: type ; using TSeriesEnsemblePtrType = typename time_series_of < PtrEnsemblePtrType >:: type ; using PtrTSeriesEnsemblePtrType = typename std :: add_pointer < TSeriesEnsemblePtrType >:: type ; }; template < typename ItemType > using PointerTypeTimeSeries = TTimeSeries < ItemType * > ; template < typename Tts = TimeSeries > using MultiTimeSeriesPtr = MultiTimeSeries < Tts * > ; template < typename Tts = TimeSeries > using ForecastTimeSeries = PointerTypeTimeSeries < Tts > ; template < typename Tts = TimeSeries > using TimeSeriesEnsemble = MultiTimeSeriesPtr < Tts > ; template < typename Tts = TimeSeries > using EnsembleForecastTimeSeries = PointerTypeTimeSeries < MultiTimeSeriesPtr < Tts > > ; template < typename Tts = TimeSeries > class TimeSeriesOperations { public : using ElementType = typename Tts :: ElementType ; using SeriesType = typename CommonTypes < ElementType >:: SeriesType ; using PtrSeriesType = typename CommonTypes < ElementType >:: PtrSeriesType ; using EnsembleType = typename CommonTypes < ElementType >:: EnsembleType ; using EnsemblePtrType = typename CommonTypes < ElementType >:: EnsemblePtrType ; using PtrEnsemblePtrType = typename CommonTypes < ElementType >:: PtrEnsemblePtrType ; using TSeriesEnsemblePtrType = typename CommonTypes < ElementType >:: TSeriesEnsemblePtrType ; using PtrTSeriesEnsemblePtrType = typename CommonTypes < ElementType >:: PtrTSeriesEnsemblePtrType ; static PtrSeriesType TrimTimeSeries ( const SeriesType & timeSeries , const ptime & startDate , const ptime & endDate ) { ptime sd = timeSeries . GetStartDate (); ptime ed = timeSeries . GetEndDate (); size_t sIndex = timeSeries . UpperIndexForTime ( startDate ); size_t eIndex = timeSeries . LowerIndexForTime ( endDate ); return new SeriesType ( timeSeries . Subset ( sIndex , eIndex )); } static PtrSeriesType Resample ( const SeriesType & timeSeries , const string & method ) { using namespace boost :: algorithm ; string m = method ; to_lower ( m ); if ( m == \"\" ) return new TimeSeries ( timeSeries ); else if ( m == \"daily_to_hourly\" ) return DailyToHourly ( timeSeries ); else { datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"Time series resampling method not known: \" + method ); return nullptr ; } } static PtrSeriesType DailyToHourly ( const SeriesType & dailyTimeSeries ) { using T = typename SeriesType :: ElementType ; size_t length = dailyTimeSeries . GetLength (); T * data = new T [ length * 24 ]; for ( size_t i = 0 ; i < length ; i ++ ) for ( size_t j = 0 ; j < 24 ; j ++ ) data [( i * 24 ) + j ] = ( dailyTimeSeries [ i ] / 24 ); PtrSeriesType result = new SeriesType ( data , length * 24 , dailyTimeSeries . GetStartDate ()); delete [] data ; return result ; } static PtrSeriesType JoinTimeSeries ( const SeriesType & head , const SeriesType & tail ) { using T = typename SeriesType :: ElementType ; ptime startDate = head . GetStartDate (); size_t headLength = head . GetLength (); size_t tailLength = tail . GetLength (); size_t length = headLength + tailLength ; T * data = new T [ length ]; for ( size_t i = 0 ; i < length ; i ++ ) { if ( i < headLength ) data [ i ] = head [ i ]; else data [ i ] = tail [ i - headLength ]; } PtrSeriesType result = new SeriesType ( data , length , startDate ); delete [] data ; return result ; } static SeriesType AggregateTimeStep ( const SeriesType & series , const string & argument ) { using sec_type = boost :: posix_time :: time_duration :: sec_type ; auto newTimeStep = TimeStep :: Parse ( argument ); sec_type deltaNew = newTimeStep . GetRegularStepDuration (). total_seconds (); sec_type delta = series . GetTimeStep (). GetRegularStepDuration (). total_seconds (); if ( deltaNew < delta ) throw std :: logic_error ( \"Cannot aggregate to a target time step finer than data source\" ); sec_type remainder = deltaNew % delta ; if ( remainder != 0 ) throw std :: logic_error ( \"Aggregate: target time step must be a multiple of the starting time step\" ); sec_type multiple = deltaNew / delta ; size_t targetSize = series . GetLength () / multiple ; if ( targetSize < 1 ) throw std :: logic_error ( \"Aggregate: source lenght too short to aggregate\" ); SeriesType newTs ( 0.0 , targetSize , series . TimeForIndex ( multiple -1 ), newTimeStep ); for ( size_t i = 0 ; i < targetSize ; i ++ ) { double accumulated = 0 ; for ( size_t j = 0 ; j < multiple ; j ++ ) { auto val = series . GetValue ( i * multiple + j ); if ( series . IsMissingValue ( val )) { newTs . SetValue ( i , newTs . GetMissingValue ()); accumulated = .0 ; break ; } else accumulated += val ; } newTs . SetValue ( i , accumulated ); accumulated = .0 ; } return newTs ; } static SeriesType DisaggregateTimeStep ( const SeriesType & series , const string & argument ) { using sec_type = boost :: posix_time :: time_duration :: sec_type ; TimeStep newTimeStep = TimeStep :: Parse ( argument ); sec_type deltaNew = newTimeStep . GetRegularStepDuration (). total_seconds (); sec_type delta = series . GetTimeStep (). GetRegularStepDuration (). total_seconds (); if ( deltaNew > delta ) throw std :: logic_error ( \"Cannot disaggregate to a target time step coarser than data source\" ); sec_type remainder = delta % deltaNew ; if ( remainder != 0 ) throw std :: logic_error ( \"Disaggregate: the starting time step must be a multiple of the target time step\" ); sec_type multiple_sc = delta / deltaNew ; // NOTE: I had changed from sec_type to size_t because of a compilation issue with gcc 8.3.0 (??), but this breaks the UT on calling AddSteps size_t multiple = ( size_t ) multiple_sc ; size_t srcSize = series . GetLength (); size_t targetSize = series . GetLength () * multiple ; if ( targetSize < 1 ) throw std :: logic_error ( \"Disaggregate: source lengh is too short to aggregate\" ); ptime newStartDate = newTimeStep . AddSteps ( series . GetStartDate (), - ( (( double ) multiple ) - 1 )); SeriesType newTs ( 0.0 , targetSize , newStartDate , newTimeStep ); for ( size_t i = 0 ; i < srcSize ; i ++ ) { auto val = series . GetValue ( i ); for ( size_t j = 0 ; j < multiple ; j ++ ) { if ( series . IsMissingValue ( val )) newTs . SetValue ( i * multiple + j , newTs . GetMissingValue ()); else newTs . SetValue ( i * multiple + j , val / multiple ); } } return newTs ; } static void AggregateTimeStep ( SeriesType & series , const string & argument ) { series = AggregateTimeStep (( const SeriesType & ) series , argument ); } static void DisaggregateTimeStep ( SeriesType & series , const string & argument ) { series = DisaggregateTimeStep (( const SeriesType & ) series , argument ); } static void TransformEachItem ( TSeriesEnsemblePtrType & efts , const string & method , const string & methodArgument ) { if ( method == string ( \"accumulate\" )) { auto n = efts . GetLength (); for ( size_t i = 0 ; i < n ; i ++ ) { PtrEnsemblePtrType item = efts . GetValue ( i ); EnsemblePtrType & y = * item ; for ( size_t j = 0 ; j < y . Size (); j ++ ) { PtrSeriesType t = y . Get ( j ); AggregateTimeStep ( * t , methodArgument ); if ( j == 0 ) y . SetStartDate ( t -> GetStartDate ()); } } } else if ( method == string ( \"disaggregate\" )) { auto n = efts . GetLength (); for ( size_t i = 0 ; i < n ; i ++ ) { PtrEnsemblePtrType item = efts . GetValue ( i ); EnsemblePtrType & y = * item ; for ( size_t j = 0 ; j < y . Size (); j ++ ) { PtrSeriesType t = y . Get ( j ); DisaggregateTimeStep ( * t , methodArgument ); if ( j == 0 ) y . SetStartDate ( t -> GetStartDate ()); } } } else throw std :: logic_error ( \"TransformEachItem is limited to 'accumulate' or 'disaggregate'\" ); } private : static const PtrEnsemblePtrType & GetEnsemble ( const TSeriesEnsemblePtrType & ensTs , size_t index = 0 ) { using datatypes :: exceptions :: ExceptionUtilities ; if ( ensTs . GetLength () == 0 ) ExceptionUtilities :: ThrowInvalidArgument ( \"ensemble time series is of length zero\" ); ExceptionUtilities :: CheckInRange < size_t > ( index , 0 , ensTs . GetLength (), \"index\" ); const PtrEnsemblePtrType & ens = ensTs . GetValue ( index ); //if (ens->Size() == 0) ExceptionUtilities::ThrowInvalidArgument(\"ensemble is of size zero\"); return ens ; } public : static ptime GetStart ( const TSeriesEnsemblePtrType & ensTs , size_t index = 0 ) { auto ens = GetEnsemble ( ensTs , index ); return ens -> GetStartDate (); } static ptime GetEnd ( const TSeriesEnsemblePtrType & ensTs , size_t index = 0 ) { auto ens = GetEnsemble ( ensTs , index ); return ens -> Get ( 0 ) -> GetEndDate (); } static void CreateForecast ( TSeriesEnsemblePtrType & forecast , const SeriesType & observations , const ptime & start , size_t length , const TimeStep & issueTimeStep , size_t leadTime , size_t offsetForecasts ) { forecast . Reset ( length , start , issueTimeStep ); TimeStep obsTstep = observations . GetTimeStep (); for ( size_t i = 0 ; i < length ; i ++ ) { // Index in the observation time series corresponding to the forecast issue time 'i' size_t obsIndex = observations . IndexForTime ( issueTimeStep . AddSteps ( start , i )); size_t from = obsIndex + offsetForecasts ; size_t to = from + ( leadTime -1 ); SeriesType fcast = observations . Subset ( from , to ); EnsemblePtrType * mts = new EnsemblePtrType ( fcast ); forecast . SetValue ( i , mts ); } } static TSeriesEnsemblePtrType * CreateForecastPtr ( const SeriesType & observations , const ptime & start , size_t length , const TimeStep & issueTimeStep , size_t leadTime , size_t offsetForecasts ) { TSeriesEnsemblePtrType * forecast = new TSeriesEnsemblePtrType ( length , start , issueTimeStep ); CreateForecast ( * forecast , observations , start , length , issueTimeStep , leadTime , offsetForecasts ); return forecast ; } static TSeriesEnsemblePtrType CreateForecast ( const SeriesType & observations , const ptime & start , size_t length , const TimeStep & issueTimeStep , size_t leadTime , size_t offsetForecasts ) { TSeriesEnsemblePtrType forecast ; CreateForecast ( forecast , observations , start , length , issueTimeStep , leadTime , offsetForecasts ); return forecast ; } template < typename U > static bool AreEqual ( const SeriesType & a , const U & b , bool strict = false , double tolerance = 1e-12 ) { size_t lengthA = a . GetLength (); for ( size_t i = 0 ; i < lengthA ; i ++ ) { auto valA = a [ i ]; if ( strict && ( valA != b )) return false ; else if ( std :: abs ( valA - b ) > tolerance ) return false ; } return true ; } static bool AreTimeSeriesEqual ( const SeriesType & a , const SeriesType & b , bool strict = false , double tolerance = 1e-12 ) { ptime startA = a . GetStartDate (); ptime startB = b . GetStartDate (); if ( startA != startB ) return false ; ptime endA = a . GetEndDate (); ptime endB = b . GetEndDate (); if ( endA != endB ) return false ; size_t lengthA = a . GetLength (); size_t lengthB = b . GetLength (); if ( lengthA != lengthB ) return false ; for ( size_t i = 0 ; i < lengthA ; i ++ ) { auto valA = a [ i ]; auto valB = b [ i ]; if ( strict && ( valA != valB )) return false ; else if ( std :: abs ( valA - valB ) > tolerance ) return false ; } return true ; } static bool AreTimeSeriesEqual ( const SeriesType & a , const SeriesType & b , const ptime & from , const ptime & to , bool strict = false , double tolerance = 1e-12 ) { TimeStep ta = a . GetTimeStep (); TimeStep tb = b . GetTimeStep (); if ( ta != tb ) return false ; auto n = ta . GetNumSteps ( from , to ); if ( n < 0 ) return false ; size_t s = ( size_t ) n ; auto offsetA = a . IndexForTime ( from ); auto offsetB = b . IndexForTime ( from ); for ( size_t i = 0 ; i < s ; i ++ ) { auto valA = a [ i + offsetA ]; auto valB = b [ i + offsetB ]; if ( strict && ( valA != valB )) return false ; else if ( std :: abs ( valA - valB ) > tolerance ) return false ; } return true ; } static bool AreValueEqual ( const SeriesType & a , const vector < ElementType >& b , size_t from = 0 , size_t to = std :: numeric_limits < size_t >:: max (), bool strict = false , double tolerance = 1e-12 ) { vector < ElementType > v = a . GetValuesVector ( from , to ); if ( v . size () != b . size ()) return false ; for ( size_t i = 0 ; i < v . size (); i ++ ) { auto valA = v [ i ]; auto valB = b [ i ]; if ( strict && ( valA != valB )) return false ; else if ( std :: abs ( valA - valB ) > tolerance ) return false ; } return true ; } static bool AreEnsembleTimeSeriesEqual ( EnsemblePtrType & a , EnsemblePtrType & b ) { size_t lengthA = a . Size (); size_t lengthB = b . Size (); if ( lengthA != lengthB ) return false ; for ( size_t i = 0 ; i < lengthA ; i ++ ) { auto valA = a . Get ( i ); auto valB = b . Get ( i ); if ( ! AreTimeSeriesEqual ( * valA , * valB )) return false ; } return true ; } static bool AreEnsembleTimeSeriesEqual ( EnsembleType & a , EnsembleType & b ) { size_t lengthA = a . Size (); size_t lengthB = b . Size (); if ( lengthA != lengthB ) return false ; for ( size_t i = 0 ; i < lengthA ; i ++ ) { auto valA = a . Get ( i ); auto valB = b . Get ( i ); if ( ! AreTimeSeriesEqual ( valA , valB )) return false ; } return true ; } static bool AreTimeSeriesEnsembleTimeSeriesEqual ( TSeriesEnsemblePtrType & a , TSeriesEnsemblePtrType & b ) { size_t lengthA = a . GetLength (); size_t lengthB = b . GetLength (); if ( lengthA != lengthB ) return false ; ptime startA = a . GetStartDate (); ptime startB = b . GetStartDate (); if ( startA != startB ) return false ; for ( size_t i = 0 ; i < lengthA ; i ++ ) { auto valA = a . GetValue ( i ); auto valB = b . GetValue ( i ); if ( ! AreEnsembleTimeSeriesEqual ( * valA , * valB )) return false ; } return true ; } template < typename T = typename Tts :: ElementType > static PtrSeriesType MaskTimeSeries ( const SeriesType & timeSeries , const ptime & start , const ptime & end , T maskValue ) { if ( start < timeSeries . GetStartDate ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"start needs to be greater than time series start\" ); if ( end > timeSeries . GetEndDate ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"end needs to be less than time series end\" ); size_t sIndex = timeSeries . UpperIndexForTime ( start ); size_t eIndex = timeSeries . LowerIndexForTime ( end ); size_t len = timeSeries . GetLength (); double * d = new double [ len ]; timeSeries . CopyTo ( d , 0 , len - 1 ); for ( size_t i = sIndex ; i <= eIndex ; i ++ ) d [ i ] = maskValue ; PtrSeriesType result = new SeriesType ( d , len , timeSeries . GetStartDate (), timeSeries . GetTimeStep ()); delete [] d ; return result ; } }; template < typename T > TTimeSeries < T > operator << ( const TTimeSeries < T >& a , const TTimeSeries < T >& b ) { using TsOps = TimeSeriesOperations < TTimeSeries < T >> ; if ( a . GetTimeStep () != b . GetTimeStep ()) // TODO: this is a minimum requirement datatypes :: exceptions :: ExceptionUtilities :: ThrowNotSupported ( \"operator<< requires identical time steps\" ); auto s = std :: min ( a . GetStartDate (), b . GetStartDate ()); auto e = std :: max ( a . GetEndDate (), b . GetEndDate ()); auto tstep = a . GetTimeStep (); auto length = tstep . GetNumSteps ( s , e ); TTimeSeries < T > result ( length , s , tstep ); result . CopyValues ( a ); result . CopyValues ( b ); return result ; } template < typename Tts = TimeSeries > class TimeWindow { public : TimeWindow ( const ptime & startDate , const ptime & endDate ) { this -> startDate = startDate ; this -> endDate = endDate ; } Tts * Trim ( const Tts & timeSeries ) const { return TimeSeriesOperations < Tts >:: TrimTimeSeries ( timeSeries , startDate , endDate ); } private : ptime startDate ; ptime endDate ; }; /******************* Below are implementations of the template code; they would normally be found in a .cpp file, but as templates putting them here makes it more reusable from other programs. ******************/ } namespace exceptions { class DATATYPES_DLL_LIB TimeSeriesChecks { public : static void CheckOutOfRange ( const string & msg , const datatypes :: timeseries :: TimeSeries & ts , const ptime & d ); }; } } Updated on 2022-08-20 at 19:28:22 +1000","title":"Source code"},{"location":"cpp/Files/time__series__io_8hpp/","text":"datatypes/time_series_io.hpp \u00b6 Namespaces \u00b6 Name datatypes datatypes::timeseries datatypes::timeseries::io Classes \u00b6 Name class datatypes::timeseries::GlobalAttributes A class to hold the global attributes of a file stored in the SWIFT netCDF format. class datatypes::timeseries::VariableAttributes A class to hold the attributes of a netCDF variable stored in the SWIFT netCDF format. class datatypes::timeseries::VariableDefinition class datatypes::timeseries::DimensionsDefinitions class datatypes::timeseries::DataGeometryProvider class datatypes::timeseries::io::SwiftNetCDFVariablePersister class datatypes::timeseries::io::SwiftNetCDFVariablePersister< double > class datatypes::timeseries::io::SwiftNetCDFVariablePersister< float > class datatypes::timeseries::io::SwiftNetCDFVariablePersister< long > class datatypes::timeseries::io::SwiftNetCDFVariablePersister< int > class datatypes::timeseries::io::SwiftNetCDFAccess Class responsible for the low-level read/write operations from/to a SWIFT netCDF file. class datatypes::timeseries::io::ConfigFileHelper class datatypes::timeseries::TimeSeriesIOHelper Representation of an univariate, ensemble time series with a SWIFT netCDF back end. class datatypes::timeseries::SingleNetCdfFileStore class datatypes::timeseries::NetCdfSingleSeriesStore class datatypes::timeseries::NetCdfEnsembleTimeSeriesStore class datatypes::timeseries::EagerWriter class datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore class datatypes::timeseries::MultiFileTsStorage An implementation of StoragePolicy such that the content of a time series is spread amongst several files. class datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore An implementation of TimeSeriesEnsembleTimeSeriesStore such that the content of a time series is spread amongst several files. class datatypes::timeseries::TimeSeriesLibraryFactory class datatypes::timeseries::SwiftNetcdfStoreFactory Source code \u00b6 #pragma once #include <stdexcept> #include <netcdf.h> #include <map> #ifdef __GNUC__ // https ://jira.csiro.au/browse/WIRADA-350 GNU gcc regex bug; use boost instead #if (__GNUC__ <= 4 && __GNUC_MINOR__ < 9) #include <boost/regex.hpp> #else #include <regex> #endif #else #include <regex> #endif // __GNUC__ #include <algorithm> #include <boost/function.hpp> #include <boost/filesystem.hpp> #include <boost/range/iterator_range.hpp> #include <boost/algorithm/string/predicate.hpp> #include <boost/algorithm/string/split.hpp> #include <boost/algorithm/string/classification.hpp> #include <boost/algorithm/string.hpp> #include \"time_series.hpp\" #include \"time_series_store.hpp\" namespace datatypes { namespace timeseries { using namespace datatypes :: exceptions ; class DATATYPES_DLL_LIB GlobalAttributes { public : string Title ; string Institution ; string Source ; string Catchment ; double STFConventionVersion ; string STFNCSpec ; string Comment ; string History ; GlobalAttributes (); GlobalAttributes ( const string & title , const string & institution , const string & source , const string & catchment , double stfConventionVersion , const string & stfNcSpec , const string & comment , const string & history ); GlobalAttributes ( GlobalAttributes && src ); GlobalAttributes ( const GlobalAttributes & src ); GlobalAttributes & operator = ( const GlobalAttributes & src ); static GlobalAttributes CreateDefault (); static GlobalAttributes CreateDefault ( const string & catchment ); }; template < typename From , typename To > To GetMetadataFrom ( const From & ens ) { throw std :: logic_error ( string ( \"No template specialization found for GetMetadataFrom<From,To> where From=\" ) + typeid ( From ). name () + string ( \"and To=\" ) + typeid ( To ). name ()); } class DATATYPES_DLL_LIB VariableAttributes { public : string LongName ; string Units ; int Type = 0 ; string TypeDescription ; string LocationType ; string DatType ; string DatDescription ; double FillValue ; static const double DefaultFillValue (); VariableAttributes (); VariableAttributes ( const string & longName , const string & units , int type , const string & typeDescription , const string & datType , const string & datDescription , const string & locationType , double fillValue ); VariableAttributes ( VariableAttributes && src ); VariableAttributes ( const VariableAttributes & src ); VariableAttributes & operator = ( const VariableAttributes & src ); }; class DATATYPES_DLL_LIB VariableDefinition { const string kDoublePrecision = DATATYPES_DOUBLE_PRECISION_ID ; const string kSinglePrecision = DATATYPES_SINGLE_PRECISION_ID ; public : VariableDefinition ( const string & name , const string & precision , const string & dimensions , const string & longName , const string & units , double fillValue , int type , const string & typeDescription , const string & datType , const string & datDescription , const string & locationType ); VariableDefinition ( const string & name , const VariableAttributes & attribs , const string & dimensions , const string & precision = DATATYPES_DOUBLE_PRECISION_ID ); VariableAttributes attributes ; string Name ; string Precision ; string Dimensions ; int GetPrecision () const ; static void Split ( const std :: map < string , VariableDefinition >& varDefinitions , vector < string >& varNames , std :: map < string , VariableAttributes >& varAttributes ); //static std::map<string, VariableDefinition> Join(const vector<string>& varNames, const std::map<string, VariableAttributes>& varAttributes); VariableDefinition (); VariableDefinition ( VariableDefinition && src ); VariableDefinition ( const VariableDefinition & src ); VariableDefinition & operator = ( VariableDefinition && src ); VariableDefinition & operator = ( const VariableDefinition & src ); static VariableDefinition PointTimeSeries ( const string & name , const string & units , const string & longName , int type = 0 , const string & typeDescription = \"<NA>\" , const string & datType = \"<NA>\" , const string & datDescription = \"<NA>\" , const string & precision = DATATYPES_DOUBLE_PRECISION_ID , double fillValue = DEFAULT_MISSING_DATA_VALUE , const string & locationType = \"Point\" ); static VariableDefinition TimeSeriesEnsembleTimeSeries ( const string & name , const string & units , const string & longName , int type = 0 , const string & typeDescription = \"<NA>\" , const string & datType = \"<NA>\" , const string & datDescription = \"<NA>\" , const string & precision = DATATYPES_DOUBLE_PRECISION_ID , double fillValue = DEFAULT_MISSING_DATA_VALUE , const string & locationType = \"Point\" ); }; class DATATYPES_DLL_LIB DimensionsDefinitions { public : DimensionsDefinitions ( const size_t ensembleSize , const vector < double >& leadTimeVar , const string & timeUnits , const vector < double >& timeVar , const vector < string >& stationIds = DEFAULT_STATION_IDENTIFIER , const string & leadTimeUnits = \"\" ); DimensionsDefinitions ( const string & timeUnits , const vector < double >& timeVar , const vector < string >& stationIds = DEFAULT_STATION_IDENTIFIER , const string & leadTimeUnits = \"\" ); DimensionsDefinitions ( ptime tsEnsStart , const TimeStep & mainTimeStep , size_t tsLength , size_t ensembleSize , const TimeStep & fcastTimeStep , size_t leadTimeSize , int fcastOffset = 1 , const vector < string >& stationIds = DEFAULT_STATION_IDENTIFIER , const string & leadTimeUnits = \"\" ); DimensionsDefinitions (); DimensionsDefinitions ( DimensionsDefinitions && src ); DimensionsDefinitions ( const DimensionsDefinitions & src ); DimensionsDefinitions & operator = ( DimensionsDefinitions && src ); DimensionsDefinitions & operator = ( const DimensionsDefinitions & src ); size_t EnsembleSize ; vector < double > LeadTimeVar ; string TimeUnits ; vector < double > TimeVar ; vector < string > StationIds ; string LeadTimeUnits ; }; template < typename ElementType > DimensionsDefinitions DimensionsFromSeries ( const TTimeSeries < ElementType >& ts , const size_t ensembleSize = 1 , const size_t leadTimeSize = 1 , const vector < string >& stationIds = DEFAULT_STATION_IDENTIFIER ) { const int fcastOffset = 1 ; return DimensionsDefinitions ( ts . GetStartDate (), ts . GetTimeStep (), ts . GetLength (), ensembleSize , ts . GetTimeStep (), leadTimeSize , fcastOffset , stationIds ); } template < typename ElementType > DimensionsDefinitions DimensionsFromSeries ( EnsembleForecastTimeSeries <>& tsEns , const vector < string >& stationIds = DEFAULT_STATION_IDENTIFIER ) { if ( tsEns . GetLength () == 0 ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"time series of ensemble forecasts must not be empty to retrieve dimensions\" ); auto ens = tsEns . GetValue (( size_t ) 0 ); if ( ens == nullptr ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"DimensionsDefinitions - time series of ensemble forecasts: first value must not be null\" ); auto s = ens -> Get ( 0 ); if ( s == nullptr ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"DimensionsDefinitions - time series of ensemble forecasts: first value in first ensemble must not be null\" ); auto tsEnsStart = tsEns . GetStartDate (); const size_t ensembleSize = ens -> Size (); TimeStep fcastTimeStep = ens -> GetTimeStep (); const size_t leadTimeSize = s -> GetLength (); const ptrdiff_t fcastOffset = fcastTimeStep . GetNumSteps ( tsEnsStart , s -> GetStartDate ()) - 1 ; return DimensionsDefinitions ( tsEnsStart , tsEns . GetTimeStep (), tsEns . GetLength (), ensembleSize , ens -> GetTimeStep (), leadTimeSize , fcastOffset , stationIds ); } template < typename ElementType > DimensionsDefinitions DimensionsFromSeries ( const vector < EnsembleForecastTimeSeries <>:: ElementType >& values , const TimeStep & tsEnsTstep = TimeStep :: GetUnknown (), const ptime & tsEnsStart = not_a_date_time , const vector < string >& stationIds = DEFAULT_STATION_IDENTIFIER , int fcastOffset = 1 ) { if ( values . empty ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"time series of ensemble forecasts must not be empty to retrieve dimensions\" ); auto ens = values [ 0 ]; if ( ens == nullptr ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"DimensionsDefinitions - time series of ensemble forecasts: first value must not be null\" ); auto s = ens -> Get ( 0 ); if ( s == nullptr ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"DimensionsDefinitions - time series of ensemble forecasts: first value in first ensemble must not be null\" ); //ptime tsEnsStart = tsEnsStart; const ptime & fcastUtcStart = s -> GetStartDate (); const TimeStep & fcastTimeStep = s -> GetTimeStep (); TimeStep mainTimeStep = tsEnsTstep ; ptime tsOrigin = tsEnsStart ; if ( tsOrigin == not_a_date_time ) tsOrigin = fcastTimeStep . AddSteps ( fcastUtcStart , - fcastOffset ); if ( mainTimeStep . IsUnknown ()) if ( values . size () > 1 && values [ 1 ] != nullptr ) mainTimeStep = TimeStep ( values [ 1 ] -> GetStartDate () - values [ 0 ] -> GetStartDate ()); else mainTimeStep = fcastTimeStep ; const size_t leadTimeSize = s -> GetLength (); const size_t ensembleSize = ens -> Size (); return DimensionsDefinitions ( tsOrigin , mainTimeStep , values . size (), ensembleSize , ens -> GetTimeStep (), leadTimeSize , fcastOffset , stationIds ); } //template<typename ElementType> //DimensionsDefinitions DimensionsFromSeries( // const TimeSeriesEnsemble<>& collectionOfTs, const vector<string>& stationIds = DEFAULT_STATION_IDENTIFIER) //{ // throw std::logic_error(\"dimension from ensemble time series not implemented\"); //} // A class that can provide the characteristics of a netCDF file for saving time series. // This class is a provision for future feature allowing for a late definition on disk // of the file geometry, e.g. when time series to record are reset after creation of the recorder. // Initially, not used to the full \"lazy\" extent as this is overly complicated for marginal/potential benefit. class DATATYPES_DLL_LIB DataGeometryProvider { public : virtual DimensionsDefinitions GetDimensions () const = 0 ; virtual ~ DataGeometryProvider (); }; namespace io { template < typename ElementType > class DATATYPES_DLL_LIB SwiftNetCDFVariablePersister { public : static int NcGetVara ( int ncid , int varid , const size_t * startp , const size_t * countp , ElementType * op ) { throw std :: logic_error ( string ( \"No template specialization found for SwiftNetCDFVariablePersister::NcGetVara for type\" ) + typeid ( ElementType ). name ()); } static int NcPutVara ( int ncid , int varid , const size_t * startp , const size_t * countp , const ElementType * op ) { throw std :: logic_error ( string ( \"No template specialization found for SwiftNetCDFVariablePersister::NcPutVara for type\" ) + typeid ( ElementType ). name ()); } }; template <> class DATATYPES_DLL_LIB SwiftNetCDFVariablePersister < double > { public : static int NcGetVara ( int ncid , int varid , const size_t * startp , const size_t * countp , double * op ) { return nc_get_vara_double ( ncid , varid , startp , countp , op ); } static int NcPutVara ( int ncid , int varid , const size_t * startp , const size_t * countp , const double * op ) { return nc_put_vara_double ( ncid , varid , startp , countp , op ); } }; template <> class DATATYPES_DLL_LIB SwiftNetCDFVariablePersister < float > { public : static int NcGetVara ( int ncid , int varid , const size_t * startp , const size_t * countp , float * op ) { return nc_get_vara_float ( ncid , varid , startp , countp , op ); } static int NcPutVara ( int ncid , int varid , const size_t * startp , const size_t * countp , const float * op ) { return nc_put_vara_float ( ncid , varid , startp , countp , op ); } }; template <> class DATATYPES_DLL_LIB SwiftNetCDFVariablePersister < long > { public : static int NcGetVara ( int ncid , int varid , const size_t * startp , const size_t * countp , long * op ) { return nc_get_vara_long ( ncid , varid , startp , countp , op ); } static int NcPutVara ( int ncid , int varid , const size_t * startp , const size_t * countp , const long * op ) { return nc_put_vara_long ( ncid , varid , startp , countp , op ); } }; template <> class DATATYPES_DLL_LIB SwiftNetCDFVariablePersister < int > { public : static int NcGetVara ( int ncid , int varid , const size_t * startp , const size_t * countp , int * op ) { return nc_get_vara_int ( ncid , varid , startp , countp , op ); } static int NcPutVara ( int ncid , int varid , const size_t * startp , const size_t * countp , const int * op ) { return nc_put_vara_int ( ncid , varid , startp , countp , op ); } }; class DATATYPES_DLL_LIB SwiftNetCDFAccess { // private : static void ThrowOnFileOpenFail ( const string & filename , int code ); static void ThrowOnVarInquiryFail ( const string & varName , int code ); void Init ( const string & filename , const size_t nEns , const vector < double >& leadTimeVar , const string & timeUnits , const vector < double >& timeVar , const vector < string >& stationIds , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes , const string & leadTimeUnits ); public : SwiftNetCDFAccess ( const string & filename , bool lazyLoad = false ); // * \\brief Constructor to create a new SWIFT netCDF file // * // * \\param filename name of the new file to create. // * \\param nEns Size of the ensembles // * \\param nLead Length of the lead time for each of the time series in the ensemble forecast for a given time. // * \\param timeUnits Units of the temporal dimension(s). // * \\param [in] timeVar The values of the \"main\" time dimension, consistent with the temporal units given with the previous parameter // * \\param [in] stationIds List of identifiers for the stations. // * \\param [in] varNames List of names of the variables. // * \\param [in] varAttributes Attributes for each variables; the keys of the dictionary must be found in the varNames parameter. // */ //SwiftNetCDFAccess(const string& filename, const size_t nEns, const vector<double>& leadTimeVar, const string& timeUnits, const vector<double>& timeVar, const vector<string>& stationIds, // const vector<string>& varNames, const std::map<string, VariableAttributes>& varAttributes); SwiftNetCDFAccess ( const string & filename , const size_t nEns , const vector < double >& leadTimeVar , const string & timeUnits , const vector < double >& timeVar , const vector < string >& stationIds , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes , const string & leadTimeUnits = \"\" ); SwiftNetCDFAccess ( const string & filename , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes ); ~ SwiftNetCDFAccess (); static void CheckCompliance ( const string & filename , int majorVersion , int minorVersion , vector < string >& warnings , vector < string >& errors ); size_t GetEnsembleSize (); size_t GetEnsembleSize ( const string & ncVarName ); size_t GetLeadTimeCount (); size_t GetLeadTimeCount ( const string & ncVarName ); size_t GetTimeLength () const ; vector < ptime > GetTimeDim (); ptime GetStart (); ptime GetEnd (); size_t IndexForIdentifier ( const string & identifier ) const ; size_t GetNumIdentifiers () const ; vector < string > GetIdentifiers () const ; //int IndexForTime(const ptime* time); ptime TimeForIndex ( size_t timeIndex ); private : template < typename ElementType > int NcGetVara ( int ncid , int varid , const size_t * startp , const size_t * countp , ElementType * op ) { return SwiftNetCDFVariablePersister < ElementType >:: NcGetVara ( ncid , varid , startp , countp , op ); } template < typename ElementType > int NcPutVara ( int ncid , int varid , const size_t * startp , const size_t * countp , const ElementType * op ) { return SwiftNetCDFVariablePersister < ElementType >:: NcPutVara ( ncid , varid , startp , countp , op ); } bool isTimeFastestVarying ( const vector < int >& varDimIds ) { return ( varDimIds [ varDimIds . size () - 1 ] == this -> timeDimId ); } public : template < typename ElementType > vector < ElementType *> * GetForecasts ( const string & varName , size_t stationIndex , size_t timeIndex ) { int dataVarId = GetVarId ( varName ); vector < size_t > startp ; vector < size_t > countp ; GetEnsFcastNetcdfWindow ( varName , stationIndex , timeIndex , startp , countp ); auto vardata = GetForecastDataBuffer (); size_t * s = & ( startp [ 0 ]); size_t * c = & ( countp [ 0 ]); int code = NcGetVara ( ncid , dataVarId , s , c , vardata ); if ( code != NC_NOERR ) { ExceptionUtilities :: ThrowInvalidOperation ( \"GetForecasts failed for variable \" + varName ); } auto result = new vector < ElementType *> (); ElementType * dest ; for ( int i = 0 ; i < ensembleSize ; i ++ ) { dest = new ElementType [ leadTimeLength ]; memcpy ( dest , vardata + i * leadTimeLength , leadTimeLength * sizeof ( ElementType )); result -> push_back ( dest ); } delete [] vardata ; return result ; } template < typename ElementType > vector < ElementType *> * GetEnsemble ( const string & varName , size_t stationIndex ) { int dataVarId = GetVarId ( varName ); vector < size_t > startp ; vector < size_t > countp ; GetNetcdfWindow ( varName , stationIndex , startp , countp ); auto n = GetTimeLength (); auto vardata = GetEnsembleDataBuffer ( 1 , n ); size_t * s = & ( startp [ 0 ]); size_t * c = & ( countp [ 0 ]); int code = NcGetVara ( ncid , dataVarId , s , c , vardata ); auto result = new vector < ElementType *> (); ElementType * dest ; auto maxT = this -> GetTimeLength (); for ( int i = 0 ; i < ensembleSize ; i ++ ) { // double q_ens[station, ens_member, time] in R; rev conventions for C // [time][ens_member][station]. There is only one station, so vardata is organised as // [time][ens_member] dest = new ElementType [ n ]; for ( size_t t = 0 ; t < maxT ; t ++ ) { dest [ t ] = vardata [ ensembleSize * t + i ]; } result -> push_back ( dest ); } delete [] vardata ; return result ; } template < typename ElementType > vector < ElementType > GetValues ( const string & varName , size_t stationIndex ) { int dataVarId = GetVarId ( varName ); vector < size_t > startp ; vector < size_t > countp ; GetNetcdfWindow ( varName , stationIndex , startp , countp ); vector < ElementType > vardata ( GetTimeLength ()); ElementType * op = & ( vardata [ 0 ]); size_t * s = & ( startp [ 0 ]); size_t * c = & ( countp [ 0 ]); int code = NcGetVara ( ncid , dataVarId , s , c , op ); if ( code != NC_NOERR ) { ExceptionUtilities :: ThrowInvalidOperation ( \"GetValues failed for variable \" + varName ); } return vardata ; } template < typename ElementType > vector < ElementType > GetValues ( const string & varName ) { size_t n = GetTimeLength (); size_t nIds = GetNumIdentifiers (); size_t N = n * nIds ; vector < ElementType > values ( N ); int dataVarId = GetVarId ( varName ); vector < size_t > startp ; vector < size_t > countp ; GetNetcdfWindow ( varName , startp , countp ); size_t * s = & ( startp [ 0 ]); size_t * c = & ( countp [ 0 ]); ElementType * vardata = values . data (); int code = NcGetVara ( ncid , dataVarId , s , c , vardata ); if ( code != NC_NOERR ) { ExceptionUtilities :: ThrowInvalidOperation ( \"GetValues failed for variable \" + varName ); } return values ; } template < typename ElementType > TTimeSeries < ElementType > * GetSeries ( const string & varName , size_t stationIndex ) { auto values = GetValues < ElementType > ( varName , stationIndex ); auto result = new TTimeSeries < ElementType > ( values , this -> TimeForIndex ( 0 ), this -> GetTimeStep ()); return result ; } template < typename ElementType > MultiTimeSeries < TTimeSeries < ElementType >*>* GetSeries ( const string & varName ) { vector < ElementType > values = GetValues < ElementType > ( varName ); size_t tlen = GetTimeLength (); size_t n = GetNumIdentifiers (); size_t N = n * tlen ; if ( values . size () != N ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"Inconsistencies between values length and expected total size of data\" ); auto varDims = GetVarDims ( varName ); ElementType * d = values . data (); auto start = TimeForIndex ( 0 ); auto tstep = GetTimeStep (); if ( isTimeFastestVarying ( varDims )) { vector < ElementType *> vv ( n ); for ( size_t i = 0 ; i < n ; i ++ ) { vv [ i ] = d ; d += tlen ; } return new MultiTimeSeries < TTimeSeries < ElementType >*> ( vv , tlen , GetStart (), GetTimeStep ()); } else { vector < ElementType > v ( tlen ); vector < vector < ElementType >> vv ; vv . assign ( n , v ); for ( size_t t = 0 ; t < tlen ; t ++ ) { for ( size_t s = 0 ; s < n ; s ++ ) { vv [ s ][ t ] = * d ; d += 1 ; } } return new MultiTimeSeries < TTimeSeries < ElementType >*> ( vv , GetStart (), GetTimeStep ()); } } template < typename ElementType > MultiTimeSeries < TTimeSeries < ElementType >*> * GetEnsembleSeries ( const string & varName , size_t stationIndex ) { auto series = GetEnsemble < ElementType > ( varName , stationIndex ); auto result = new MultiTimeSeries < TTimeSeries < ElementType >*> ( * series , this -> GetTimeLength (), this -> TimeForIndex ( 0 ), this -> GetTimeStep ()); for ( auto & d : ( * series )) { if ( d != nullptr ) delete [] d ; } delete series ; return result ; } template < typename ElementType > void SetForecasts ( const string & varName , size_t stationIndex , size_t timeIndex , vector < ElementType *> & values ) // TODO: checks on 'values' { int dataVarId = GetVarId ( varName ); vector < size_t > startp ; vector < size_t > countp ; GetEnsFcastNetcdfWindow ( varName , stationIndex , timeIndex , startp , countp ); auto vardata = GetForecastDataBuffer (); ElementType * dest ; for ( int i = 0 ; i < ensembleSize ; i ++ ) { dest = vardata + i * leadTimeLength ; memcpy ( dest , values [ i ], leadTimeLength * sizeof ( ElementType )); } size_t * s = & ( startp [ 0 ]); size_t * c = & ( countp [ 0 ]); int code = NcPutVara ( ncid , dataVarId , s , c , vardata ); delete [] vardata ; } template < typename ElementType > void SetEnsembles ( const string & varName , size_t stationIndex , vector < ElementType *> & values ) { int dataVarId = GetVarId ( varName ); vector < size_t > startp ; vector < size_t > countp ; GetNetcdfWindow ( varName , stationIndex , startp , countp ); size_t n = GetTimeLength (); auto vardata = GetEnsembleDataBuffer ( 1 , n ); for ( int i = 0 ; i < ensembleSize ; i ++ ) { ElementType * ensData = values [ i ]; for ( int j = 0 ; j < n ; j ++ ) { vardata [ ensembleSize * j + i ] = ensData [ j ]; } } size_t * s = & ( startp [ 0 ]); size_t * c = & ( countp [ 0 ]); int code = NcPutVara ( ncid , dataVarId , s , c , vardata ); delete vardata ; } template < typename ElementType > void SetValues ( const string & varName , size_t stationIndex , const vector < ElementType >& values ) { size_t n = GetTimeLength (); if ( values . size () != n ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"vector passed does not have the length of the main time dimension\" ); int dataVarId = GetVarId ( varName ); vector < size_t > startp ; vector < size_t > countp ; GetNetcdfWindow ( varName , stationIndex , startp , countp ); size_t * s = & ( startp [ 0 ]); size_t * c = & ( countp [ 0 ]); const double * vardata = values . data (); int code = NcPutVara ( ncid , dataVarId , s , c , vardata ); } template < typename ElementType > void SetValues ( const string & varName , const vector < ElementType >& values ) { size_t n = GetTimeLength (); size_t nIds = GetNumIdentifiers (); size_t N = n * nIds ; if ( values . size () != N ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"Inconsistencies between values length and expected total size of data\" ); int dataVarId = GetVarId ( varName ); vector < size_t > startp ; vector < size_t > countp ; GetNetcdfWindow ( varName , startp , countp ); size_t * s = & ( startp [ 0 ]); size_t * c = & ( countp [ 0 ]); // double q_der[station, time] in R; rev conventions for C const double * vardata = values . data (); int code = NcPutVara ( ncid , dataVarId , s , c , vardata ); if ( code != NC_NOERR ) { ExceptionUtilities :: ThrowInvalidOperation ( \"SetValues failed for variable \" + varName ); } } vector < int > GetVarDims ( int varNumDims ); vector < int > GetVarDims ( const string & varName ); vector < string > ReadVariableNames ( bool removeDimVars = true ); vector < string > ReadAttributeNames ( const string & varName ); string ReadStringAttribute ( int varId , const string & attName , bool throwIfNotFound = false , string defaultValue = \"\" ); string ReadStringAttribute ( const string & varName , const string & attName , bool throwIfNotFound = false , string defaultValue = \"\" ); double ReadNumericAttribute ( int varId , const string & attName , bool throwIfNotFound = false , double defaultValue = 0.0 ); double ReadNumericAttribute ( const string & varName , const string & attName , bool throwIfNotFound = false , double defaultValue = 0.0 ); VariableAttributes ReadAttributes ( const string & varName ); GlobalAttributes ReadGlobalAttributes (); template < typename ElementType > static string CreateTimeUnitsAttribute ( const TTimeSeries < ElementType >& tSeries ) { return CreateTimeUnitsAttribute ( tSeries . GetStartDate (), tSeries . GetTimeStep ()); } static std :: pair < vector < double > , vector < double >> CreateTimeVectors ( const ptime & start , const TimeStep & timeStep , size_t tsLength , const TimeStep & leadTimeStep , size_t leadTimeSize , int fcastOffset = 1 ); static vector < double > CreateTimeVector ( const ptime & start , const TimeStep & timeStep , const ptime & origin , const time_duration & timeStepAxis , const size_t length ); static vector < double > CreateTimeVector ( const ptime & start , const TimeStep & timeStep , const ptime & origin , const TimeStep & timeStepAxis , const size_t length ); static vector < double > CreateTimeVector ( const ptime & start , const TimeStep & timeStep , const size_t length ); template < typename ElementType > static vector < double > CreateTimeVector ( const TTimeSeries < ElementType >& tSeries ) { return CreateTimeVector ( tSeries . GetStartDate (), tSeries . GetTimeStep (), tSeries . GetLength ()); } template < typename ElementType > static vector < double > CreateTimeVector ( const TTimeSeries < ElementType >& tSeries , const ptime & origin , const TimeStep & timeStepAxis ) { return CreateTimeVector ( tSeries . GetStartDate (), tSeries . GetTimeStep (), origin , timeStepAxis , tSeries . GetLength ()); } template < typename T > static ptime StartCoordinate ( const ptime & origin , const TimeStep & timeStep , const vector < T >& timeCoords ) { if ( timeCoords . empty ()) ExceptionUtilities :: ThrowInvalidArgument ( \"Empty time coordinates\" ); return timeStep . AddSteps ( origin , timeCoords [ 0 ]); } static std :: pair < ptime , TimeStep > CreateTimeGeometry ( const string & axisDefinition , const vector < double >& timeCoords ); static string GetTimeStepName ( const TimeStep & timeStep ); static string CreateTimeUnitsAttribute ( const ptime & utcStart , const string & units ); static string CreateTimeUnitsAttribute ( const ptime & utcStart , const TimeStep & timeStep ); static ptime ParseStartDate ( const string & unitsAttribute ); static string ParseTimeUnits ( const string & unitsAttribute ); static string CreateLeadTimeUnitsAttribute ( const TimeStep & timeStep ); TimeStep GetTimeStep (); TimeStep GetLeadTimeStep (); std :: pair < ptime , TimeStep > GetLeadTimeGeometry ( const ptime & issueTime ); vector < double > GetLeadTimeDim (); template < class TFrom , class TTo > static vector < TTo > Convert ( const vector < TFrom >& from , const std :: function < TTo ( const TFrom & ) >& f ) { using IterFrom = typename vector < TFrom >:: const_iterator ; using IterTo = typename vector < TTo >:: iterator ; vector < TTo > result ( from . size ()); std :: transform < IterFrom , IterTo , std :: function < TTo ( TFrom ) >> ( from . begin (), from . end (), result . begin (), f ); return result ; } static time_duration CreateTimeUnits ( const TimeStep & timeStep ); static time_duration TimeOffsetIn ; static time_duration TimeOffsetOut ; static void SetTimeOffsetIn ( const time_duration & td ); static void SetTimeOffsetOut ( const time_duration & td ); GlobalAttributes GetGlobalAttributes (); VariableAttributes GetAttributes ( const string & varName ); private : TimeStep GetTimeUnitTimeStep () const ; void DefineVariable ( const VariableDefinition & definition , int & code ); static TimeStep GetTimeUnitTimeStep ( const string & timeUnits ); template < class TTo > static TTo * ConvertToArray ( const vector < string >& src ) { return datatypes :: utils :: ConvertToArray < TTo > ( src ); } template < class TFrom , class TTo > static TTo * ConvertToArray ( const vector < TFrom >& src ) { return datatypes :: utils :: ConvertToArray < TFrom , TTo > ( src ); } template < class TFrom , class TTo > static vector < TTo > Convert ( const vector < TFrom >& src ) { return datatypes :: utils :: Convert < TFrom , TTo > ( src ); } template < class TTo > vector < TTo > Convert ( const vector < string >& src ) { return datatypes :: utils :: Convert < TTo > ( src ); } template < class T > static vector < T > ToVector ( T * values , size_t n ) { vector < T > result ( n ); result . assign ( values , values + n ); return result ; } template < class T > TimeStep FindTimeStep ( bool & cachedFlag , TimeStep & timeStep , const vector < T >& timeVec ) { if ( cachedFlag ) return timeStep ; auto tsu = GetTimeUnitTimeStep (); if ( timeVec . size () <= 1 ) { timeStep = tsu ; } else { if ( tsu . IsRegular ()) { timeStep = tsu * ( timeVec [ 1 ] - timeVec [ 0 ]); } else { if (( timeVec [ 1 ] - timeVec [ 0 ]) == 1 ) { timeStep = tsu ; } else { exceptions :: ExceptionUtilities :: ThrowNotSupported ( \"No support for multiple increments of an irregular time step\" ); } } } cachedFlag = true ; return timeStep ; } template < class T > static TimeStep FindTimeStep ( const TimeStep & axisTimeStep , const vector < T >& timeVec ) { TimeStep timeStep ; auto tsu = axisTimeStep ; if ( timeVec . size () <= 1 ) timeStep = tsu ; else timeStep = tsu * ( timeVec [ 1 ] - timeVec [ 0 ]); return timeStep ; } template < class T > static TimeStep FindTimeStep ( const string & axisDefinition , const vector < T >& timeVec ) { TimeStep timeStep ; auto utstep = GetTimeUnitTimeStep ( ParseTimeUnits ( axisDefinition )); return FindTimeStep < T > ( utstep , timeVec ); } template < class T > TimeStep FindTimeStep ( const vector < T >& timeVec ) { TimeStep timeStep ; bool ignored = false ; return FindTimeStep < double > ( ignored , timeStep , timeVec ); } const int kDefaultStrLength = 30 ; static const string kTimeDimName ; static const string kStationDimName ; static const string kStrLenDimName ; static const string kLeadTimeDimName ; static const string kEnsMemberDimName ; static const string kTimeVarName ; static const string kLatVarName ; static const string kLonVarName ; static const string kElevationVarName ; static const string kStationNameVarName ; static const string kStationIdVarName ; static const string kLeadTimeVarName ; static const string kEnsMemberVarName ; // The following two may be used only as filtering out results of var names queries static const string kStrLenVarName ; static const string kStationVarName ; vector < string > ReservedVariableNames () const ; static const string kUnitsAttName ; static const string kStandardNameAttName ; static const string kLongNameAttName ; static const string kAxisAttName ; static const string kTypeAttName ; static const string kTypeDescriptionAttName ; static const string kDatTypeAttName ; static const string kDatDescriptionAttName ; static const string kLocationTypeAttName ; static const string kCatchmentAttName ; static const string kFillValueAttName ; static const string kGlobalAttNameTitle ; static const string kGlobalAttNameInstitution ; static const string kGlobalAttNameSource ; static const string kGlobalAttNameCatchment ; static const string kGlobalAttNameSTF_convention_version ; static const string kGlobalAttNameSTF_nc_spec ; static const string kGlobalAttNameComment ; static const string kGlobalAttNameHistory ; static const string kAttNameTimeStandard ; const double kDefaultFillValue = VariableAttributes :: DefaultFillValue (); void ReadGeometry (); void ReadGeometryDimensions (); void ReadGeometryVariables (); void WriteGeometry ( size_t nEns , const vector < double >& leadTimeVar , const string & timeUnits , const vector < double >& timeVar , const vector < string >& stationIds , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes , const string & leadTimeUnits = \"\" ); void DefineMandatoryDimensions ( size_t nEns , size_t nLead , size_t nStations ); void DefineDimVariables (); void DefineVariables (); void WriteCommonVarData (); int AddGlobalAttribute ( const string & attName , const string & attValue ); int AddGlobalAttribute ( const string & attName , double attValue ); int AddGlobalAttribute ( char * attName , char * attValue ); int AddAttribute ( int varId , const string & attName , const string & attValue ); int AddAttribute ( int varId , const string & attName , int attValue ); int AddAttribute ( int varId , const string & attName , double attValue ); void AddVariableAttributes ( int varId , const VariableAttributes & varAttributes ); void AddVariableAttributes ( int varId , const string & longName , const string & units , int type , const string & typeDescription , const string & datType , const string & datDescription , double fillValue , const string & locationType ); void AddAttributes ( int varId , const string & varName , std :: map < string , VariableAttributes >& varAttributes ); void FillAttributes ( const GlobalAttributes & globalAttributes , const string & timeUnits , const string & leadTimeUnits ); void SetTimeVar ( const vector < double >& timeVar ); void SetLeadTimeVar ( const vector < double >& leadTimeVar ); void InquireDimIds (); void InquireDimVarIds (); size_t InquireDimLength ( int dimId ); size_t GetNumDims ( const string & ncVarName ); void ReadTimeUnits (); vector < string > * GetStringVariable ( size_t strLen , int varId , size_t n ); nc_type GetDataType ( int variableId ); vector < int > ReadAsInt ( int varId , size_t size ); vector < float > ReadAsFloat ( int varId , size_t size , bool strict = true ); vector < double > ReadAsDouble ( int varId , size_t size ); void ErrorLossPrecision ( int varId ); /* template<class T> vector<T> GetVariable(int varId, size_t n) { if (varId < 0) return nullptr; T* result = new T[n]; int code = nc_get_var(ncid, varId, result); if (code != NC_NOERR) { delete[] result; return nullptr; } return result; } */ template < class T > void SetVariableDimOne ( int varId , T * values , size_t n ) { if ( values == nullptr ) ExceptionUtilities :: ThrowInvalidArgument ( \"SwiftNetCDFAccess::SetVariableDimOne: values cannot be a nullptr\" ); if ( n <= 0 ) ExceptionUtilities :: ThrowInvalidArgument ( \"SwiftNetCDFAccess::SetVariableDimOne: data size must be strictly positive\" ); //if (varId < 0) return nullptr; const size_t startp [ 1 ] = { 0 }; const size_t countp [ 1 ] = { ( size_t ) n }; int code = NcPutVara < T > ( ncid , varId , & ( startp [ 0 ]), & ( countp [ 0 ]), values ); if ( code != NC_NOERR ) { ExceptionUtilities :: ThrowInvalidOperation ( \"SetVariableDimOne failed for variable ID \" + std :: to_string ( varId )); } } template < class T > void SetVariableDimOne ( int varId , vector < T > values ) { SetVariableDimOne < T > ( varId , values . data (), values . size ()); } template < class T > vector < T > GetVariableDimOne ( int varId , size_t n ) { if ( n <= 0 ) ExceptionUtilities :: ThrowInvalidArgument ( \"SwiftNetCDFAccess::GetVariableDimOne: data size must be strictly positive\" ); //if (varId < 0) return nullptr; const size_t startp [ 1 ] = { 0 }; const size_t countp [ 1 ] = { ( size_t ) n }; T * values = new T [ n ]; int code = NcGetVara < T > ( ncid , varId , & ( startp [ 0 ]), & ( countp [ 0 ]), values ); if ( code != NC_NOERR ) { delete values ; ExceptionUtilities :: ThrowInvalidOperation ( \"SetVariableDimOne failed for variable ID \" + std :: to_string ( varId )); } vector < T > result = ToVector ( values , n ); delete values ; return result ; } template < class T , class TStored > vector < T > GetVariableDimOne ( int varId , size_t n ) { vector < T > result ( n ); vector < TStored > tmp = GetVariableDimOne < TStored > ( varId , n ); for ( int i = 0 ; i < n ; i ++ ) { result [ i ] = static_cast < T > ( tmp [ i ]); } return result ; } template < class T , class TStored > void SetVariable ( int varId , T * values , size_t n ) { if ( values == nullptr ) ExceptionUtilities :: ThrowInvalidArgument ( \"SwiftNetCDFAccess::SetVariable: values cannot be a nullptr\" ); TStored * tmp = new TStored [ n ]; for ( int i = 0 ; i < n ; i ++ ) { tmp [ i ] = static_cast < TStored > ( values [ i ]); } SetVariable < TStored > ( varId , tmp , n ); delete [] tmp ; } void GetEnsFcastNetcdfWindow ( const string & varName , size_t stationIndex , size_t timeIndex , vector < size_t >& startp , vector < size_t >& countp ); // void GetEnsNetcdfWindow(size_t stationIndex, vector<size_t>& startp, vector<size_t>& countp); void GetNetcdfWindow ( const string & varName , size_t stationIndex , vector < size_t >& startp , vector < size_t >& countp ); void GetNetcdfWindow ( const string & varName , vector < size_t >& startp , vector < size_t >& countp ); int GetVarId ( const string & varName ); double * GetForecastDataBuffer ( size_t numStations = 1 , size_t numTimeSteps = 1 ); double * GetEnsembleDataBuffer ( size_t numStations , size_t numTimeSteps ); double * GetSingleSeriesDataBuffer ( size_t numStations , size_t numTimeSteps ); int ncid = -1 ; int timeDimId , stationDimId , leadTimeDimId , ensMemberDimId , strLenDimId ; int timeVarId = -1 , stationNameVarId = -1 , stationIdVarId = -1 , leadTimeVarId = -1 , ensMemberVarId = -1 , latVarId = -1 , lonVarId = -1 , elevationVarId = -1 ; ptime startDate ; string timeUnits ; TimeStep timeStep ; TimeStep leadTimeStep ; bool cachedTimeStep = false ; bool cachedLeadTimeStep = false ; size_t /*numTimeSteps, */ numStations , strLen ; bool cachedTimeVector = false ; vector < ptime > ptimeVec ; vector < string > * stationNames = nullptr ; vector < string > * variableVarNames = nullptr ; // TODO suggest this is strings vector < int > stationIds ; vector < double > stationLat ; vector < double > stationLon ; vector < double > stationElevation ; vector < float > leadTimeVec /*= nullptr*/ ; size_t leadTimeLength ; vector < float > timeVec /*= nullptr*/ ; size_t numTimeSteps ; bool geometryRead = false ; vector < int > variableVarIds ; //int stepMultiplier ; size_t ensembleSize ; string catchmentName ; //vector<string> variableNames; //std::map<string, VariableAttributes> variableAttributes; std :: map < string , VariableDefinition > variableDefinitions ; }; class DATATYPES_DLL_LIB ConfigFileHelper { using string = std :: string ; private : ConfigFileHelper (); public : static const string FileKey ; static const string VarKey ; static const string IdentifierKey ; static const string IdDataKey ; static const string IndexKey ; static const string TypeKey ; static const string TimeStepKey ; static const string StartKey ; static const string LengthKey ; static const string EnsembleSizeKey ; static const string EnsembleLengthKey ; static const string EnsembleTimeStepKey ; static const string FilePatternKey ; static const string MappingKey ; static const string StorageKey ; static const string SingleSeriesTypeId ; static const string EnsembleSeriesTypeId ; static const string TimeSeriesEnsemblesTypeId ; static const string SingleSeriesCollectionTypeId ; static const string StorageTypeSingleNetcdfFile ; static const string StorageTypeMultipleNetcdfFiles ; static TimeSeriesLibraryDescription LoadTimeSeriesLibraryDescription ( const string & filename , const string & dataPath = \"\" , TimeSeriesSourceInfoBuilder * srcBuilder = nullptr ); static void SaveTimeSeriesLibraryDescription ( const TimeSeriesLibraryDescription & config , const string & filename ); static string FileName ( const YAML :: Node & storage ); static string FullFileName ( const YAML :: Node & storage , const TimeSeriesLibraryDescription & tsl ); private : static bool PreCheckStorageType ( const string & storageType , TimeSeriesSourceInfoBuilder * srcBuilder = nullptr ); }; } using namespace datatypes :: timeseries :: io ; template < typename TElement > DimensionsDefinitions DimensionsFromPointTimeSeries ( const TTimeSeries < TElement >& ts ) { string timeUnits = SwiftNetCDFAccess :: CreateTimeUnitsAttribute ( ts . GetStartDate (), ts . GetTimeStep ()); auto timeVar = datatypes :: utils :: SeqVec < double > ( 0 , 1 , ts . GetLength ()); return DimensionsDefinitions ( timeUnits , timeVar ); } //template <typename T> //class DATATYPES_DLL_LIB NetCdfSingleSeriesStore //{ // // //public: // /** // * \\brief Constructor. // * // * \\param [in] dataAccess SWIFT netCDF data access object to read/write the back end file. // * \\param varName Name of the variable for this time series (the netCDF back end may have several variables). // * \\param identifier The identifier. // */ // NetCdfSingleSeriesStore(SwiftNetCDFAccess * dataAccess, const string& varName, const string& identifier) // { // this->dataAccess = dataAccess; // this->varName = varName; // this->identifier = identifier; // this->stationIndex = this->GetNcAccess()->IndexForIdentifier(identifier); // } // /** // * \\brief Gets the ensemble forecast for a given index in the time dimension // * // * \\param i Zero-based index of the time step of interest. // * // * \\return a pointer to a new MultiTimeSeries. // */ // MultiTimeSeries<TimeSeries*> * GetForecasts(int i) // { // auto series = this->GetNcAccess()->GetForecasts<T>(varName, stationIndex, i); // auto result = new MultiTimeSeries<TimeSeries*>(*series, this->GetLeadTimeCount(), this->GetNcAccess()->TimeForIndex(i), this->GetTimeStep()); // for (auto& d : (*series)) // { // if (d != nullptr) delete[] d; // } // delete series; // return result; // } // /** // * \\brief Gets a non-ensemble time series. There must be such a record, otherwise an exception is thrown. // * // * \\return null if it fails, else the series. // */ // TTimeSeries<T> * GetSeries() // { // auto values = this->GetNcAccess()->GetValues<T>(varName, stationIndex); // auto result = new TTimeSeries<T>(values, this->GetTimeLength(), this->TimeForIndex(0), this->GetTimeStep()); // delete values; // return result; // } // MultiTimeSeries<TimeSeries*> * GetEnsembleSeries() // { // auto series = this->GetNcAccess()->GetEnsemble<T>(varName, stationIndex); // auto result = new MultiTimeSeries<TimeSeries*>(*series, this->GetTimeLength(), this->TimeForIndex(0), this->GetTimeStep()); // for (auto& d : (*series)) // { // if (d != nullptr) delete[] d; // } // delete series; // return result; // } // void SetForecasts(int i, MultiTimeSeries<TimeSeries*> * forecasts) // { // this->GetNcAccess()->WriteForecastsVarData(); // auto values = forecasts->GetValues(); // this->GetNcAccess()->SetForecasts(varName, stationIndex, i, (*values)); // for (auto& d : (*values)) // { // if (d != nullptr) delete[] d; // } // delete values; // } // void SetEnsemble(MultiTimeSeries<TimeSeries*> * ensemble) // { // this->GetNcAccess()->WriteEnsembleVarData(); // vector<T*>* values = ensemble->GetValues(); // this->GetNcAccess()->SetEnsembles(varName, stationIndex, *values); // for (T* data : *values) // if (data != nullptr) delete[] data; // delete values; // } // void SetSeries(TTimeSeries<T> * timeSeries) // { // this->GetNcAccess()->WriteSingleSeriesVarData(); // T* values = timeSeries->GetValues(); // this->GetNcAccess()->SetValues(varName, stationIndex, values); // delete[] values; // } // int GetEnsembleSize() // { // return this->GetNcAccess()->GetEnsembleSize(varName); // } // int GetLeadTimeCount() // { // return this->GetNcAccess()->GetLeadTimeCount(varName); // } // int GetTimeLength() // { // return this->GetNcAccess()->GetTimeLength(); // } // TimeStep GetTimeStep() // { // return this->GetNcAccess()->GetTimeStep(); // } // ptime TimeForIndex(size_t timeIndex) // { // return this->GetNcAccess()->TimeForIndex(timeIndex); // } //private: // SwiftNetCDFAccess * dataAccess = nullptr; // string varName; // string identifier; // size_t stationIndex; //}; //template <typename T = double> //class DATATYPES_DLL_LIB NetCdfSingleSeriesStoreStore //{ // // //public: // /** // * \\brief Create a wrapper time series store around an existing SWIFT netCDF file. // * // * \\param filename Filename of the file. // */ // NetCdfSingleSeriesStoreStore(const string& filename) // { // dataAccess = new SwiftNetCDFAccess(filename); // } // /** // *\\brief Constructor to create a new SWIFT netCDF file // * // * \\param filename name of the new file to create. // * \\param nEns Size of the ensembles // * \\param nLead Length of the lead time for each of the time series in the ensemble forecast for a given time. // * \\param timeUnits Units of the temporal dimension(s). // * \\param[in] timeVar The values of the \"main\" time dimension, consistent with the temporal units given with the previous parameter // * \\param[in] stationIds List of identifiers for the stations. // * \\param[in] varNames List of names of the variables. // * \\param[in] varAttributes Attributes for each variables; the keys of the dictionary must be found in the varNames parameter. // */ // NetCdfSingleSeriesStoreStore(const string& filename, size_t nEns, size_t nLead, const string& timeUnits, vector<double>& timeVar, vector<string>& stationIds, vector<string>& varNames, // std::map<string, VariableAttributes>& varAttributes = std::map<string, VariableAttributes>()) // { // dataAccess = new SwiftNetCDFAccess(filename, nEns, nLead, timeUnits, timeVar, stationIds, varNames, varAttributes); // } // ~NetCdfSingleSeriesStoreStore() // { // Close(); // } // void Close() // { // if (dataAccess != nullptr) // { // delete dataAccess; // dataAccess = nullptr; // } // } // /** // * \\brief Create an univariate SWIFT netCDF time series using this netCDF time series store. // * // * \\param varName Name of the variable. // * \\param identifier The identifier; e.g. a catchment identifier. // * \\param dimIdent (Optional) name of the dimension in which to look for the location identifier (e.g. catchment identifier). Defaults to 'station_id' as per SWIFT netCDF schema // * \\param startTime (Optional) the start time. If null (default), the start time of the whole data set is used. // * \\param leadTimeCount (Optional) number of lead times to read. If negative (default), the maximum number of lead times returned by GetLeadTimeCount() // * // * \\return null if it fails, else a NetCdfSingleSeriesStore&lt;T&gt;*. // */ // NetCdfSingleSeriesStore<T> * Get(const string& varName, const string& identifier, const string& dimIdent = \"station_id\", const ptime* startTime = nullptr, int leadTimeCount = -1) // { // return new NetCdfSingleSeriesStore<T>(dataAccess, varName, identifier); // } // //void Set(NetCdfSingleSeriesStore<T> * series, const string& varName, const string& identifier, const string& dimIdent = \"station_id\", const ptime* startTime = nullptr, int leadTimeCount = -1); //private: // SwiftNetCDFAccess * dataAccess = nullptr; //}; template < typename T > class DATATYPES_DLL_LIB TimeSeriesIOHelper { public : using SeriesType = typename CommonTypes < T >:: SeriesType ; using PtrSeriesType = typename CommonTypes < T >:: PtrSeriesType ; using EnsemblePtrType = typename CommonTypes < T >:: EnsemblePtrType ; using PtrEnsemblePtrType = typename CommonTypes < T >:: PtrEnsemblePtrType ; using TSeriesEnsemblePtrType = typename CommonTypes < T >:: TSeriesEnsemblePtrType ; using PtrTSeriesEnsemblePtrType = typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType ; static SeriesType * Read ( const string & netCdfFilePath , const string & varName , const string & identifier ); static void Write ( const string & varName , std :: map < string , TTimeSeries < T >*>& recordedTimeSeries , const std :: map < string , string >& idMap , const string & filePath ); static void Write ( DimensionsDefinitions & dimDefinitions , const map < std :: string , VariableDefinition >& varDefinitions , const GlobalAttributes & GlobalAttributes , std :: map < string , TTimeSeries < T >*>& recordedTimeSeries , const string & filePath ); static PtrEnsemblePtrType ReadForecastTimeSeries ( const string & netCdfFilepath , const string & varName , const string & identifier , int index ); static PtrTSeriesEnsemblePtrType ReadForecastTimeSeries ( const string & netCdfFilepath , const string & varName , const string & identifier ); static SeriesType * Read ( const string & netCdfFilePath , const string & varName , const string & identifier , const TimeWindow < SeriesType >& window ) { auto tmp = Read ( netCdfFilePath , varName , identifier ); auto result = window . Trim ( * tmp ); delete tmp ; return result ; } static SeriesType * ReadDailyToHourly ( const string & netCdfFilePath , const string & varName , const string & identifier , const TimeWindow < SeriesType >& window ) { TTimeSeries < T >* fullDailyObsPetTimeSeries = Read ( netCdfFilePath , varName , identifier ); TTimeSeries < T >* fullHourlyObsPetTimeSeries = TimeSeriesOperations < SeriesType >:: DailyToHourly ( * fullDailyObsPetTimeSeries ); auto result = window . Trim ( * fullHourlyObsPetTimeSeries ); delete fullDailyObsPetTimeSeries ; delete fullHourlyObsPetTimeSeries ; return result ; } }; template < typename T > class /*DATATYPES_DLL_LIB*/ SingleNetCdfFileStore { private : string ncVarName ; string identifier ; SwiftNetCDFAccess * dataAccess = nullptr ; string fileName ; protected : SingleNetCdfFileStore () {} SingleNetCdfFileStore ( const string & fname , const size_t nEns , const vector < double >& leadTimeVar , const string & timeUnits , const vector < double >& timeVar , const vector < string >& stationIds , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName = \"\" , const string & identifier = \"\" , const string & leadTimeUnits = \"\" ) : ncVarName ( ncVarName ), identifier ( identifier ), fileName ( fname ) { dataAccess = new SwiftNetCDFAccess ( fname , nEns , leadTimeVar , timeUnits , timeVar , stationIds , varDefinitions , globalAttributes , leadTimeUnits ); } SingleNetCdfFileStore ( const string & fname , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName = \"\" , const string & identifier = \"\" ) : ncVarName ( ncVarName ), identifier ( identifier ), fileName ( fname ) { dataAccess = new SwiftNetCDFAccess ( fname , dimDefinitions , varDefinitions , globalAttributes ); } SingleNetCdfFileStore ( const string & fname , const string & ncVarName = \"\" , const string & identifier = \"\" , bool writeMode = false ) : ncVarName ( ncVarName ), identifier ( identifier ), fileName ( fname ) { if ( ! writeMode ) dataAccess = new SwiftNetCDFAccess ( fname ); } void Init ( const string & filename , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes ) { if ( dataAccess != nullptr ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"netCDF single file store already bound to a netCDF file\" ); dataAccess = new SwiftNetCDFAccess ( filename , dimDefinitions , varDefinitions , globalAttributes ); } void MoveFrom ( SingleNetCdfFileStore & src ) { std :: swap ( dataAccess , src . dataAccess ); std :: swap ( fileName , src . fileName ); std :: swap ( identifier , src . identifier ); std :: swap ( ncVarName , src . ncVarName ); } void CopyFrom ( const SingleNetCdfFileStore & src ) { ExceptionUtilities :: ThrowNotSupported ( \"Deep copy operations are not supported\" ); } string GetNcVarName ( bool allowDiscovery = true ) const { string varName = ncVarName ; const bool removeReservedVarnames = true ; if ( varName . empty () && allowDiscovery ) { vector < string > v = this -> GetNcAccess () -> ReadVariableNames ( removeReservedVarnames ); if ( v . size () == 1 ) varName = v [ 0 ]; else if ( v . size () > 1 ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation (); else if ( v . empty ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation (); } return varName ; } string DataSummaryForIdentifier () const { if ( identifier . empty ()) return string ( \", identifier: <NA>\" ); else return string ( \", identifier: \" ) + this -> GetIdentifier (); } string GetDefaultDataSummary () const { auto start = this -> GetStart (); auto end = this -> GetEnd (); string result = string ( \"variable name: \" ) + this -> GetNcVarName () + DataSummaryForIdentifier () + string ( \", start: \" ) + to_iso_extended_string ( start ) + string ( \", end: \" ) + to_iso_extended_string ( end ) + string ( \", time length: \" ) + std :: to_string ( this -> GetNcAccess () -> GetTimeLength ()) + string ( \", time step: \" ) + this -> GetNcAccess () -> GetTimeStep (). GetName (); return result ; } size_t IndexForIdentifier ( bool strict = true ) const { if ( identifier . empty ()) { if ( strict ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"This netCDF data provider does not have a unique identifier (station ID)\" ); } // TODO: reassess how to deal with it, if really acceptable if ( GetNcAccess () -> GetNumIdentifiers () == 1 ) return 0 ; } return IndexForIdentifier ( this -> identifier ); } virtual bool HasIdentifier () const { return ( ! identifier . empty ()); } virtual string GetIdentifier ( bool strict = true ) const { if ( identifier . empty ()) { if ( strict ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"This netCDF data provider does not have a unique identifier (station ID)\" ); } // TODO: reassess how to deal with it, if really acceptable if ( GetNcAccess () -> GetNumIdentifiers () == 1 ) { auto ids = GetIdentifiers (); if ( ids . size () == 1 ) return ids [ 0 ]; datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"Inconsistency between netCDF claimed number of identifiers and retrieved list\" ); } } return this -> identifier ; } void SetIdentifier ( string ident ) { this -> identifier = ident ; } virtual vector < string > GetIdentifiers () const { if ( identifier . empty ()) { // TODO: reassess how to deal with it, if really acceptable return GetNcAccess () -> GetIdentifiers (); } else return vector < string > ({ this -> identifier }); } SwiftNetCDFAccess * GetNcAccess () const { if ( dataAccess == nullptr ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"The low level swift netCDF data access is a nullptr\" ); return dataAccess ; } string & GetFileName () { return fileName ; } public : virtual ~ SingleNetCdfFileStore () { Close (); } virtual void Close () { if ( dataAccess != nullptr ) { delete dataAccess ; dataAccess = nullptr ; } } bool HasNcAccess () { return ( dataAccess != nullptr ); } size_t GetEnsembleSize () const { auto v = GetNcVarName ( false ); if ( v . empty ()) return this -> GetNcAccess () -> GetEnsembleSize (); return this -> GetNcAccess () -> GetEnsembleSize ( this -> GetNcVarName ()); } size_t GetLeadTimeCount () const { auto v = GetNcVarName ( false ); if ( v . empty ()) return this -> GetNcAccess () -> GetLeadTimeCount (); return this -> GetNcAccess () -> GetLeadTimeCount ( this -> GetNcVarName ()); } size_t GetTimeLength () const { return this -> GetNcAccess () -> GetTimeLength (); } TimeStep GetTimeStep () const { return this -> GetNcAccess () -> GetTimeStep (); } ptime TimeForIndex ( size_t timeIndex ) const { return this -> GetNcAccess () -> TimeForIndex ( timeIndex ); } vector < ptime > GetTimeDim () const { return this -> GetNcAccess () -> GetTimeDim (); } vector < double > GetLeadTimeDim () const { return this -> GetNcAccess () -> GetLeadTimeDim (); } ptime GetStart () const { return this -> GetNcAccess () -> GetStart (); } ptime GetEnd () const { return this -> GetNcAccess () -> GetEnd (); } size_t IndexForIdentifier ( const string & identifier ) const { return this -> GetNcAccess () -> IndexForIdentifier ( identifier ); } //vector<string> GetIdentifiers() const //{ // return this->GetNcAccess()->GetIdentifiers(); //} VariableAttributes GetVarAttributes () { std :: string ncVarName = GetNcVarName (); return this -> GetNcAccess () -> GetAttributes ( ncVarName ); } GlobalAttributes GetGlobalAttributes () { return this -> GetNcAccess () -> GetGlobalAttributes (); } }; template < typename T > class /*DATATYPES_DLL_LIB*/ NetCdfSingleSeriesStore : public SingleTimeSeriesStore < T > , public SingleNetCdfFileStore < T > { // public : NetCdfSingleSeriesStore ( const string & filename , const size_t nEns , const vector < double >& leadTimeVar , const string & timeUnits , const vector < double >& timeVar , const vector < string >& stationIds , const std :: map < string , VariableDefinition >& varDefinitions , const string & ncVarName , const string & identifier = \"\" , const string & leadTimeUnits = \"\" ) : SingleNetCdfFileStore < T > ( filename , nEns , leadTimeVar , timeUnits , timeVar , stationIds , varDefinitions , ncVarName , identifier , leadTimeUnits ) { } NetCdfSingleSeriesStore ( const string & filename , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName , const string & identifier = \"\" ) : SingleNetCdfFileStore < T > ( filename , dimDefinitions , varDefinitions , globalAttributes , ncVarName , identifier ) { } NetCdfSingleSeriesStore ( const string & fname ) : SingleNetCdfFileStore < T > ( fname ) { } NetCdfSingleSeriesStore ( const string & fname , const string & ncVarName , const string & identifier = \"\" ) : SingleNetCdfFileStore < T > ( fname , ncVarName , identifier ) { } NetCdfSingleSeriesStore & operator = ( NetCdfSingleSeriesStore && src ) { // Avoid self assignment if ( & src == this ) { return * this ; } SingleNetCdfFileStore < T >:: MoveFrom ( src ); return * this ; } NetCdfSingleSeriesStore & operator = ( const NetCdfSingleSeriesStore & src ) { if ( & src == this ) { return * this ; } SingleNetCdfFileStore < T >:: CopyFrom ( src ); return * this ; } NetCdfSingleSeriesStore ( NetCdfSingleSeriesStore && src ) { * this = src ; } NetCdfSingleSeriesStore ( const NetCdfSingleSeriesStore & src ) { * this = src ; } static string Dimensions () { return \"2\" ; } string GetDataSummary () const { return SingleNetCdfFileStore < T >:: GetDefaultDataSummary (); } vector < DataDimensionDescriptor > GetDataDimensionsDescription () const { vector < DataDimensionDescriptor > d ; if ( ! this -> HasIdentifier ()) d . push_back ( DataDimensionDescriptor ( COLLECTION_DIM_TYPE_DATA_DIMENSION )); d . push_back ( DataDimensionDescriptor ( TIME_DIM_TYPE_DATA_DIMENSION )); return d ; } TTimeSeries < T >* Read () { return Read ( this -> GetIdentifier ()); } TTimeSeries < T >* Read ( const string & identifier ) { if ( identifier == string ( \"\" )) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"Cannot get a time series if no identifier is provided.\" ); int index = static_cast < int > ( this -> IndexForIdentifier ( identifier )); if ( index < 0 ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"Index not found for data identifier: \" + identifier ); // Need to disambiguate the call to the template method GetSeries for GCC, somehow. Even if this does not look ambiguous. // See e.g. http://stackoverflow.com/questions/15572415/expected-primary-expression-before-in-g-but-not-in-microsoft-compiler return this -> GetNcAccess () -> template GetSeries < T > ( this -> GetNcVarName (), index ); } MultiTimeSeries < TTimeSeries < T >*>* ReadAllCollection () { MultiTimeSeries < TTimeSeries < T >*>* result = new MultiTimeSeries < TTimeSeries < T >*> (); // Need to disambiguate the call to the template method GetSeries for GCC, somehow. Even if this does not look ambiguous. // See e.g. http://stackoverflow.com/questions/15572415/expected-primary-expression-before-in-g-but-not-in-microsoft-compiler return this -> GetNcAccess () -> template GetSeries < T > ( this -> GetNcVarName ()); } void Write ( TTimeSeries < T > * timeSeries ) { vector < T > values = timeSeries -> GetValuesVector (); this -> GetNcAccess () -> template SetValues < T > ( this -> GetNcVarName (), this -> IndexForIdentifier (), values ); } vector < TTimeSeries < T >*> ReorderPerIdentifier ( const std :: map < string , TTimeSeries < T >*>& toSave ) { vector < string > ids = this -> GetNcAccess () -> GetIdentifiers (); return datatypes :: utils :: STLHelper :: SortValues ( toSave , ids ); } vector < T > Serialize ( const vector < TTimeSeries < T >*>& series ) { vector < vector < T >> v ; for ( size_t i = 0 ; i < series . size (); i ++ ) { v . push_back ( series [ i ] -> GetValuesVector ()); } return datatypes :: utils :: STLHelper :: Serialize ( v ); } void WriteToIdentifiers ( const std :: map < string , TTimeSeries < T >*>& toSave ) { vector < TTimeSeries < T >*> series = ReorderPerIdentifier ( toSave ); vector < T > values = Serialize ( series ); this -> GetNcAccess () -> template SetValues < T > ( this -> GetNcVarName (), values ); } void WriteToNcVariables ( const std :: map < string , TTimeSeries < T >*>& toSave ) { for ( auto & kvp : toSave ) { TTimeSeries < T >* ptr = kvp . second ; if ( ptr != nullptr ) this -> GetNcAccess () -> template SetValues < T > ( kvp . first , 0 , ptr -> GetValuesVector ()); } } vector < string > GetIdentifiers () const { return SingleNetCdfFileStore < T >:: GetIdentifiers (); vector < string > x = { SingleNetCdfFileStore < T >:: GetIdentifier () }; return x ; } }; template < typename T > class /*DATATYPES_DLL_LIB*/ NetCdfEnsembleTimeSeriesStore : public EnsembleTimeSeriesStore < T > , public SingleNetCdfFileStore < T > { // public : NetCdfEnsembleTimeSeriesStore ( const string & filename , const size_t nEns , const vector < double >& leadTimeVar , const string & timeUnits , const vector < double >& timeVar , const vector < string >& stationIds , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName , const string & identifier = \"\" , const string & leadTimeUnits = \"\" ) : SingleNetCdfFileStore < T > ( filename , nEns , leadTimeVar , timeUnits , timeVar , stationIds , varDefinitions , globalAttributes , ncVarName , identifier , leadTimeUnits ) { } NetCdfEnsembleTimeSeriesStore ( const string & filename , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName , const string & identifier = \"\" ) : SingleNetCdfFileStore < T > ( filename , dimDefinitions , varDefinitions , globalAttributes , ncVarName , identifier ) { } NetCdfEnsembleTimeSeriesStore ( const string & fname , const string & ncVarName , const string & identifier = \"\" ) : SingleNetCdfFileStore < T > ( fname , ncVarName , identifier ) { } static string Dimensions () { return DATATYPES_THREE_DIMENSIONS_DATA ; } string GetDataSummary () const { return SingleNetCdfFileStore < T >:: GetDefaultDataSummary (); } vector < DataDimensionDescriptor > GetDataDimensionsDescription () const { return { DataDimensionDescriptor ( ENSEMBLE_DIM_TYPE_DATA_DIMENSION ), DataDimensionDescriptor ( TIME_DIM_TYPE_DATA_DIMENSION ) }; } vector < string > GetIdentifiers () const { return SingleNetCdfFileStore < T >:: GetIdentifiers (); vector < string > x = { SingleNetCdfFileStore < T >:: GetIdentifier () }; return x ; } MultiTimeSeries < TTimeSeries < T >*>* Read () { return this -> GetNcAccess () -> template GetEnsembleSeries < T > ( this -> GetNcVarName (), this -> IndexForIdentifier ()); } void Write ( MultiTimeSeries < TTimeSeries < T >*> * ensemble ) { size_t stationIndex = this -> IndexForIdentifier (); vector < T *>* values = ensemble -> GetValues (); this -> GetNcAccess () -> SetEnsembles ( this -> GetNcVarName (), stationIndex , * values ); for ( T * data : * values ) if ( data != nullptr ) delete [] data ; delete values ; } }; template < typename StorageType > class EagerWriter : public StoragePolicy < StorageType > { public : using EnsemblePtrType = typename TimeSeriesEnsembleTimeSeriesStore < double >:: EnsemblePtrType ; using PtrEnsemblePtrType = StorageType ; using ElementType = typename EnsemblePtrType :: ElementType ; using TsType = EnsemblePtrType :: ItemType ; private : vector < PtrEnsemblePtrType > ensemblesProxies ; WritableTimeSeriesEnsembleTimeSeriesStore < ElementType > * store ; void resetProxies () { if ( store -> IsActive ()) resetProxies ( store -> GetLength ()); } void resetProxies ( size_t length ) { for ( size_t i = 0 ; i < ensemblesProxies . size (); i ++ ) { PtrEnsemblePtrType ptr = ensemblesProxies [ i ]; if ( ptr != nullptr ) delete ptr ; } ensemblesProxies . assign ( length , nullptr ); } public : EagerWriter ( WritableTimeSeriesEnsembleTimeSeriesStore < ElementType > * store ) { if ( store == nullptr ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"store must not be nullptr for an EagerWriter\" ); this -> store = store ; resetProxies (); } EagerWriter ( const EagerWriter & src ) { this -> store = src . store ; resetProxies (); } bool ReadOnly () override { return ! store -> IsActive (); } size_t Size () const { return store -> GetLength (); } void Allocate ( size_t length , PtrEnsemblePtrType value ) { store -> Allocate ( length , value ); resetProxies (); } void AllocateValues ( size_t length , const PtrEnsemblePtrType * values ) { store -> AllocateValues ( length , values ); resetProxies (); } void AllocateValues ( const vector < PtrEnsemblePtrType >& values ) { store -> AllocateValues ( values ); resetProxies (); } void CopyTo ( vector < PtrEnsemblePtrType >& dest , size_t from = 0 , size_t to = -1 ) const { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); //CheckIntervalBounds(from, to); //size_t len = (to - from) + 1; //if (dest.size() != len) //{ // dest.clear(); // dest.resize(len); //}; //for (size_t i = 0; i < len; i++) //{ // dest[i] = (data[i] == nullptr ? store.ReadAt(i) : data[i]); //} } private : void CheckDataItemRange ( const size_t i ) const { datatypes :: exceptions :: ExceptionUtilities :: CheckInRange < size_t > ( i , 0 , store -> GetLength (), \"index\" ); } public : PtrEnsemblePtrType & GetProxy ( const size_t i ) { CheckDataItemRange ( i ); auto proxy = ensemblesProxies [ i ]; if ( proxy == nullptr ) { auto s = new TimeSeriesEnsembleTimeSeriesStoragePolicy < TsType > ( store , i ); proxy = new EnsemblePtrType ( s ); ensemblesProxies [ i ] = proxy ; } return ensemblesProxies [ i ]; } PtrEnsemblePtrType & operator []( const size_t i ) { return GetProxy ( i ); } private : PtrEnsemblePtrType dummy ; // to compile... public : const PtrEnsemblePtrType & operator []( const size_t i ) const { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented ( \"Not sure how to implement this, if at all possible, sorry\" ); return dummy ; // to compile... } StoragePolicy < PtrEnsemblePtrType >* Clone () const { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotSupported ( \"EagerWriter\" , \"Clone\" ); return nullptr ; } size_t GetLength () const { return store -> GetLength (); } TimeStep GetTimeStep () const override { return store -> GetTimeStep (); } ptime GetStart () const override { return store -> GetStart (); } void SetTimeStep ( const TimeStep & tStep ) override { store -> SetTimeStep ( tStep ); } void SetStart ( const ptime & start ) override { store -> SetStart ( start ); } }; template < typename T = double > class /*DATATYPES_DLL_LIB*/ NetCdfTimeSeriesEnsembleTimeSeriesStore : public WritableTimeSeriesEnsembleTimeSeriesStore < T > , public SingleNetCdfFileStore < T > { public : NetCdfTimeSeriesEnsembleTimeSeriesStore ( const string & filename , const size_t nEns , const vector < double >& leadTimeVar , const string & timeUnits , const vector < double >& timeVar , const vector < string >& stationIds , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName , const string & identifier = \"\" ) : SingleNetCdfFileStore < T > ( filename , nEns , leadTimeVar , timeUnits , timeVar , stationIds , varDefinitions , globalAttributes , ncVarName , identifier ) { } NetCdfTimeSeriesEnsembleTimeSeriesStore ( const string & filename , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName , const string & identifier = \"\" ) : SingleNetCdfFileStore < T > ( filename , dimDefinitions , varDefinitions , globalAttributes , ncVarName , identifier ) { } NetCdfTimeSeriesEnsembleTimeSeriesStore ( const string & fname , const string & ncVarName , const string & varIdentifier , bool writeMode = false ) : SingleNetCdfFileStore < T > ( fname , ncVarName , varIdentifier , writeMode ) { } static string Dimensions () { return DATATYPES_FOUR_DIMENSIONS_DATA ; } using SeriesType = typename CommonTypes < T >:: SeriesType ; using PtrSeriesType = typename CommonTypes < T >:: PtrSeriesType ; using EnsemblePtrType = typename CommonTypes < T >:: EnsemblePtrType ; using PtrEnsemblePtrType = typename CommonTypes < T >:: PtrEnsemblePtrType ; using TSeriesEnsemblePtrType = typename CommonTypes < T >:: TSeriesEnsemblePtrType ; using PtrTSeriesEnsemblePtrType = typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType ; using ElementType = typename EnsemblePtrType :: ElementType ; private : EnsembleForecastTimeSeries < TTimeSeries < T > >* ReadSeriesFromFile ( const string & dataId ) { EnsembleForecastTimeSeries < TTimeSeries < T >>* result ; size_t dataLength = this -> GetLength (); ptime start = this -> GetStart (); TimeStep step = this -> GetTimeStep (); result = new EnsembleForecastTimeSeries < TTimeSeries < T >> ( dataLength , start , step ); for ( size_t i = 0 ; i < dataLength ; i ++ ) { auto rawTs = this -> GetForecasts ( i ); result -> SetValue ( i , rawTs ); } return result ; } EnsembleForecastTimeSeries < SeriesType >* CreateWriteProxy ( const string & dataId ) { StoragePolicy < PtrEnsemblePtrType > * s = new EagerWriter < PtrEnsemblePtrType > ( this ); return new EnsembleForecastTimeSeries < SeriesType > ( s ); } public : virtual EnsembleForecastTimeSeries < TTimeSeries < T > >* GetSeries ( const string & dataId ) { EnsembleForecastTimeSeries < TTimeSeries < T >>* result ; if ( this -> HasNcAccess ()) result = ReadSeriesFromFile ( dataId ); else result = CreateWriteProxy ( dataId ); return result ; } vector < string > GetIdentifiers () const { return SingleNetCdfFileStore < T >:: GetIdentifiers (); vector < string > x = { SingleNetCdfFileStore < T >:: GetIdentifier () }; return x ; } void SetIdentifier ( string ident ) { SingleNetCdfFileStore < T >:: SetIdentifier ( ident ); } PtrEnsemblePtrType GetForecasts ( size_t i ) { size_t stationIndex = this -> IndexForIdentifier ( false ); auto nc = this -> GetNcAccess (); ptime issueTime = GetTimeForIndex ( i ); std :: pair < ptime , TimeStep > fcastGeom = nc -> GetLeadTimeGeometry ( issueTime ); vector < ElementType *>* series = nc -> template GetForecasts < T > ( this -> GetNcVarName (), stationIndex , i ); auto result = new EnsemblePtrType ( * series , this -> GetLeadTimeCount (), fcastGeom . first , fcastGeom . second ); for ( auto & d : ( * series )) { if ( d != nullptr ) delete [] d ; } delete series ; return result ; } void SetForecasts ( size_t i , MultiTimeSeries < TimeSeries *> * forecasts ) { size_t stationIndex = this -> IndexForIdentifier ( false ); auto values = forecasts -> GetValues (); this -> GetNcAccess () -> SetForecasts ( this -> GetNcVarName (), stationIndex , i , ( * values )); for ( auto & d : ( * values )) { if ( d != nullptr ) delete [] d ; } delete values ; } virtual ~ NetCdfTimeSeriesEnsembleTimeSeriesStore () { if ( indexForTime != nullptr ) { delete indexForTime ; indexForTime = nullptr ; } if ( timeForIndex != nullptr ) { delete timeForIndex ; timeForIndex = nullptr ; } }; MultiTimeSeries < TTimeSeries < T >*>* Read ( const string & ensembleIdentifier ) override { char * end ; const char * q = ensembleIdentifier . c_str (); size_t index = -1 ; ptime dateIndex = TimeStep :: PtimeFromIsoString ( ensembleIdentifier ); if ( dateIndex == not_a_date_time ) { index = ( int ) std :: strtol ( q , & end , 10 ); const char * r = q + ensembleIdentifier . size () * sizeof ( char * ); if ( end == q || end != r ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"Could not parse as integer or a (ptime) date specification: \" + ensembleIdentifier ); } } else { index = GetIndexForTime ( dateIndex ); } // check on index validity // datatypes::exceptions::ExceptionUtilities::ThrowInvalidArgument( return GetForecasts ( index ); } size_t GetIndexForTime ( const ptime & dateIndex ) { if ( indexForTime == nullptr ) { vector < ptime > p = this -> GetNcAccess () -> GetTimeDim (); indexForTime = new std :: map < ptime , size_t > (); for ( size_t i = 0 ; i < p . size (); i ++ ) { ( * indexForTime )[ p [ i ]] = i ; } } return indexForTime -> at ( dateIndex ); } ptime GetTimeForIndex ( size_t index ) { if ( timeForIndex == nullptr ) { timeForIndex = new std :: vector < ptime > ( this -> GetNcAccess () -> GetTimeDim ()); } return ( * timeForIndex )[ index ]; } //vector<string> GetItemIdentifiers() const //{ // vector<ptime> times = this->GetNcAccess()->GetTimeDim(); // std::function<string(const ptime&)> f = [&](const ptime& p) { return boost::posix_time::to_iso_string(p); }; // return SwiftNetCDFAccess::Convert<ptime, string>(times, f); //} size_t GetLength () const { return this -> GetNcAccess () -> GetTimeLength (); } TimeStep GetTimeStep () const { // TODO: returning this->GetNcAccess()->GetTimeStep() is adequeate for // SWIFT netCDF specs v1, not the most recent return this -> GetNcAccess () -> GetTimeStep (); } TimeStep GetLeadTimeStep () const { return this -> GetNcAccess () -> GetLeadTimeStep (); } ptime GetStart () const { vector < ptime > times = this -> GetNcAccess () -> GetTimeDim (); return times [ 0 ]; } ptime GetEnd () const { vector < ptime > times = this -> GetNcAccess () -> GetTimeDim (); return times [ times . size () -1 ]; } string GetDataSummary () const { return SingleNetCdfFileStore < T >:: GetDefaultDataSummary (); } vector < DataDimensionDescriptor > GetDataDimensionsDescription () const { return { DataDimensionDescriptor ( TIME_DIM_TYPE_DATA_DIMENSION ), DataDimensionDescriptor ( ENSEMBLE_DIM_TYPE_DATA_DIMENSION ), DataDimensionDescriptor ( TIME_DIM_TYPE_DATA_DIMENSION ) }; } using WritableTimeSeriesEnsembleTimeSeriesStore < T >:: GetEnsembleSize ; using SingleNetCdfFileStore < T >:: GetEnsembleSize ; void Allocate ( size_t length , PtrEnsemblePtrType value ) { vector < PtrEnsemblePtrType > v ( length ); v . assign ( length , value ); AllocateValues ( v ); } void AllocateValues ( const vector < PtrEnsemblePtrType >& values ) { if ( IsActive ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"This netCDF store is already initialised and active\" ); DimensionsDefinitions dimDef = DimensionsFromSeries < T > ( values ); string ncVarname ( this -> GetNcVarName ()); string longName = \"<NA>\" ; string units = \"\" ; double fillValue = DEFAULT_MISSING_DATA_VALUE ; int type = 9 ; string typeDescription = \"<NA>\" ; string datType = \"<NA>\" ; string datDescription = \"<NA>\" ; map < string , VariableDefinition > v ; v [ ncVarname ] = VariableDefinition ( ncVarname , DATATYPES_DOUBLE_PRECISION_ID , Dimensions (), longName , units , fillValue , type , typeDescription , datType , datDescription , \"Point\" ); GlobalAttributes globAtts = GlobalAttributes :: CreateDefault (); SingleNetCdfFileStore < T >:: Init ( this -> GetFileName (), dimDef , v , globAtts ); for ( size_t i = 0 ; i < values . size (); i ++ ) { SetItem ( ncVarname , i , values [ i ]); } } void SetSeries ( const string & dataId , PtrTSeriesEnsemblePtrType value ) { for ( size_t i = 0 ; i < value -> GetLength (); i ++ ) { SetItem ( this -> GetNcVarName (), i , value -> GetValue ( i )); } } void SetItem ( const string & dataId , size_t index , PtrEnsemblePtrType value ) { SetForecasts ( index , value ); } void SetItem ( const string & dataId , size_t index , const EnsemblePtrType & value ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); } //SetItem(const string& dataId, PtrEnsemblePtrType) = 0; //EnsemblePtrType Read(const string& ensembleIdentifier) = 0; void SetLength ( size_t length ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); } void SetStart ( ptime start ) { // TODO? can it be done after initial allocation? } //vector<string> GetItemIdentifiers() const = 0; void SetTimeStep ( const TimeStep & ) { // TODO? can it be done after initial allocation? } bool IsActive () { return ( this -> HasNcAccess ()); } private : std :: vector < ptime > * timeForIndex = nullptr ; std :: map < ptime , size_t > * indexForTime = nullptr ; }; template < typename T > class MultiFileTimeSeriesEnsembleTimeSeriesStore ; template < typename T > class MultiFileTsStorage : public StoragePolicy < T > { public : // Implicitely here, we are dealing only with time series of ensemble of time series typedef typename std :: remove_pointer < T >:: type :: ElementType ElementType ; private : MultiFileTsStorage ( const MultiFileTsStorage & src ) { store = src . store ; // We do not copy the data vector! ReserveVectorData ( store . GetLength ()); readOnly = src . readOnly ; } MultiFileTimeSeriesEnsembleTimeSeriesStore < ElementType > store ; void CheckIntervalBounds ( const size_t & from , size_t & to ) const { size_t tsLen = this -> GetLength (); datatypes :: exceptions :: RangeCheck < size_t >:: CheckTimeSeriesInterval ( from , to , tsLen ); } public : MultiFileTsStorage ( const MultiFileTimeSeriesEnsembleTimeSeriesStore < ElementType >& storage , const string & dataIdentifier , bool readOnly = true ) { store = storage ; size_t length = store . GetLength (); ReserveVectorData ( length ); this -> readOnly = readOnly ; } vector < T > data ; bool readOnly = true ; bool ReadOnly () override { return readOnly ; } size_t Size () const { return data . size (); } void ReserveVectorData ( size_t length ) { if ( ! data . empty ()) { for ( size_t i = 0 ; i < data . size (); i ++ ) { auto ptr = data [ i ]; if ( ptr != nullptr ) delete ptr ; } data . clear (); } if ( length > 0 ) { data . reserve ( length ); data . assign ( length , nullptr ); } } void Allocate ( size_t length , T value ) { if ( ReadOnly ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"MultiFileTsStorage::Allocate cannot be called if the storage is read-only\" ); else { ReserveVectorData ( length ); data . assign ( length , value ); } } void AllocateValues ( size_t length , const T * values ) { if ( ReadOnly ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"MultiFileTsStorage::AllocateValues cannot be called if the storage is read-only\" ); else { ReserveVectorData ( length ); data . assign ( values , values + length ); } } void AllocateValues ( const vector < T >& values ) { if ( ReadOnly ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"MultiFileTsStorage::AllocateValues cannot be called if the storage is read-only\" ); else { ReserveVectorData ( values . size ()); data . assign ( values . begin (), values . end ()); } } void CopyTo ( vector < T >& dest , size_t from = 0 , size_t to = -1 ) const { CheckIntervalBounds ( from , to ); size_t len = ( to - from ) + 1 ; if ( dest . size () != len ) { dest . clear (); dest . resize ( len ); }; for ( size_t i = 0 ; i < len ; i ++ ) { dest [ i ] = ( data [ i ] == nullptr ? store . ReadAt ( i ) : data [ i ]); } } private : void CheckDataItemRange ( const size_t i ) const { if ( data . empty ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"No data item present in this MultiFileTsStorage\" ); datatypes :: exceptions :: ExceptionUtilities :: CheckInRange < size_t > ( i , 0 , data . size (), \"index\" ); } public : T & operator []( const size_t i ) { CheckDataItemRange ( i ); if ( data [ i ] == nullptr ) data [ i ] = store . ReadAt ( i ); return data [ i ]; } const T & operator []( const size_t i ) const { CheckDataItemRange ( i ); return data [ i ]; } StoragePolicy < T >* Clone () const { return new MultiFileTsStorage < T > ( * this ); } size_t GetLength () const { return store . GetLength (); } TimeStep GetTimeStep () const override { return store . GetTimeStep (); } ptime GetStart () const override { return store . GetStart (); } void SetTimeStep ( const TimeStep & tStep ) override { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); } void SetStart ( const ptime & start ) override { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); } }; template < typename T > class /*DATATYPES_DLL_LIB*/ MultiFileTimeSeriesEnsembleTimeSeriesStore : public TimeSeriesEnsembleTimeSeriesStore < T > { public : string DatePattern = \"YYYYMMDD\" ; string FileNamePattern = datatypes :: io :: IoHelper :: DefaultFilePattern ; MultiFileTimeSeriesEnsembleTimeSeriesStore () { } MultiFileTimeSeriesEnsembleTimeSeriesStore ( const string & forecastDataFiles , const string & varName , const string & varIdentifier , int index , const TimeStep & timeStep , const ptime & start , int length , int ensembleSize , int ensembleLength , const TimeStep & ensembleTimeStep ) { this -> forecastDataFiles = forecastDataFiles ; this -> varName = varName ; this -> varIdentifier = varIdentifier ; this -> index = index ; this -> timeStep = timeStep ; this -> start = start ; this -> length = length ; this -> ensembleSize = ensembleSize ; this -> ensembleLength = ensembleLength ; this -> ensembleTimeStep = ensembleTimeStep ; } virtual ~ MultiFileTimeSeriesEnsembleTimeSeriesStore () { /*TODO*/ }; using SeriesType = typename CommonTypes < T >:: SeriesType ; EnsembleForecastTimeSeries < SeriesType >* GetSeries ( const string & dataId ) { // Buckle up... // T is of double // if T is double, SeriesType is TTimeSeries<T> // if T is double, SeriesTypePtr is TTimeSeries<T>* // EnsembleForecastTimeSeries< SeriesType > is an EnsembleForecastTimeSeries<TTimeSeries<T>> // which is a PointerTypeTimeSeries < MultiTimeSeriesPtr<SeriesType> > // which is a PointerTypeTimeSeries < MultiTimeSeriesPtr<TTimeSeries<T> > // which is a TTimeSeries < MultiTimeSeriesPtr<TTimeSeries<T>* > // which is a TTimeSeries < MultiTimeSeries<TTimeSeries<T*>*> // so the type parameters of the storage policy must be a type MultiTimeSeries<TTimeSeries<T*>* // // That all said: // an EnsembleForecastTimeSeries is a template typename for a TTimeSeries, so a simpler way to specify the storage type is: using StorageType = typename EnsembleForecastTimeSeries < SeriesType >:: ElementType ; StoragePolicy < StorageType >* s = new MultiFileTsStorage < StorageType > ( * this , dataId ); return new EnsembleForecastTimeSeries < SeriesType > ( s ); } private : MultiTimeSeries < SeriesType *>* ReadByFileId ( const string & fileIdentifier ) const { using namespace boost :: filesystem ; using datatypes :: io :: IoHelper ; string fileName = IoHelper :: MakeFileName ( forecastDataFiles , fileIdentifier ); path p ( fileName ); if ( exists ( p ) && is_regular_file ( p )) return TimeSeriesIOHelper < T >:: ReadForecastTimeSeries ( fileName , varName , varIdentifier , index ); else return nullptr ; } string GetItemIdentifierForIndex ( size_t index ) const { ptime t = timeStep . AddSteps ( start , index ); return TimeStep :: ToString ( t , DatePattern ); } string GetFilenameForItem ( size_t index ) const { //\"blah/sample_data\\UnitTests\\netcdf\\testpet{0}.nc\" string fn = ShortFileNamePattern (); string s = GetItemIdentifierForIndex ( index ); boost :: algorithm :: replace_first ( fn , FileNamePattern , s ); return fn ; } public : MultiTimeSeries < SeriesType *>* Read ( const string & fileIdentifier ) override { return ReadByFileId ( fileIdentifier ); } MultiTimeSeries < SeriesType *>* ReadAt ( size_t index ) const { datatypes :: exceptions :: ExceptionUtilities :: CheckInRange < size_t > ( index , 0 , this -> length - 1 , \"index\" ); string id = GetItemIdentifierForIndex ( index ); return ReadByFileId ( id ); } size_t GetLength () const { return this -> length ; //return GetMatchingFiles().size(); } TimeStep GetTimeStep () const { return timeStep ; } ptime GetStart () const { return start ; } ptime GetEnd () const { if ( length < 0 ) return start ; size_t n = length ; return timeStep . AddSteps ( start , n ); } string ShortFileNamePattern () const { namespace fs = boost :: filesystem ; fs :: path filesPath ( forecastDataFiles ); auto someDir = filesPath . parent_path (); string fileNamePattern ( filesPath . filename (). string ()); return fileNamePattern ; } string GetDataSummary () const { auto start = GetStart (); auto end = GetEnd (); string result = string ( \"variable name: \" ) + varName + string ( \", identifier: \" ) + varIdentifier + string ( \", index: \" ) + std :: to_string ( index ) + string ( \", start: \" ) + to_iso_extended_string ( start ) + string ( \", end: \" ) + to_iso_extended_string ( end ) + string ( \", time length: \" ) + std :: to_string ( GetLength ()) + string ( \", time step: <not yet supported>\" ); return result ; } vector < DataDimensionDescriptor > GetDataDimensionsDescription () const { return { DataDimensionDescriptor ( TIME_DIM_TYPE_DATA_DIMENSION ), DataDimensionDescriptor ( ENSEMBLE_DIM_TYPE_DATA_DIMENSION ), DataDimensionDescriptor ( TIME_DIM_TYPE_DATA_DIMENSION ) }; } private : string forecastDataFiles ; //string ncVarName; string varName ; //string identifier; string varIdentifier ; int index ; TimeStep timeStep ; ptime start ; int length = -1 ; int ensembleSize = -1 ; int ensembleLength = -1 ; TimeStep ensembleTimeStep ; vector < string > Split ( const string & s , const string & separators ) const { vector < string > tokens ; boost :: split ( tokens , s , boost :: is_any_of ( separators )); return tokens ; } vector < string > GetMatchingFiles () const { namespace fs = boost :: filesystem ; boost :: filesystem :: path filesPath ( forecastDataFiles ); auto someDir = filesPath . parent_path (); string fileNamePattern ( filesPath . filename (). string ()); boost :: algorithm :: replace_first ( fileNamePattern , FileNamePattern , \".*\" ); #ifdef __GNUC__ // https ://jira.csiro.au/browse/WIRADA-350 GNU gcc regex bug; use boost instead #if (__GNUC__ <= 4 && __GNUC_MINOR__ < 9) using boost :: regex ; using boost :: regex_constants :: icase ; using boost :: regex_search ; #else using std :: regex ; using std :: regex_constants :: icase ; using std :: regex_search ; #endif #else using std :: regex ; using std :: regex_constants :: icase ; using std :: regex_search ; #endif // __GNUC__ regex rex ( fileNamePattern , icase ); vector < string > files ; if ( fs :: exists ( someDir ) && fs :: is_directory ( someDir )) { fs :: directory_iterator end ; for ( fs :: directory_iterator dirIter ( someDir ); dirIter != end ; ++ dirIter ) { auto f = dirIter -> path (). filename (); if ( regex_search ( f . string (), rex ) && fs :: is_regular_file ( dirIter -> status ())) { files . push_back ( f . string ()); } } } return files ; } }; class DATATYPES_DLL_LIB TimeSeriesLibraryFactory { private : static void CreateLibrary ( const TimeSeriesLibraryDescription & description , TimeSeriesLibrary & result ); public : using PtrSeriesType = TTimeSeries < double >* ; using SeriesType = TTimeSeries < double > ; static TimeSeriesLibrary CreateLibrary ( const TimeSeriesLibraryDescription & description ); static TimeSeriesLibrary * CreateLibraryPtr ( const TimeSeriesLibraryDescription & description ); static TimeSeriesLibrary LoadTimeSeriesLibrary ( const string & filepath , const string & dataPath = \"\" ); static TimeSeriesLibrary * LoadTimeSeriesLibraryPtr ( const string & filepath , const string & dataPath = \"\" ); static TimeSeriesLibrary * CreateTimeSeriesLibraryPtr ( const string & type ); static SingleTimeSeriesStore < double >* CreateTsSource ( const string & ncFilename , const string & ncVarName , const string & ncIdentifier ); static EnsembleTimeSeriesStore < double >* CreateEnsTsSource ( const string & ncFilename , const string & ncVarName , const string & ncIdentifier ); static TimeSeriesEnsembleTimeSeriesStore < double >* CreateTsEnsTsSource ( const string & ncFilename , const string & ncVarName , const string & ncIdentifier ); static EnsembleForecastTimeSeries < SeriesType >* LoadTsEnsTs ( const string & ncFilename , const string & ncVarName , const string & ncIdentifier , const string & dataId ); static TimeSeriesSourceInfo CreateNetcdfSourceInfo ( const string & dataId , const string & storageType , const string & ncFilename , const string & ncVarName , const string & ncIdentifier ); static TimeSeriesSourceInfo CreateNetcdfSourceInfo ( const string & dataId , const string & storageType , const string & ncFilename , const string & ncVarName , const string & ncIdentifier , int index , const string & timeStep , const string & start , int length , int ensembleSize ); static TimeSeriesSourceInfo CreateNetcdfSourceInfo ( const string & dataId , const string & storageType , const string & ncFilename , const string & ncVarName , const string & ncIdentifier , int index , const string & timeStep , const string & start , int length , int ensembleSize , int ensembleLength , const string & ensembleTimeStep ); static const string kTestRecorderKey ; static const string kTimeSeriesEnsemblesKey ; static bool HasTimeSeriesSourceInfoBuilderRegistered (); static void RegisterTimeSeriesSourceInfoBuilder ( TimeSeriesSourceInfoBuilder * srcBuilder ); private : static TimeSeriesSourceInfoBuilder * GetBuilder (); static TimeSeriesSourceInfoBuilder * infoBuilder ; }; class DATATYPES_DLL_LIB SwiftNetcdfStoreFactory : public TimeSeriesStoreFactory { private : string dirPath ; DataGeometryProvider * geometryProvider ; boost :: filesystem :: path CreateNcFilename ( const string & dataId ) { return boost :: filesystem :: path ( dirPath ) / ( dataId + \".nc\" ); } public : SwiftNetcdfStoreFactory ( const string & path , DataGeometryProvider * dgp ); ~ SwiftNetcdfStoreFactory (); TimeSeriesEnsembleTimeSeriesStore < double >* CreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ); bool CanCreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ); }; //using EFTS = CommonTypes<>::TSeriesEnsemblePtrType; //template<> //GlobalAttributes GetMetadataFrom<EFTS,GlobalAttributes>(const EFTS& ens) //{ //} } } Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes/time_series_io.hpp"},{"location":"cpp/Files/time__series__io_8hpp/#datatypestime_series_iohpp","text":"","title":"datatypes/time_series_io.hpp"},{"location":"cpp/Files/time__series__io_8hpp/#namespaces","text":"Name datatypes datatypes::timeseries datatypes::timeseries::io","title":"Namespaces"},{"location":"cpp/Files/time__series__io_8hpp/#classes","text":"Name class datatypes::timeseries::GlobalAttributes A class to hold the global attributes of a file stored in the SWIFT netCDF format. class datatypes::timeseries::VariableAttributes A class to hold the attributes of a netCDF variable stored in the SWIFT netCDF format. class datatypes::timeseries::VariableDefinition class datatypes::timeseries::DimensionsDefinitions class datatypes::timeseries::DataGeometryProvider class datatypes::timeseries::io::SwiftNetCDFVariablePersister class datatypes::timeseries::io::SwiftNetCDFVariablePersister< double > class datatypes::timeseries::io::SwiftNetCDFVariablePersister< float > class datatypes::timeseries::io::SwiftNetCDFVariablePersister< long > class datatypes::timeseries::io::SwiftNetCDFVariablePersister< int > class datatypes::timeseries::io::SwiftNetCDFAccess Class responsible for the low-level read/write operations from/to a SWIFT netCDF file. class datatypes::timeseries::io::ConfigFileHelper class datatypes::timeseries::TimeSeriesIOHelper Representation of an univariate, ensemble time series with a SWIFT netCDF back end. class datatypes::timeseries::SingleNetCdfFileStore class datatypes::timeseries::NetCdfSingleSeriesStore class datatypes::timeseries::NetCdfEnsembleTimeSeriesStore class datatypes::timeseries::EagerWriter class datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore class datatypes::timeseries::MultiFileTsStorage An implementation of StoragePolicy such that the content of a time series is spread amongst several files. class datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore An implementation of TimeSeriesEnsembleTimeSeriesStore such that the content of a time series is spread amongst several files. class datatypes::timeseries::TimeSeriesLibraryFactory class datatypes::timeseries::SwiftNetcdfStoreFactory","title":"Classes"},{"location":"cpp/Files/time__series__io_8hpp/#source-code","text":"#pragma once #include <stdexcept> #include <netcdf.h> #include <map> #ifdef __GNUC__ // https ://jira.csiro.au/browse/WIRADA-350 GNU gcc regex bug; use boost instead #if (__GNUC__ <= 4 && __GNUC_MINOR__ < 9) #include <boost/regex.hpp> #else #include <regex> #endif #else #include <regex> #endif // __GNUC__ #include <algorithm> #include <boost/function.hpp> #include <boost/filesystem.hpp> #include <boost/range/iterator_range.hpp> #include <boost/algorithm/string/predicate.hpp> #include <boost/algorithm/string/split.hpp> #include <boost/algorithm/string/classification.hpp> #include <boost/algorithm/string.hpp> #include \"time_series.hpp\" #include \"time_series_store.hpp\" namespace datatypes { namespace timeseries { using namespace datatypes :: exceptions ; class DATATYPES_DLL_LIB GlobalAttributes { public : string Title ; string Institution ; string Source ; string Catchment ; double STFConventionVersion ; string STFNCSpec ; string Comment ; string History ; GlobalAttributes (); GlobalAttributes ( const string & title , const string & institution , const string & source , const string & catchment , double stfConventionVersion , const string & stfNcSpec , const string & comment , const string & history ); GlobalAttributes ( GlobalAttributes && src ); GlobalAttributes ( const GlobalAttributes & src ); GlobalAttributes & operator = ( const GlobalAttributes & src ); static GlobalAttributes CreateDefault (); static GlobalAttributes CreateDefault ( const string & catchment ); }; template < typename From , typename To > To GetMetadataFrom ( const From & ens ) { throw std :: logic_error ( string ( \"No template specialization found for GetMetadataFrom<From,To> where From=\" ) + typeid ( From ). name () + string ( \"and To=\" ) + typeid ( To ). name ()); } class DATATYPES_DLL_LIB VariableAttributes { public : string LongName ; string Units ; int Type = 0 ; string TypeDescription ; string LocationType ; string DatType ; string DatDescription ; double FillValue ; static const double DefaultFillValue (); VariableAttributes (); VariableAttributes ( const string & longName , const string & units , int type , const string & typeDescription , const string & datType , const string & datDescription , const string & locationType , double fillValue ); VariableAttributes ( VariableAttributes && src ); VariableAttributes ( const VariableAttributes & src ); VariableAttributes & operator = ( const VariableAttributes & src ); }; class DATATYPES_DLL_LIB VariableDefinition { const string kDoublePrecision = DATATYPES_DOUBLE_PRECISION_ID ; const string kSinglePrecision = DATATYPES_SINGLE_PRECISION_ID ; public : VariableDefinition ( const string & name , const string & precision , const string & dimensions , const string & longName , const string & units , double fillValue , int type , const string & typeDescription , const string & datType , const string & datDescription , const string & locationType ); VariableDefinition ( const string & name , const VariableAttributes & attribs , const string & dimensions , const string & precision = DATATYPES_DOUBLE_PRECISION_ID ); VariableAttributes attributes ; string Name ; string Precision ; string Dimensions ; int GetPrecision () const ; static void Split ( const std :: map < string , VariableDefinition >& varDefinitions , vector < string >& varNames , std :: map < string , VariableAttributes >& varAttributes ); //static std::map<string, VariableDefinition> Join(const vector<string>& varNames, const std::map<string, VariableAttributes>& varAttributes); VariableDefinition (); VariableDefinition ( VariableDefinition && src ); VariableDefinition ( const VariableDefinition & src ); VariableDefinition & operator = ( VariableDefinition && src ); VariableDefinition & operator = ( const VariableDefinition & src ); static VariableDefinition PointTimeSeries ( const string & name , const string & units , const string & longName , int type = 0 , const string & typeDescription = \"<NA>\" , const string & datType = \"<NA>\" , const string & datDescription = \"<NA>\" , const string & precision = DATATYPES_DOUBLE_PRECISION_ID , double fillValue = DEFAULT_MISSING_DATA_VALUE , const string & locationType = \"Point\" ); static VariableDefinition TimeSeriesEnsembleTimeSeries ( const string & name , const string & units , const string & longName , int type = 0 , const string & typeDescription = \"<NA>\" , const string & datType = \"<NA>\" , const string & datDescription = \"<NA>\" , const string & precision = DATATYPES_DOUBLE_PRECISION_ID , double fillValue = DEFAULT_MISSING_DATA_VALUE , const string & locationType = \"Point\" ); }; class DATATYPES_DLL_LIB DimensionsDefinitions { public : DimensionsDefinitions ( const size_t ensembleSize , const vector < double >& leadTimeVar , const string & timeUnits , const vector < double >& timeVar , const vector < string >& stationIds = DEFAULT_STATION_IDENTIFIER , const string & leadTimeUnits = \"\" ); DimensionsDefinitions ( const string & timeUnits , const vector < double >& timeVar , const vector < string >& stationIds = DEFAULT_STATION_IDENTIFIER , const string & leadTimeUnits = \"\" ); DimensionsDefinitions ( ptime tsEnsStart , const TimeStep & mainTimeStep , size_t tsLength , size_t ensembleSize , const TimeStep & fcastTimeStep , size_t leadTimeSize , int fcastOffset = 1 , const vector < string >& stationIds = DEFAULT_STATION_IDENTIFIER , const string & leadTimeUnits = \"\" ); DimensionsDefinitions (); DimensionsDefinitions ( DimensionsDefinitions && src ); DimensionsDefinitions ( const DimensionsDefinitions & src ); DimensionsDefinitions & operator = ( DimensionsDefinitions && src ); DimensionsDefinitions & operator = ( const DimensionsDefinitions & src ); size_t EnsembleSize ; vector < double > LeadTimeVar ; string TimeUnits ; vector < double > TimeVar ; vector < string > StationIds ; string LeadTimeUnits ; }; template < typename ElementType > DimensionsDefinitions DimensionsFromSeries ( const TTimeSeries < ElementType >& ts , const size_t ensembleSize = 1 , const size_t leadTimeSize = 1 , const vector < string >& stationIds = DEFAULT_STATION_IDENTIFIER ) { const int fcastOffset = 1 ; return DimensionsDefinitions ( ts . GetStartDate (), ts . GetTimeStep (), ts . GetLength (), ensembleSize , ts . GetTimeStep (), leadTimeSize , fcastOffset , stationIds ); } template < typename ElementType > DimensionsDefinitions DimensionsFromSeries ( EnsembleForecastTimeSeries <>& tsEns , const vector < string >& stationIds = DEFAULT_STATION_IDENTIFIER ) { if ( tsEns . GetLength () == 0 ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"time series of ensemble forecasts must not be empty to retrieve dimensions\" ); auto ens = tsEns . GetValue (( size_t ) 0 ); if ( ens == nullptr ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"DimensionsDefinitions - time series of ensemble forecasts: first value must not be null\" ); auto s = ens -> Get ( 0 ); if ( s == nullptr ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"DimensionsDefinitions - time series of ensemble forecasts: first value in first ensemble must not be null\" ); auto tsEnsStart = tsEns . GetStartDate (); const size_t ensembleSize = ens -> Size (); TimeStep fcastTimeStep = ens -> GetTimeStep (); const size_t leadTimeSize = s -> GetLength (); const ptrdiff_t fcastOffset = fcastTimeStep . GetNumSteps ( tsEnsStart , s -> GetStartDate ()) - 1 ; return DimensionsDefinitions ( tsEnsStart , tsEns . GetTimeStep (), tsEns . GetLength (), ensembleSize , ens -> GetTimeStep (), leadTimeSize , fcastOffset , stationIds ); } template < typename ElementType > DimensionsDefinitions DimensionsFromSeries ( const vector < EnsembleForecastTimeSeries <>:: ElementType >& values , const TimeStep & tsEnsTstep = TimeStep :: GetUnknown (), const ptime & tsEnsStart = not_a_date_time , const vector < string >& stationIds = DEFAULT_STATION_IDENTIFIER , int fcastOffset = 1 ) { if ( values . empty ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"time series of ensemble forecasts must not be empty to retrieve dimensions\" ); auto ens = values [ 0 ]; if ( ens == nullptr ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"DimensionsDefinitions - time series of ensemble forecasts: first value must not be null\" ); auto s = ens -> Get ( 0 ); if ( s == nullptr ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"DimensionsDefinitions - time series of ensemble forecasts: first value in first ensemble must not be null\" ); //ptime tsEnsStart = tsEnsStart; const ptime & fcastUtcStart = s -> GetStartDate (); const TimeStep & fcastTimeStep = s -> GetTimeStep (); TimeStep mainTimeStep = tsEnsTstep ; ptime tsOrigin = tsEnsStart ; if ( tsOrigin == not_a_date_time ) tsOrigin = fcastTimeStep . AddSteps ( fcastUtcStart , - fcastOffset ); if ( mainTimeStep . IsUnknown ()) if ( values . size () > 1 && values [ 1 ] != nullptr ) mainTimeStep = TimeStep ( values [ 1 ] -> GetStartDate () - values [ 0 ] -> GetStartDate ()); else mainTimeStep = fcastTimeStep ; const size_t leadTimeSize = s -> GetLength (); const size_t ensembleSize = ens -> Size (); return DimensionsDefinitions ( tsOrigin , mainTimeStep , values . size (), ensembleSize , ens -> GetTimeStep (), leadTimeSize , fcastOffset , stationIds ); } //template<typename ElementType> //DimensionsDefinitions DimensionsFromSeries( // const TimeSeriesEnsemble<>& collectionOfTs, const vector<string>& stationIds = DEFAULT_STATION_IDENTIFIER) //{ // throw std::logic_error(\"dimension from ensemble time series not implemented\"); //} // A class that can provide the characteristics of a netCDF file for saving time series. // This class is a provision for future feature allowing for a late definition on disk // of the file geometry, e.g. when time series to record are reset after creation of the recorder. // Initially, not used to the full \"lazy\" extent as this is overly complicated for marginal/potential benefit. class DATATYPES_DLL_LIB DataGeometryProvider { public : virtual DimensionsDefinitions GetDimensions () const = 0 ; virtual ~ DataGeometryProvider (); }; namespace io { template < typename ElementType > class DATATYPES_DLL_LIB SwiftNetCDFVariablePersister { public : static int NcGetVara ( int ncid , int varid , const size_t * startp , const size_t * countp , ElementType * op ) { throw std :: logic_error ( string ( \"No template specialization found for SwiftNetCDFVariablePersister::NcGetVara for type\" ) + typeid ( ElementType ). name ()); } static int NcPutVara ( int ncid , int varid , const size_t * startp , const size_t * countp , const ElementType * op ) { throw std :: logic_error ( string ( \"No template specialization found for SwiftNetCDFVariablePersister::NcPutVara for type\" ) + typeid ( ElementType ). name ()); } }; template <> class DATATYPES_DLL_LIB SwiftNetCDFVariablePersister < double > { public : static int NcGetVara ( int ncid , int varid , const size_t * startp , const size_t * countp , double * op ) { return nc_get_vara_double ( ncid , varid , startp , countp , op ); } static int NcPutVara ( int ncid , int varid , const size_t * startp , const size_t * countp , const double * op ) { return nc_put_vara_double ( ncid , varid , startp , countp , op ); } }; template <> class DATATYPES_DLL_LIB SwiftNetCDFVariablePersister < float > { public : static int NcGetVara ( int ncid , int varid , const size_t * startp , const size_t * countp , float * op ) { return nc_get_vara_float ( ncid , varid , startp , countp , op ); } static int NcPutVara ( int ncid , int varid , const size_t * startp , const size_t * countp , const float * op ) { return nc_put_vara_float ( ncid , varid , startp , countp , op ); } }; template <> class DATATYPES_DLL_LIB SwiftNetCDFVariablePersister < long > { public : static int NcGetVara ( int ncid , int varid , const size_t * startp , const size_t * countp , long * op ) { return nc_get_vara_long ( ncid , varid , startp , countp , op ); } static int NcPutVara ( int ncid , int varid , const size_t * startp , const size_t * countp , const long * op ) { return nc_put_vara_long ( ncid , varid , startp , countp , op ); } }; template <> class DATATYPES_DLL_LIB SwiftNetCDFVariablePersister < int > { public : static int NcGetVara ( int ncid , int varid , const size_t * startp , const size_t * countp , int * op ) { return nc_get_vara_int ( ncid , varid , startp , countp , op ); } static int NcPutVara ( int ncid , int varid , const size_t * startp , const size_t * countp , const int * op ) { return nc_put_vara_int ( ncid , varid , startp , countp , op ); } }; class DATATYPES_DLL_LIB SwiftNetCDFAccess { // private : static void ThrowOnFileOpenFail ( const string & filename , int code ); static void ThrowOnVarInquiryFail ( const string & varName , int code ); void Init ( const string & filename , const size_t nEns , const vector < double >& leadTimeVar , const string & timeUnits , const vector < double >& timeVar , const vector < string >& stationIds , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes , const string & leadTimeUnits ); public : SwiftNetCDFAccess ( const string & filename , bool lazyLoad = false ); // * \\brief Constructor to create a new SWIFT netCDF file // * // * \\param filename name of the new file to create. // * \\param nEns Size of the ensembles // * \\param nLead Length of the lead time for each of the time series in the ensemble forecast for a given time. // * \\param timeUnits Units of the temporal dimension(s). // * \\param [in] timeVar The values of the \"main\" time dimension, consistent with the temporal units given with the previous parameter // * \\param [in] stationIds List of identifiers for the stations. // * \\param [in] varNames List of names of the variables. // * \\param [in] varAttributes Attributes for each variables; the keys of the dictionary must be found in the varNames parameter. // */ //SwiftNetCDFAccess(const string& filename, const size_t nEns, const vector<double>& leadTimeVar, const string& timeUnits, const vector<double>& timeVar, const vector<string>& stationIds, // const vector<string>& varNames, const std::map<string, VariableAttributes>& varAttributes); SwiftNetCDFAccess ( const string & filename , const size_t nEns , const vector < double >& leadTimeVar , const string & timeUnits , const vector < double >& timeVar , const vector < string >& stationIds , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes , const string & leadTimeUnits = \"\" ); SwiftNetCDFAccess ( const string & filename , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes ); ~ SwiftNetCDFAccess (); static void CheckCompliance ( const string & filename , int majorVersion , int minorVersion , vector < string >& warnings , vector < string >& errors ); size_t GetEnsembleSize (); size_t GetEnsembleSize ( const string & ncVarName ); size_t GetLeadTimeCount (); size_t GetLeadTimeCount ( const string & ncVarName ); size_t GetTimeLength () const ; vector < ptime > GetTimeDim (); ptime GetStart (); ptime GetEnd (); size_t IndexForIdentifier ( const string & identifier ) const ; size_t GetNumIdentifiers () const ; vector < string > GetIdentifiers () const ; //int IndexForTime(const ptime* time); ptime TimeForIndex ( size_t timeIndex ); private : template < typename ElementType > int NcGetVara ( int ncid , int varid , const size_t * startp , const size_t * countp , ElementType * op ) { return SwiftNetCDFVariablePersister < ElementType >:: NcGetVara ( ncid , varid , startp , countp , op ); } template < typename ElementType > int NcPutVara ( int ncid , int varid , const size_t * startp , const size_t * countp , const ElementType * op ) { return SwiftNetCDFVariablePersister < ElementType >:: NcPutVara ( ncid , varid , startp , countp , op ); } bool isTimeFastestVarying ( const vector < int >& varDimIds ) { return ( varDimIds [ varDimIds . size () - 1 ] == this -> timeDimId ); } public : template < typename ElementType > vector < ElementType *> * GetForecasts ( const string & varName , size_t stationIndex , size_t timeIndex ) { int dataVarId = GetVarId ( varName ); vector < size_t > startp ; vector < size_t > countp ; GetEnsFcastNetcdfWindow ( varName , stationIndex , timeIndex , startp , countp ); auto vardata = GetForecastDataBuffer (); size_t * s = & ( startp [ 0 ]); size_t * c = & ( countp [ 0 ]); int code = NcGetVara ( ncid , dataVarId , s , c , vardata ); if ( code != NC_NOERR ) { ExceptionUtilities :: ThrowInvalidOperation ( \"GetForecasts failed for variable \" + varName ); } auto result = new vector < ElementType *> (); ElementType * dest ; for ( int i = 0 ; i < ensembleSize ; i ++ ) { dest = new ElementType [ leadTimeLength ]; memcpy ( dest , vardata + i * leadTimeLength , leadTimeLength * sizeof ( ElementType )); result -> push_back ( dest ); } delete [] vardata ; return result ; } template < typename ElementType > vector < ElementType *> * GetEnsemble ( const string & varName , size_t stationIndex ) { int dataVarId = GetVarId ( varName ); vector < size_t > startp ; vector < size_t > countp ; GetNetcdfWindow ( varName , stationIndex , startp , countp ); auto n = GetTimeLength (); auto vardata = GetEnsembleDataBuffer ( 1 , n ); size_t * s = & ( startp [ 0 ]); size_t * c = & ( countp [ 0 ]); int code = NcGetVara ( ncid , dataVarId , s , c , vardata ); auto result = new vector < ElementType *> (); ElementType * dest ; auto maxT = this -> GetTimeLength (); for ( int i = 0 ; i < ensembleSize ; i ++ ) { // double q_ens[station, ens_member, time] in R; rev conventions for C // [time][ens_member][station]. There is only one station, so vardata is organised as // [time][ens_member] dest = new ElementType [ n ]; for ( size_t t = 0 ; t < maxT ; t ++ ) { dest [ t ] = vardata [ ensembleSize * t + i ]; } result -> push_back ( dest ); } delete [] vardata ; return result ; } template < typename ElementType > vector < ElementType > GetValues ( const string & varName , size_t stationIndex ) { int dataVarId = GetVarId ( varName ); vector < size_t > startp ; vector < size_t > countp ; GetNetcdfWindow ( varName , stationIndex , startp , countp ); vector < ElementType > vardata ( GetTimeLength ()); ElementType * op = & ( vardata [ 0 ]); size_t * s = & ( startp [ 0 ]); size_t * c = & ( countp [ 0 ]); int code = NcGetVara ( ncid , dataVarId , s , c , op ); if ( code != NC_NOERR ) { ExceptionUtilities :: ThrowInvalidOperation ( \"GetValues failed for variable \" + varName ); } return vardata ; } template < typename ElementType > vector < ElementType > GetValues ( const string & varName ) { size_t n = GetTimeLength (); size_t nIds = GetNumIdentifiers (); size_t N = n * nIds ; vector < ElementType > values ( N ); int dataVarId = GetVarId ( varName ); vector < size_t > startp ; vector < size_t > countp ; GetNetcdfWindow ( varName , startp , countp ); size_t * s = & ( startp [ 0 ]); size_t * c = & ( countp [ 0 ]); ElementType * vardata = values . data (); int code = NcGetVara ( ncid , dataVarId , s , c , vardata ); if ( code != NC_NOERR ) { ExceptionUtilities :: ThrowInvalidOperation ( \"GetValues failed for variable \" + varName ); } return values ; } template < typename ElementType > TTimeSeries < ElementType > * GetSeries ( const string & varName , size_t stationIndex ) { auto values = GetValues < ElementType > ( varName , stationIndex ); auto result = new TTimeSeries < ElementType > ( values , this -> TimeForIndex ( 0 ), this -> GetTimeStep ()); return result ; } template < typename ElementType > MultiTimeSeries < TTimeSeries < ElementType >*>* GetSeries ( const string & varName ) { vector < ElementType > values = GetValues < ElementType > ( varName ); size_t tlen = GetTimeLength (); size_t n = GetNumIdentifiers (); size_t N = n * tlen ; if ( values . size () != N ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"Inconsistencies between values length and expected total size of data\" ); auto varDims = GetVarDims ( varName ); ElementType * d = values . data (); auto start = TimeForIndex ( 0 ); auto tstep = GetTimeStep (); if ( isTimeFastestVarying ( varDims )) { vector < ElementType *> vv ( n ); for ( size_t i = 0 ; i < n ; i ++ ) { vv [ i ] = d ; d += tlen ; } return new MultiTimeSeries < TTimeSeries < ElementType >*> ( vv , tlen , GetStart (), GetTimeStep ()); } else { vector < ElementType > v ( tlen ); vector < vector < ElementType >> vv ; vv . assign ( n , v ); for ( size_t t = 0 ; t < tlen ; t ++ ) { for ( size_t s = 0 ; s < n ; s ++ ) { vv [ s ][ t ] = * d ; d += 1 ; } } return new MultiTimeSeries < TTimeSeries < ElementType >*> ( vv , GetStart (), GetTimeStep ()); } } template < typename ElementType > MultiTimeSeries < TTimeSeries < ElementType >*> * GetEnsembleSeries ( const string & varName , size_t stationIndex ) { auto series = GetEnsemble < ElementType > ( varName , stationIndex ); auto result = new MultiTimeSeries < TTimeSeries < ElementType >*> ( * series , this -> GetTimeLength (), this -> TimeForIndex ( 0 ), this -> GetTimeStep ()); for ( auto & d : ( * series )) { if ( d != nullptr ) delete [] d ; } delete series ; return result ; } template < typename ElementType > void SetForecasts ( const string & varName , size_t stationIndex , size_t timeIndex , vector < ElementType *> & values ) // TODO: checks on 'values' { int dataVarId = GetVarId ( varName ); vector < size_t > startp ; vector < size_t > countp ; GetEnsFcastNetcdfWindow ( varName , stationIndex , timeIndex , startp , countp ); auto vardata = GetForecastDataBuffer (); ElementType * dest ; for ( int i = 0 ; i < ensembleSize ; i ++ ) { dest = vardata + i * leadTimeLength ; memcpy ( dest , values [ i ], leadTimeLength * sizeof ( ElementType )); } size_t * s = & ( startp [ 0 ]); size_t * c = & ( countp [ 0 ]); int code = NcPutVara ( ncid , dataVarId , s , c , vardata ); delete [] vardata ; } template < typename ElementType > void SetEnsembles ( const string & varName , size_t stationIndex , vector < ElementType *> & values ) { int dataVarId = GetVarId ( varName ); vector < size_t > startp ; vector < size_t > countp ; GetNetcdfWindow ( varName , stationIndex , startp , countp ); size_t n = GetTimeLength (); auto vardata = GetEnsembleDataBuffer ( 1 , n ); for ( int i = 0 ; i < ensembleSize ; i ++ ) { ElementType * ensData = values [ i ]; for ( int j = 0 ; j < n ; j ++ ) { vardata [ ensembleSize * j + i ] = ensData [ j ]; } } size_t * s = & ( startp [ 0 ]); size_t * c = & ( countp [ 0 ]); int code = NcPutVara ( ncid , dataVarId , s , c , vardata ); delete vardata ; } template < typename ElementType > void SetValues ( const string & varName , size_t stationIndex , const vector < ElementType >& values ) { size_t n = GetTimeLength (); if ( values . size () != n ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"vector passed does not have the length of the main time dimension\" ); int dataVarId = GetVarId ( varName ); vector < size_t > startp ; vector < size_t > countp ; GetNetcdfWindow ( varName , stationIndex , startp , countp ); size_t * s = & ( startp [ 0 ]); size_t * c = & ( countp [ 0 ]); const double * vardata = values . data (); int code = NcPutVara ( ncid , dataVarId , s , c , vardata ); } template < typename ElementType > void SetValues ( const string & varName , const vector < ElementType >& values ) { size_t n = GetTimeLength (); size_t nIds = GetNumIdentifiers (); size_t N = n * nIds ; if ( values . size () != N ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"Inconsistencies between values length and expected total size of data\" ); int dataVarId = GetVarId ( varName ); vector < size_t > startp ; vector < size_t > countp ; GetNetcdfWindow ( varName , startp , countp ); size_t * s = & ( startp [ 0 ]); size_t * c = & ( countp [ 0 ]); // double q_der[station, time] in R; rev conventions for C const double * vardata = values . data (); int code = NcPutVara ( ncid , dataVarId , s , c , vardata ); if ( code != NC_NOERR ) { ExceptionUtilities :: ThrowInvalidOperation ( \"SetValues failed for variable \" + varName ); } } vector < int > GetVarDims ( int varNumDims ); vector < int > GetVarDims ( const string & varName ); vector < string > ReadVariableNames ( bool removeDimVars = true ); vector < string > ReadAttributeNames ( const string & varName ); string ReadStringAttribute ( int varId , const string & attName , bool throwIfNotFound = false , string defaultValue = \"\" ); string ReadStringAttribute ( const string & varName , const string & attName , bool throwIfNotFound = false , string defaultValue = \"\" ); double ReadNumericAttribute ( int varId , const string & attName , bool throwIfNotFound = false , double defaultValue = 0.0 ); double ReadNumericAttribute ( const string & varName , const string & attName , bool throwIfNotFound = false , double defaultValue = 0.0 ); VariableAttributes ReadAttributes ( const string & varName ); GlobalAttributes ReadGlobalAttributes (); template < typename ElementType > static string CreateTimeUnitsAttribute ( const TTimeSeries < ElementType >& tSeries ) { return CreateTimeUnitsAttribute ( tSeries . GetStartDate (), tSeries . GetTimeStep ()); } static std :: pair < vector < double > , vector < double >> CreateTimeVectors ( const ptime & start , const TimeStep & timeStep , size_t tsLength , const TimeStep & leadTimeStep , size_t leadTimeSize , int fcastOffset = 1 ); static vector < double > CreateTimeVector ( const ptime & start , const TimeStep & timeStep , const ptime & origin , const time_duration & timeStepAxis , const size_t length ); static vector < double > CreateTimeVector ( const ptime & start , const TimeStep & timeStep , const ptime & origin , const TimeStep & timeStepAxis , const size_t length ); static vector < double > CreateTimeVector ( const ptime & start , const TimeStep & timeStep , const size_t length ); template < typename ElementType > static vector < double > CreateTimeVector ( const TTimeSeries < ElementType >& tSeries ) { return CreateTimeVector ( tSeries . GetStartDate (), tSeries . GetTimeStep (), tSeries . GetLength ()); } template < typename ElementType > static vector < double > CreateTimeVector ( const TTimeSeries < ElementType >& tSeries , const ptime & origin , const TimeStep & timeStepAxis ) { return CreateTimeVector ( tSeries . GetStartDate (), tSeries . GetTimeStep (), origin , timeStepAxis , tSeries . GetLength ()); } template < typename T > static ptime StartCoordinate ( const ptime & origin , const TimeStep & timeStep , const vector < T >& timeCoords ) { if ( timeCoords . empty ()) ExceptionUtilities :: ThrowInvalidArgument ( \"Empty time coordinates\" ); return timeStep . AddSteps ( origin , timeCoords [ 0 ]); } static std :: pair < ptime , TimeStep > CreateTimeGeometry ( const string & axisDefinition , const vector < double >& timeCoords ); static string GetTimeStepName ( const TimeStep & timeStep ); static string CreateTimeUnitsAttribute ( const ptime & utcStart , const string & units ); static string CreateTimeUnitsAttribute ( const ptime & utcStart , const TimeStep & timeStep ); static ptime ParseStartDate ( const string & unitsAttribute ); static string ParseTimeUnits ( const string & unitsAttribute ); static string CreateLeadTimeUnitsAttribute ( const TimeStep & timeStep ); TimeStep GetTimeStep (); TimeStep GetLeadTimeStep (); std :: pair < ptime , TimeStep > GetLeadTimeGeometry ( const ptime & issueTime ); vector < double > GetLeadTimeDim (); template < class TFrom , class TTo > static vector < TTo > Convert ( const vector < TFrom >& from , const std :: function < TTo ( const TFrom & ) >& f ) { using IterFrom = typename vector < TFrom >:: const_iterator ; using IterTo = typename vector < TTo >:: iterator ; vector < TTo > result ( from . size ()); std :: transform < IterFrom , IterTo , std :: function < TTo ( TFrom ) >> ( from . begin (), from . end (), result . begin (), f ); return result ; } static time_duration CreateTimeUnits ( const TimeStep & timeStep ); static time_duration TimeOffsetIn ; static time_duration TimeOffsetOut ; static void SetTimeOffsetIn ( const time_duration & td ); static void SetTimeOffsetOut ( const time_duration & td ); GlobalAttributes GetGlobalAttributes (); VariableAttributes GetAttributes ( const string & varName ); private : TimeStep GetTimeUnitTimeStep () const ; void DefineVariable ( const VariableDefinition & definition , int & code ); static TimeStep GetTimeUnitTimeStep ( const string & timeUnits ); template < class TTo > static TTo * ConvertToArray ( const vector < string >& src ) { return datatypes :: utils :: ConvertToArray < TTo > ( src ); } template < class TFrom , class TTo > static TTo * ConvertToArray ( const vector < TFrom >& src ) { return datatypes :: utils :: ConvertToArray < TFrom , TTo > ( src ); } template < class TFrom , class TTo > static vector < TTo > Convert ( const vector < TFrom >& src ) { return datatypes :: utils :: Convert < TFrom , TTo > ( src ); } template < class TTo > vector < TTo > Convert ( const vector < string >& src ) { return datatypes :: utils :: Convert < TTo > ( src ); } template < class T > static vector < T > ToVector ( T * values , size_t n ) { vector < T > result ( n ); result . assign ( values , values + n ); return result ; } template < class T > TimeStep FindTimeStep ( bool & cachedFlag , TimeStep & timeStep , const vector < T >& timeVec ) { if ( cachedFlag ) return timeStep ; auto tsu = GetTimeUnitTimeStep (); if ( timeVec . size () <= 1 ) { timeStep = tsu ; } else { if ( tsu . IsRegular ()) { timeStep = tsu * ( timeVec [ 1 ] - timeVec [ 0 ]); } else { if (( timeVec [ 1 ] - timeVec [ 0 ]) == 1 ) { timeStep = tsu ; } else { exceptions :: ExceptionUtilities :: ThrowNotSupported ( \"No support for multiple increments of an irregular time step\" ); } } } cachedFlag = true ; return timeStep ; } template < class T > static TimeStep FindTimeStep ( const TimeStep & axisTimeStep , const vector < T >& timeVec ) { TimeStep timeStep ; auto tsu = axisTimeStep ; if ( timeVec . size () <= 1 ) timeStep = tsu ; else timeStep = tsu * ( timeVec [ 1 ] - timeVec [ 0 ]); return timeStep ; } template < class T > static TimeStep FindTimeStep ( const string & axisDefinition , const vector < T >& timeVec ) { TimeStep timeStep ; auto utstep = GetTimeUnitTimeStep ( ParseTimeUnits ( axisDefinition )); return FindTimeStep < T > ( utstep , timeVec ); } template < class T > TimeStep FindTimeStep ( const vector < T >& timeVec ) { TimeStep timeStep ; bool ignored = false ; return FindTimeStep < double > ( ignored , timeStep , timeVec ); } const int kDefaultStrLength = 30 ; static const string kTimeDimName ; static const string kStationDimName ; static const string kStrLenDimName ; static const string kLeadTimeDimName ; static const string kEnsMemberDimName ; static const string kTimeVarName ; static const string kLatVarName ; static const string kLonVarName ; static const string kElevationVarName ; static const string kStationNameVarName ; static const string kStationIdVarName ; static const string kLeadTimeVarName ; static const string kEnsMemberVarName ; // The following two may be used only as filtering out results of var names queries static const string kStrLenVarName ; static const string kStationVarName ; vector < string > ReservedVariableNames () const ; static const string kUnitsAttName ; static const string kStandardNameAttName ; static const string kLongNameAttName ; static const string kAxisAttName ; static const string kTypeAttName ; static const string kTypeDescriptionAttName ; static const string kDatTypeAttName ; static const string kDatDescriptionAttName ; static const string kLocationTypeAttName ; static const string kCatchmentAttName ; static const string kFillValueAttName ; static const string kGlobalAttNameTitle ; static const string kGlobalAttNameInstitution ; static const string kGlobalAttNameSource ; static const string kGlobalAttNameCatchment ; static const string kGlobalAttNameSTF_convention_version ; static const string kGlobalAttNameSTF_nc_spec ; static const string kGlobalAttNameComment ; static const string kGlobalAttNameHistory ; static const string kAttNameTimeStandard ; const double kDefaultFillValue = VariableAttributes :: DefaultFillValue (); void ReadGeometry (); void ReadGeometryDimensions (); void ReadGeometryVariables (); void WriteGeometry ( size_t nEns , const vector < double >& leadTimeVar , const string & timeUnits , const vector < double >& timeVar , const vector < string >& stationIds , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes , const string & leadTimeUnits = \"\" ); void DefineMandatoryDimensions ( size_t nEns , size_t nLead , size_t nStations ); void DefineDimVariables (); void DefineVariables (); void WriteCommonVarData (); int AddGlobalAttribute ( const string & attName , const string & attValue ); int AddGlobalAttribute ( const string & attName , double attValue ); int AddGlobalAttribute ( char * attName , char * attValue ); int AddAttribute ( int varId , const string & attName , const string & attValue ); int AddAttribute ( int varId , const string & attName , int attValue ); int AddAttribute ( int varId , const string & attName , double attValue ); void AddVariableAttributes ( int varId , const VariableAttributes & varAttributes ); void AddVariableAttributes ( int varId , const string & longName , const string & units , int type , const string & typeDescription , const string & datType , const string & datDescription , double fillValue , const string & locationType ); void AddAttributes ( int varId , const string & varName , std :: map < string , VariableAttributes >& varAttributes ); void FillAttributes ( const GlobalAttributes & globalAttributes , const string & timeUnits , const string & leadTimeUnits ); void SetTimeVar ( const vector < double >& timeVar ); void SetLeadTimeVar ( const vector < double >& leadTimeVar ); void InquireDimIds (); void InquireDimVarIds (); size_t InquireDimLength ( int dimId ); size_t GetNumDims ( const string & ncVarName ); void ReadTimeUnits (); vector < string > * GetStringVariable ( size_t strLen , int varId , size_t n ); nc_type GetDataType ( int variableId ); vector < int > ReadAsInt ( int varId , size_t size ); vector < float > ReadAsFloat ( int varId , size_t size , bool strict = true ); vector < double > ReadAsDouble ( int varId , size_t size ); void ErrorLossPrecision ( int varId ); /* template<class T> vector<T> GetVariable(int varId, size_t n) { if (varId < 0) return nullptr; T* result = new T[n]; int code = nc_get_var(ncid, varId, result); if (code != NC_NOERR) { delete[] result; return nullptr; } return result; } */ template < class T > void SetVariableDimOne ( int varId , T * values , size_t n ) { if ( values == nullptr ) ExceptionUtilities :: ThrowInvalidArgument ( \"SwiftNetCDFAccess::SetVariableDimOne: values cannot be a nullptr\" ); if ( n <= 0 ) ExceptionUtilities :: ThrowInvalidArgument ( \"SwiftNetCDFAccess::SetVariableDimOne: data size must be strictly positive\" ); //if (varId < 0) return nullptr; const size_t startp [ 1 ] = { 0 }; const size_t countp [ 1 ] = { ( size_t ) n }; int code = NcPutVara < T > ( ncid , varId , & ( startp [ 0 ]), & ( countp [ 0 ]), values ); if ( code != NC_NOERR ) { ExceptionUtilities :: ThrowInvalidOperation ( \"SetVariableDimOne failed for variable ID \" + std :: to_string ( varId )); } } template < class T > void SetVariableDimOne ( int varId , vector < T > values ) { SetVariableDimOne < T > ( varId , values . data (), values . size ()); } template < class T > vector < T > GetVariableDimOne ( int varId , size_t n ) { if ( n <= 0 ) ExceptionUtilities :: ThrowInvalidArgument ( \"SwiftNetCDFAccess::GetVariableDimOne: data size must be strictly positive\" ); //if (varId < 0) return nullptr; const size_t startp [ 1 ] = { 0 }; const size_t countp [ 1 ] = { ( size_t ) n }; T * values = new T [ n ]; int code = NcGetVara < T > ( ncid , varId , & ( startp [ 0 ]), & ( countp [ 0 ]), values ); if ( code != NC_NOERR ) { delete values ; ExceptionUtilities :: ThrowInvalidOperation ( \"SetVariableDimOne failed for variable ID \" + std :: to_string ( varId )); } vector < T > result = ToVector ( values , n ); delete values ; return result ; } template < class T , class TStored > vector < T > GetVariableDimOne ( int varId , size_t n ) { vector < T > result ( n ); vector < TStored > tmp = GetVariableDimOne < TStored > ( varId , n ); for ( int i = 0 ; i < n ; i ++ ) { result [ i ] = static_cast < T > ( tmp [ i ]); } return result ; } template < class T , class TStored > void SetVariable ( int varId , T * values , size_t n ) { if ( values == nullptr ) ExceptionUtilities :: ThrowInvalidArgument ( \"SwiftNetCDFAccess::SetVariable: values cannot be a nullptr\" ); TStored * tmp = new TStored [ n ]; for ( int i = 0 ; i < n ; i ++ ) { tmp [ i ] = static_cast < TStored > ( values [ i ]); } SetVariable < TStored > ( varId , tmp , n ); delete [] tmp ; } void GetEnsFcastNetcdfWindow ( const string & varName , size_t stationIndex , size_t timeIndex , vector < size_t >& startp , vector < size_t >& countp ); // void GetEnsNetcdfWindow(size_t stationIndex, vector<size_t>& startp, vector<size_t>& countp); void GetNetcdfWindow ( const string & varName , size_t stationIndex , vector < size_t >& startp , vector < size_t >& countp ); void GetNetcdfWindow ( const string & varName , vector < size_t >& startp , vector < size_t >& countp ); int GetVarId ( const string & varName ); double * GetForecastDataBuffer ( size_t numStations = 1 , size_t numTimeSteps = 1 ); double * GetEnsembleDataBuffer ( size_t numStations , size_t numTimeSteps ); double * GetSingleSeriesDataBuffer ( size_t numStations , size_t numTimeSteps ); int ncid = -1 ; int timeDimId , stationDimId , leadTimeDimId , ensMemberDimId , strLenDimId ; int timeVarId = -1 , stationNameVarId = -1 , stationIdVarId = -1 , leadTimeVarId = -1 , ensMemberVarId = -1 , latVarId = -1 , lonVarId = -1 , elevationVarId = -1 ; ptime startDate ; string timeUnits ; TimeStep timeStep ; TimeStep leadTimeStep ; bool cachedTimeStep = false ; bool cachedLeadTimeStep = false ; size_t /*numTimeSteps, */ numStations , strLen ; bool cachedTimeVector = false ; vector < ptime > ptimeVec ; vector < string > * stationNames = nullptr ; vector < string > * variableVarNames = nullptr ; // TODO suggest this is strings vector < int > stationIds ; vector < double > stationLat ; vector < double > stationLon ; vector < double > stationElevation ; vector < float > leadTimeVec /*= nullptr*/ ; size_t leadTimeLength ; vector < float > timeVec /*= nullptr*/ ; size_t numTimeSteps ; bool geometryRead = false ; vector < int > variableVarIds ; //int stepMultiplier ; size_t ensembleSize ; string catchmentName ; //vector<string> variableNames; //std::map<string, VariableAttributes> variableAttributes; std :: map < string , VariableDefinition > variableDefinitions ; }; class DATATYPES_DLL_LIB ConfigFileHelper { using string = std :: string ; private : ConfigFileHelper (); public : static const string FileKey ; static const string VarKey ; static const string IdentifierKey ; static const string IdDataKey ; static const string IndexKey ; static const string TypeKey ; static const string TimeStepKey ; static const string StartKey ; static const string LengthKey ; static const string EnsembleSizeKey ; static const string EnsembleLengthKey ; static const string EnsembleTimeStepKey ; static const string FilePatternKey ; static const string MappingKey ; static const string StorageKey ; static const string SingleSeriesTypeId ; static const string EnsembleSeriesTypeId ; static const string TimeSeriesEnsemblesTypeId ; static const string SingleSeriesCollectionTypeId ; static const string StorageTypeSingleNetcdfFile ; static const string StorageTypeMultipleNetcdfFiles ; static TimeSeriesLibraryDescription LoadTimeSeriesLibraryDescription ( const string & filename , const string & dataPath = \"\" , TimeSeriesSourceInfoBuilder * srcBuilder = nullptr ); static void SaveTimeSeriesLibraryDescription ( const TimeSeriesLibraryDescription & config , const string & filename ); static string FileName ( const YAML :: Node & storage ); static string FullFileName ( const YAML :: Node & storage , const TimeSeriesLibraryDescription & tsl ); private : static bool PreCheckStorageType ( const string & storageType , TimeSeriesSourceInfoBuilder * srcBuilder = nullptr ); }; } using namespace datatypes :: timeseries :: io ; template < typename TElement > DimensionsDefinitions DimensionsFromPointTimeSeries ( const TTimeSeries < TElement >& ts ) { string timeUnits = SwiftNetCDFAccess :: CreateTimeUnitsAttribute ( ts . GetStartDate (), ts . GetTimeStep ()); auto timeVar = datatypes :: utils :: SeqVec < double > ( 0 , 1 , ts . GetLength ()); return DimensionsDefinitions ( timeUnits , timeVar ); } //template <typename T> //class DATATYPES_DLL_LIB NetCdfSingleSeriesStore //{ // // //public: // /** // * \\brief Constructor. // * // * \\param [in] dataAccess SWIFT netCDF data access object to read/write the back end file. // * \\param varName Name of the variable for this time series (the netCDF back end may have several variables). // * \\param identifier The identifier. // */ // NetCdfSingleSeriesStore(SwiftNetCDFAccess * dataAccess, const string& varName, const string& identifier) // { // this->dataAccess = dataAccess; // this->varName = varName; // this->identifier = identifier; // this->stationIndex = this->GetNcAccess()->IndexForIdentifier(identifier); // } // /** // * \\brief Gets the ensemble forecast for a given index in the time dimension // * // * \\param i Zero-based index of the time step of interest. // * // * \\return a pointer to a new MultiTimeSeries. // */ // MultiTimeSeries<TimeSeries*> * GetForecasts(int i) // { // auto series = this->GetNcAccess()->GetForecasts<T>(varName, stationIndex, i); // auto result = new MultiTimeSeries<TimeSeries*>(*series, this->GetLeadTimeCount(), this->GetNcAccess()->TimeForIndex(i), this->GetTimeStep()); // for (auto& d : (*series)) // { // if (d != nullptr) delete[] d; // } // delete series; // return result; // } // /** // * \\brief Gets a non-ensemble time series. There must be such a record, otherwise an exception is thrown. // * // * \\return null if it fails, else the series. // */ // TTimeSeries<T> * GetSeries() // { // auto values = this->GetNcAccess()->GetValues<T>(varName, stationIndex); // auto result = new TTimeSeries<T>(values, this->GetTimeLength(), this->TimeForIndex(0), this->GetTimeStep()); // delete values; // return result; // } // MultiTimeSeries<TimeSeries*> * GetEnsembleSeries() // { // auto series = this->GetNcAccess()->GetEnsemble<T>(varName, stationIndex); // auto result = new MultiTimeSeries<TimeSeries*>(*series, this->GetTimeLength(), this->TimeForIndex(0), this->GetTimeStep()); // for (auto& d : (*series)) // { // if (d != nullptr) delete[] d; // } // delete series; // return result; // } // void SetForecasts(int i, MultiTimeSeries<TimeSeries*> * forecasts) // { // this->GetNcAccess()->WriteForecastsVarData(); // auto values = forecasts->GetValues(); // this->GetNcAccess()->SetForecasts(varName, stationIndex, i, (*values)); // for (auto& d : (*values)) // { // if (d != nullptr) delete[] d; // } // delete values; // } // void SetEnsemble(MultiTimeSeries<TimeSeries*> * ensemble) // { // this->GetNcAccess()->WriteEnsembleVarData(); // vector<T*>* values = ensemble->GetValues(); // this->GetNcAccess()->SetEnsembles(varName, stationIndex, *values); // for (T* data : *values) // if (data != nullptr) delete[] data; // delete values; // } // void SetSeries(TTimeSeries<T> * timeSeries) // { // this->GetNcAccess()->WriteSingleSeriesVarData(); // T* values = timeSeries->GetValues(); // this->GetNcAccess()->SetValues(varName, stationIndex, values); // delete[] values; // } // int GetEnsembleSize() // { // return this->GetNcAccess()->GetEnsembleSize(varName); // } // int GetLeadTimeCount() // { // return this->GetNcAccess()->GetLeadTimeCount(varName); // } // int GetTimeLength() // { // return this->GetNcAccess()->GetTimeLength(); // } // TimeStep GetTimeStep() // { // return this->GetNcAccess()->GetTimeStep(); // } // ptime TimeForIndex(size_t timeIndex) // { // return this->GetNcAccess()->TimeForIndex(timeIndex); // } //private: // SwiftNetCDFAccess * dataAccess = nullptr; // string varName; // string identifier; // size_t stationIndex; //}; //template <typename T = double> //class DATATYPES_DLL_LIB NetCdfSingleSeriesStoreStore //{ // // //public: // /** // * \\brief Create a wrapper time series store around an existing SWIFT netCDF file. // * // * \\param filename Filename of the file. // */ // NetCdfSingleSeriesStoreStore(const string& filename) // { // dataAccess = new SwiftNetCDFAccess(filename); // } // /** // *\\brief Constructor to create a new SWIFT netCDF file // * // * \\param filename name of the new file to create. // * \\param nEns Size of the ensembles // * \\param nLead Length of the lead time for each of the time series in the ensemble forecast for a given time. // * \\param timeUnits Units of the temporal dimension(s). // * \\param[in] timeVar The values of the \"main\" time dimension, consistent with the temporal units given with the previous parameter // * \\param[in] stationIds List of identifiers for the stations. // * \\param[in] varNames List of names of the variables. // * \\param[in] varAttributes Attributes for each variables; the keys of the dictionary must be found in the varNames parameter. // */ // NetCdfSingleSeriesStoreStore(const string& filename, size_t nEns, size_t nLead, const string& timeUnits, vector<double>& timeVar, vector<string>& stationIds, vector<string>& varNames, // std::map<string, VariableAttributes>& varAttributes = std::map<string, VariableAttributes>()) // { // dataAccess = new SwiftNetCDFAccess(filename, nEns, nLead, timeUnits, timeVar, stationIds, varNames, varAttributes); // } // ~NetCdfSingleSeriesStoreStore() // { // Close(); // } // void Close() // { // if (dataAccess != nullptr) // { // delete dataAccess; // dataAccess = nullptr; // } // } // /** // * \\brief Create an univariate SWIFT netCDF time series using this netCDF time series store. // * // * \\param varName Name of the variable. // * \\param identifier The identifier; e.g. a catchment identifier. // * \\param dimIdent (Optional) name of the dimension in which to look for the location identifier (e.g. catchment identifier). Defaults to 'station_id' as per SWIFT netCDF schema // * \\param startTime (Optional) the start time. If null (default), the start time of the whole data set is used. // * \\param leadTimeCount (Optional) number of lead times to read. If negative (default), the maximum number of lead times returned by GetLeadTimeCount() // * // * \\return null if it fails, else a NetCdfSingleSeriesStore&lt;T&gt;*. // */ // NetCdfSingleSeriesStore<T> * Get(const string& varName, const string& identifier, const string& dimIdent = \"station_id\", const ptime* startTime = nullptr, int leadTimeCount = -1) // { // return new NetCdfSingleSeriesStore<T>(dataAccess, varName, identifier); // } // //void Set(NetCdfSingleSeriesStore<T> * series, const string& varName, const string& identifier, const string& dimIdent = \"station_id\", const ptime* startTime = nullptr, int leadTimeCount = -1); //private: // SwiftNetCDFAccess * dataAccess = nullptr; //}; template < typename T > class DATATYPES_DLL_LIB TimeSeriesIOHelper { public : using SeriesType = typename CommonTypes < T >:: SeriesType ; using PtrSeriesType = typename CommonTypes < T >:: PtrSeriesType ; using EnsemblePtrType = typename CommonTypes < T >:: EnsemblePtrType ; using PtrEnsemblePtrType = typename CommonTypes < T >:: PtrEnsemblePtrType ; using TSeriesEnsemblePtrType = typename CommonTypes < T >:: TSeriesEnsemblePtrType ; using PtrTSeriesEnsemblePtrType = typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType ; static SeriesType * Read ( const string & netCdfFilePath , const string & varName , const string & identifier ); static void Write ( const string & varName , std :: map < string , TTimeSeries < T >*>& recordedTimeSeries , const std :: map < string , string >& idMap , const string & filePath ); static void Write ( DimensionsDefinitions & dimDefinitions , const map < std :: string , VariableDefinition >& varDefinitions , const GlobalAttributes & GlobalAttributes , std :: map < string , TTimeSeries < T >*>& recordedTimeSeries , const string & filePath ); static PtrEnsemblePtrType ReadForecastTimeSeries ( const string & netCdfFilepath , const string & varName , const string & identifier , int index ); static PtrTSeriesEnsemblePtrType ReadForecastTimeSeries ( const string & netCdfFilepath , const string & varName , const string & identifier ); static SeriesType * Read ( const string & netCdfFilePath , const string & varName , const string & identifier , const TimeWindow < SeriesType >& window ) { auto tmp = Read ( netCdfFilePath , varName , identifier ); auto result = window . Trim ( * tmp ); delete tmp ; return result ; } static SeriesType * ReadDailyToHourly ( const string & netCdfFilePath , const string & varName , const string & identifier , const TimeWindow < SeriesType >& window ) { TTimeSeries < T >* fullDailyObsPetTimeSeries = Read ( netCdfFilePath , varName , identifier ); TTimeSeries < T >* fullHourlyObsPetTimeSeries = TimeSeriesOperations < SeriesType >:: DailyToHourly ( * fullDailyObsPetTimeSeries ); auto result = window . Trim ( * fullHourlyObsPetTimeSeries ); delete fullDailyObsPetTimeSeries ; delete fullHourlyObsPetTimeSeries ; return result ; } }; template < typename T > class /*DATATYPES_DLL_LIB*/ SingleNetCdfFileStore { private : string ncVarName ; string identifier ; SwiftNetCDFAccess * dataAccess = nullptr ; string fileName ; protected : SingleNetCdfFileStore () {} SingleNetCdfFileStore ( const string & fname , const size_t nEns , const vector < double >& leadTimeVar , const string & timeUnits , const vector < double >& timeVar , const vector < string >& stationIds , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName = \"\" , const string & identifier = \"\" , const string & leadTimeUnits = \"\" ) : ncVarName ( ncVarName ), identifier ( identifier ), fileName ( fname ) { dataAccess = new SwiftNetCDFAccess ( fname , nEns , leadTimeVar , timeUnits , timeVar , stationIds , varDefinitions , globalAttributes , leadTimeUnits ); } SingleNetCdfFileStore ( const string & fname , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName = \"\" , const string & identifier = \"\" ) : ncVarName ( ncVarName ), identifier ( identifier ), fileName ( fname ) { dataAccess = new SwiftNetCDFAccess ( fname , dimDefinitions , varDefinitions , globalAttributes ); } SingleNetCdfFileStore ( const string & fname , const string & ncVarName = \"\" , const string & identifier = \"\" , bool writeMode = false ) : ncVarName ( ncVarName ), identifier ( identifier ), fileName ( fname ) { if ( ! writeMode ) dataAccess = new SwiftNetCDFAccess ( fname ); } void Init ( const string & filename , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes ) { if ( dataAccess != nullptr ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"netCDF single file store already bound to a netCDF file\" ); dataAccess = new SwiftNetCDFAccess ( filename , dimDefinitions , varDefinitions , globalAttributes ); } void MoveFrom ( SingleNetCdfFileStore & src ) { std :: swap ( dataAccess , src . dataAccess ); std :: swap ( fileName , src . fileName ); std :: swap ( identifier , src . identifier ); std :: swap ( ncVarName , src . ncVarName ); } void CopyFrom ( const SingleNetCdfFileStore & src ) { ExceptionUtilities :: ThrowNotSupported ( \"Deep copy operations are not supported\" ); } string GetNcVarName ( bool allowDiscovery = true ) const { string varName = ncVarName ; const bool removeReservedVarnames = true ; if ( varName . empty () && allowDiscovery ) { vector < string > v = this -> GetNcAccess () -> ReadVariableNames ( removeReservedVarnames ); if ( v . size () == 1 ) varName = v [ 0 ]; else if ( v . size () > 1 ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation (); else if ( v . empty ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation (); } return varName ; } string DataSummaryForIdentifier () const { if ( identifier . empty ()) return string ( \", identifier: <NA>\" ); else return string ( \", identifier: \" ) + this -> GetIdentifier (); } string GetDefaultDataSummary () const { auto start = this -> GetStart (); auto end = this -> GetEnd (); string result = string ( \"variable name: \" ) + this -> GetNcVarName () + DataSummaryForIdentifier () + string ( \", start: \" ) + to_iso_extended_string ( start ) + string ( \", end: \" ) + to_iso_extended_string ( end ) + string ( \", time length: \" ) + std :: to_string ( this -> GetNcAccess () -> GetTimeLength ()) + string ( \", time step: \" ) + this -> GetNcAccess () -> GetTimeStep (). GetName (); return result ; } size_t IndexForIdentifier ( bool strict = true ) const { if ( identifier . empty ()) { if ( strict ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"This netCDF data provider does not have a unique identifier (station ID)\" ); } // TODO: reassess how to deal with it, if really acceptable if ( GetNcAccess () -> GetNumIdentifiers () == 1 ) return 0 ; } return IndexForIdentifier ( this -> identifier ); } virtual bool HasIdentifier () const { return ( ! identifier . empty ()); } virtual string GetIdentifier ( bool strict = true ) const { if ( identifier . empty ()) { if ( strict ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"This netCDF data provider does not have a unique identifier (station ID)\" ); } // TODO: reassess how to deal with it, if really acceptable if ( GetNcAccess () -> GetNumIdentifiers () == 1 ) { auto ids = GetIdentifiers (); if ( ids . size () == 1 ) return ids [ 0 ]; datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"Inconsistency between netCDF claimed number of identifiers and retrieved list\" ); } } return this -> identifier ; } void SetIdentifier ( string ident ) { this -> identifier = ident ; } virtual vector < string > GetIdentifiers () const { if ( identifier . empty ()) { // TODO: reassess how to deal with it, if really acceptable return GetNcAccess () -> GetIdentifiers (); } else return vector < string > ({ this -> identifier }); } SwiftNetCDFAccess * GetNcAccess () const { if ( dataAccess == nullptr ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"The low level swift netCDF data access is a nullptr\" ); return dataAccess ; } string & GetFileName () { return fileName ; } public : virtual ~ SingleNetCdfFileStore () { Close (); } virtual void Close () { if ( dataAccess != nullptr ) { delete dataAccess ; dataAccess = nullptr ; } } bool HasNcAccess () { return ( dataAccess != nullptr ); } size_t GetEnsembleSize () const { auto v = GetNcVarName ( false ); if ( v . empty ()) return this -> GetNcAccess () -> GetEnsembleSize (); return this -> GetNcAccess () -> GetEnsembleSize ( this -> GetNcVarName ()); } size_t GetLeadTimeCount () const { auto v = GetNcVarName ( false ); if ( v . empty ()) return this -> GetNcAccess () -> GetLeadTimeCount (); return this -> GetNcAccess () -> GetLeadTimeCount ( this -> GetNcVarName ()); } size_t GetTimeLength () const { return this -> GetNcAccess () -> GetTimeLength (); } TimeStep GetTimeStep () const { return this -> GetNcAccess () -> GetTimeStep (); } ptime TimeForIndex ( size_t timeIndex ) const { return this -> GetNcAccess () -> TimeForIndex ( timeIndex ); } vector < ptime > GetTimeDim () const { return this -> GetNcAccess () -> GetTimeDim (); } vector < double > GetLeadTimeDim () const { return this -> GetNcAccess () -> GetLeadTimeDim (); } ptime GetStart () const { return this -> GetNcAccess () -> GetStart (); } ptime GetEnd () const { return this -> GetNcAccess () -> GetEnd (); } size_t IndexForIdentifier ( const string & identifier ) const { return this -> GetNcAccess () -> IndexForIdentifier ( identifier ); } //vector<string> GetIdentifiers() const //{ // return this->GetNcAccess()->GetIdentifiers(); //} VariableAttributes GetVarAttributes () { std :: string ncVarName = GetNcVarName (); return this -> GetNcAccess () -> GetAttributes ( ncVarName ); } GlobalAttributes GetGlobalAttributes () { return this -> GetNcAccess () -> GetGlobalAttributes (); } }; template < typename T > class /*DATATYPES_DLL_LIB*/ NetCdfSingleSeriesStore : public SingleTimeSeriesStore < T > , public SingleNetCdfFileStore < T > { // public : NetCdfSingleSeriesStore ( const string & filename , const size_t nEns , const vector < double >& leadTimeVar , const string & timeUnits , const vector < double >& timeVar , const vector < string >& stationIds , const std :: map < string , VariableDefinition >& varDefinitions , const string & ncVarName , const string & identifier = \"\" , const string & leadTimeUnits = \"\" ) : SingleNetCdfFileStore < T > ( filename , nEns , leadTimeVar , timeUnits , timeVar , stationIds , varDefinitions , ncVarName , identifier , leadTimeUnits ) { } NetCdfSingleSeriesStore ( const string & filename , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName , const string & identifier = \"\" ) : SingleNetCdfFileStore < T > ( filename , dimDefinitions , varDefinitions , globalAttributes , ncVarName , identifier ) { } NetCdfSingleSeriesStore ( const string & fname ) : SingleNetCdfFileStore < T > ( fname ) { } NetCdfSingleSeriesStore ( const string & fname , const string & ncVarName , const string & identifier = \"\" ) : SingleNetCdfFileStore < T > ( fname , ncVarName , identifier ) { } NetCdfSingleSeriesStore & operator = ( NetCdfSingleSeriesStore && src ) { // Avoid self assignment if ( & src == this ) { return * this ; } SingleNetCdfFileStore < T >:: MoveFrom ( src ); return * this ; } NetCdfSingleSeriesStore & operator = ( const NetCdfSingleSeriesStore & src ) { if ( & src == this ) { return * this ; } SingleNetCdfFileStore < T >:: CopyFrom ( src ); return * this ; } NetCdfSingleSeriesStore ( NetCdfSingleSeriesStore && src ) { * this = src ; } NetCdfSingleSeriesStore ( const NetCdfSingleSeriesStore & src ) { * this = src ; } static string Dimensions () { return \"2\" ; } string GetDataSummary () const { return SingleNetCdfFileStore < T >:: GetDefaultDataSummary (); } vector < DataDimensionDescriptor > GetDataDimensionsDescription () const { vector < DataDimensionDescriptor > d ; if ( ! this -> HasIdentifier ()) d . push_back ( DataDimensionDescriptor ( COLLECTION_DIM_TYPE_DATA_DIMENSION )); d . push_back ( DataDimensionDescriptor ( TIME_DIM_TYPE_DATA_DIMENSION )); return d ; } TTimeSeries < T >* Read () { return Read ( this -> GetIdentifier ()); } TTimeSeries < T >* Read ( const string & identifier ) { if ( identifier == string ( \"\" )) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"Cannot get a time series if no identifier is provided.\" ); int index = static_cast < int > ( this -> IndexForIdentifier ( identifier )); if ( index < 0 ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"Index not found for data identifier: \" + identifier ); // Need to disambiguate the call to the template method GetSeries for GCC, somehow. Even if this does not look ambiguous. // See e.g. http://stackoverflow.com/questions/15572415/expected-primary-expression-before-in-g-but-not-in-microsoft-compiler return this -> GetNcAccess () -> template GetSeries < T > ( this -> GetNcVarName (), index ); } MultiTimeSeries < TTimeSeries < T >*>* ReadAllCollection () { MultiTimeSeries < TTimeSeries < T >*>* result = new MultiTimeSeries < TTimeSeries < T >*> (); // Need to disambiguate the call to the template method GetSeries for GCC, somehow. Even if this does not look ambiguous. // See e.g. http://stackoverflow.com/questions/15572415/expected-primary-expression-before-in-g-but-not-in-microsoft-compiler return this -> GetNcAccess () -> template GetSeries < T > ( this -> GetNcVarName ()); } void Write ( TTimeSeries < T > * timeSeries ) { vector < T > values = timeSeries -> GetValuesVector (); this -> GetNcAccess () -> template SetValues < T > ( this -> GetNcVarName (), this -> IndexForIdentifier (), values ); } vector < TTimeSeries < T >*> ReorderPerIdentifier ( const std :: map < string , TTimeSeries < T >*>& toSave ) { vector < string > ids = this -> GetNcAccess () -> GetIdentifiers (); return datatypes :: utils :: STLHelper :: SortValues ( toSave , ids ); } vector < T > Serialize ( const vector < TTimeSeries < T >*>& series ) { vector < vector < T >> v ; for ( size_t i = 0 ; i < series . size (); i ++ ) { v . push_back ( series [ i ] -> GetValuesVector ()); } return datatypes :: utils :: STLHelper :: Serialize ( v ); } void WriteToIdentifiers ( const std :: map < string , TTimeSeries < T >*>& toSave ) { vector < TTimeSeries < T >*> series = ReorderPerIdentifier ( toSave ); vector < T > values = Serialize ( series ); this -> GetNcAccess () -> template SetValues < T > ( this -> GetNcVarName (), values ); } void WriteToNcVariables ( const std :: map < string , TTimeSeries < T >*>& toSave ) { for ( auto & kvp : toSave ) { TTimeSeries < T >* ptr = kvp . second ; if ( ptr != nullptr ) this -> GetNcAccess () -> template SetValues < T > ( kvp . first , 0 , ptr -> GetValuesVector ()); } } vector < string > GetIdentifiers () const { return SingleNetCdfFileStore < T >:: GetIdentifiers (); vector < string > x = { SingleNetCdfFileStore < T >:: GetIdentifier () }; return x ; } }; template < typename T > class /*DATATYPES_DLL_LIB*/ NetCdfEnsembleTimeSeriesStore : public EnsembleTimeSeriesStore < T > , public SingleNetCdfFileStore < T > { // public : NetCdfEnsembleTimeSeriesStore ( const string & filename , const size_t nEns , const vector < double >& leadTimeVar , const string & timeUnits , const vector < double >& timeVar , const vector < string >& stationIds , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName , const string & identifier = \"\" , const string & leadTimeUnits = \"\" ) : SingleNetCdfFileStore < T > ( filename , nEns , leadTimeVar , timeUnits , timeVar , stationIds , varDefinitions , globalAttributes , ncVarName , identifier , leadTimeUnits ) { } NetCdfEnsembleTimeSeriesStore ( const string & filename , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName , const string & identifier = \"\" ) : SingleNetCdfFileStore < T > ( filename , dimDefinitions , varDefinitions , globalAttributes , ncVarName , identifier ) { } NetCdfEnsembleTimeSeriesStore ( const string & fname , const string & ncVarName , const string & identifier = \"\" ) : SingleNetCdfFileStore < T > ( fname , ncVarName , identifier ) { } static string Dimensions () { return DATATYPES_THREE_DIMENSIONS_DATA ; } string GetDataSummary () const { return SingleNetCdfFileStore < T >:: GetDefaultDataSummary (); } vector < DataDimensionDescriptor > GetDataDimensionsDescription () const { return { DataDimensionDescriptor ( ENSEMBLE_DIM_TYPE_DATA_DIMENSION ), DataDimensionDescriptor ( TIME_DIM_TYPE_DATA_DIMENSION ) }; } vector < string > GetIdentifiers () const { return SingleNetCdfFileStore < T >:: GetIdentifiers (); vector < string > x = { SingleNetCdfFileStore < T >:: GetIdentifier () }; return x ; } MultiTimeSeries < TTimeSeries < T >*>* Read () { return this -> GetNcAccess () -> template GetEnsembleSeries < T > ( this -> GetNcVarName (), this -> IndexForIdentifier ()); } void Write ( MultiTimeSeries < TTimeSeries < T >*> * ensemble ) { size_t stationIndex = this -> IndexForIdentifier (); vector < T *>* values = ensemble -> GetValues (); this -> GetNcAccess () -> SetEnsembles ( this -> GetNcVarName (), stationIndex , * values ); for ( T * data : * values ) if ( data != nullptr ) delete [] data ; delete values ; } }; template < typename StorageType > class EagerWriter : public StoragePolicy < StorageType > { public : using EnsemblePtrType = typename TimeSeriesEnsembleTimeSeriesStore < double >:: EnsemblePtrType ; using PtrEnsemblePtrType = StorageType ; using ElementType = typename EnsemblePtrType :: ElementType ; using TsType = EnsemblePtrType :: ItemType ; private : vector < PtrEnsemblePtrType > ensemblesProxies ; WritableTimeSeriesEnsembleTimeSeriesStore < ElementType > * store ; void resetProxies () { if ( store -> IsActive ()) resetProxies ( store -> GetLength ()); } void resetProxies ( size_t length ) { for ( size_t i = 0 ; i < ensemblesProxies . size (); i ++ ) { PtrEnsemblePtrType ptr = ensemblesProxies [ i ]; if ( ptr != nullptr ) delete ptr ; } ensemblesProxies . assign ( length , nullptr ); } public : EagerWriter ( WritableTimeSeriesEnsembleTimeSeriesStore < ElementType > * store ) { if ( store == nullptr ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"store must not be nullptr for an EagerWriter\" ); this -> store = store ; resetProxies (); } EagerWriter ( const EagerWriter & src ) { this -> store = src . store ; resetProxies (); } bool ReadOnly () override { return ! store -> IsActive (); } size_t Size () const { return store -> GetLength (); } void Allocate ( size_t length , PtrEnsemblePtrType value ) { store -> Allocate ( length , value ); resetProxies (); } void AllocateValues ( size_t length , const PtrEnsemblePtrType * values ) { store -> AllocateValues ( length , values ); resetProxies (); } void AllocateValues ( const vector < PtrEnsemblePtrType >& values ) { store -> AllocateValues ( values ); resetProxies (); } void CopyTo ( vector < PtrEnsemblePtrType >& dest , size_t from = 0 , size_t to = -1 ) const { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); //CheckIntervalBounds(from, to); //size_t len = (to - from) + 1; //if (dest.size() != len) //{ // dest.clear(); // dest.resize(len); //}; //for (size_t i = 0; i < len; i++) //{ // dest[i] = (data[i] == nullptr ? store.ReadAt(i) : data[i]); //} } private : void CheckDataItemRange ( const size_t i ) const { datatypes :: exceptions :: ExceptionUtilities :: CheckInRange < size_t > ( i , 0 , store -> GetLength (), \"index\" ); } public : PtrEnsemblePtrType & GetProxy ( const size_t i ) { CheckDataItemRange ( i ); auto proxy = ensemblesProxies [ i ]; if ( proxy == nullptr ) { auto s = new TimeSeriesEnsembleTimeSeriesStoragePolicy < TsType > ( store , i ); proxy = new EnsemblePtrType ( s ); ensemblesProxies [ i ] = proxy ; } return ensemblesProxies [ i ]; } PtrEnsemblePtrType & operator []( const size_t i ) { return GetProxy ( i ); } private : PtrEnsemblePtrType dummy ; // to compile... public : const PtrEnsemblePtrType & operator []( const size_t i ) const { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented ( \"Not sure how to implement this, if at all possible, sorry\" ); return dummy ; // to compile... } StoragePolicy < PtrEnsemblePtrType >* Clone () const { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotSupported ( \"EagerWriter\" , \"Clone\" ); return nullptr ; } size_t GetLength () const { return store -> GetLength (); } TimeStep GetTimeStep () const override { return store -> GetTimeStep (); } ptime GetStart () const override { return store -> GetStart (); } void SetTimeStep ( const TimeStep & tStep ) override { store -> SetTimeStep ( tStep ); } void SetStart ( const ptime & start ) override { store -> SetStart ( start ); } }; template < typename T = double > class /*DATATYPES_DLL_LIB*/ NetCdfTimeSeriesEnsembleTimeSeriesStore : public WritableTimeSeriesEnsembleTimeSeriesStore < T > , public SingleNetCdfFileStore < T > { public : NetCdfTimeSeriesEnsembleTimeSeriesStore ( const string & filename , const size_t nEns , const vector < double >& leadTimeVar , const string & timeUnits , const vector < double >& timeVar , const vector < string >& stationIds , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName , const string & identifier = \"\" ) : SingleNetCdfFileStore < T > ( filename , nEns , leadTimeVar , timeUnits , timeVar , stationIds , varDefinitions , globalAttributes , ncVarName , identifier ) { } NetCdfTimeSeriesEnsembleTimeSeriesStore ( const string & filename , const DimensionsDefinitions & dimDefinitions , const std :: map < string , VariableDefinition >& varDefinitions , const GlobalAttributes & globalAttributes , const string & ncVarName , const string & identifier = \"\" ) : SingleNetCdfFileStore < T > ( filename , dimDefinitions , varDefinitions , globalAttributes , ncVarName , identifier ) { } NetCdfTimeSeriesEnsembleTimeSeriesStore ( const string & fname , const string & ncVarName , const string & varIdentifier , bool writeMode = false ) : SingleNetCdfFileStore < T > ( fname , ncVarName , varIdentifier , writeMode ) { } static string Dimensions () { return DATATYPES_FOUR_DIMENSIONS_DATA ; } using SeriesType = typename CommonTypes < T >:: SeriesType ; using PtrSeriesType = typename CommonTypes < T >:: PtrSeriesType ; using EnsemblePtrType = typename CommonTypes < T >:: EnsemblePtrType ; using PtrEnsemblePtrType = typename CommonTypes < T >:: PtrEnsemblePtrType ; using TSeriesEnsemblePtrType = typename CommonTypes < T >:: TSeriesEnsemblePtrType ; using PtrTSeriesEnsemblePtrType = typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType ; using ElementType = typename EnsemblePtrType :: ElementType ; private : EnsembleForecastTimeSeries < TTimeSeries < T > >* ReadSeriesFromFile ( const string & dataId ) { EnsembleForecastTimeSeries < TTimeSeries < T >>* result ; size_t dataLength = this -> GetLength (); ptime start = this -> GetStart (); TimeStep step = this -> GetTimeStep (); result = new EnsembleForecastTimeSeries < TTimeSeries < T >> ( dataLength , start , step ); for ( size_t i = 0 ; i < dataLength ; i ++ ) { auto rawTs = this -> GetForecasts ( i ); result -> SetValue ( i , rawTs ); } return result ; } EnsembleForecastTimeSeries < SeriesType >* CreateWriteProxy ( const string & dataId ) { StoragePolicy < PtrEnsemblePtrType > * s = new EagerWriter < PtrEnsemblePtrType > ( this ); return new EnsembleForecastTimeSeries < SeriesType > ( s ); } public : virtual EnsembleForecastTimeSeries < TTimeSeries < T > >* GetSeries ( const string & dataId ) { EnsembleForecastTimeSeries < TTimeSeries < T >>* result ; if ( this -> HasNcAccess ()) result = ReadSeriesFromFile ( dataId ); else result = CreateWriteProxy ( dataId ); return result ; } vector < string > GetIdentifiers () const { return SingleNetCdfFileStore < T >:: GetIdentifiers (); vector < string > x = { SingleNetCdfFileStore < T >:: GetIdentifier () }; return x ; } void SetIdentifier ( string ident ) { SingleNetCdfFileStore < T >:: SetIdentifier ( ident ); } PtrEnsemblePtrType GetForecasts ( size_t i ) { size_t stationIndex = this -> IndexForIdentifier ( false ); auto nc = this -> GetNcAccess (); ptime issueTime = GetTimeForIndex ( i ); std :: pair < ptime , TimeStep > fcastGeom = nc -> GetLeadTimeGeometry ( issueTime ); vector < ElementType *>* series = nc -> template GetForecasts < T > ( this -> GetNcVarName (), stationIndex , i ); auto result = new EnsemblePtrType ( * series , this -> GetLeadTimeCount (), fcastGeom . first , fcastGeom . second ); for ( auto & d : ( * series )) { if ( d != nullptr ) delete [] d ; } delete series ; return result ; } void SetForecasts ( size_t i , MultiTimeSeries < TimeSeries *> * forecasts ) { size_t stationIndex = this -> IndexForIdentifier ( false ); auto values = forecasts -> GetValues (); this -> GetNcAccess () -> SetForecasts ( this -> GetNcVarName (), stationIndex , i , ( * values )); for ( auto & d : ( * values )) { if ( d != nullptr ) delete [] d ; } delete values ; } virtual ~ NetCdfTimeSeriesEnsembleTimeSeriesStore () { if ( indexForTime != nullptr ) { delete indexForTime ; indexForTime = nullptr ; } if ( timeForIndex != nullptr ) { delete timeForIndex ; timeForIndex = nullptr ; } }; MultiTimeSeries < TTimeSeries < T >*>* Read ( const string & ensembleIdentifier ) override { char * end ; const char * q = ensembleIdentifier . c_str (); size_t index = -1 ; ptime dateIndex = TimeStep :: PtimeFromIsoString ( ensembleIdentifier ); if ( dateIndex == not_a_date_time ) { index = ( int ) std :: strtol ( q , & end , 10 ); const char * r = q + ensembleIdentifier . size () * sizeof ( char * ); if ( end == q || end != r ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"Could not parse as integer or a (ptime) date specification: \" + ensembleIdentifier ); } } else { index = GetIndexForTime ( dateIndex ); } // check on index validity // datatypes::exceptions::ExceptionUtilities::ThrowInvalidArgument( return GetForecasts ( index ); } size_t GetIndexForTime ( const ptime & dateIndex ) { if ( indexForTime == nullptr ) { vector < ptime > p = this -> GetNcAccess () -> GetTimeDim (); indexForTime = new std :: map < ptime , size_t > (); for ( size_t i = 0 ; i < p . size (); i ++ ) { ( * indexForTime )[ p [ i ]] = i ; } } return indexForTime -> at ( dateIndex ); } ptime GetTimeForIndex ( size_t index ) { if ( timeForIndex == nullptr ) { timeForIndex = new std :: vector < ptime > ( this -> GetNcAccess () -> GetTimeDim ()); } return ( * timeForIndex )[ index ]; } //vector<string> GetItemIdentifiers() const //{ // vector<ptime> times = this->GetNcAccess()->GetTimeDim(); // std::function<string(const ptime&)> f = [&](const ptime& p) { return boost::posix_time::to_iso_string(p); }; // return SwiftNetCDFAccess::Convert<ptime, string>(times, f); //} size_t GetLength () const { return this -> GetNcAccess () -> GetTimeLength (); } TimeStep GetTimeStep () const { // TODO: returning this->GetNcAccess()->GetTimeStep() is adequeate for // SWIFT netCDF specs v1, not the most recent return this -> GetNcAccess () -> GetTimeStep (); } TimeStep GetLeadTimeStep () const { return this -> GetNcAccess () -> GetLeadTimeStep (); } ptime GetStart () const { vector < ptime > times = this -> GetNcAccess () -> GetTimeDim (); return times [ 0 ]; } ptime GetEnd () const { vector < ptime > times = this -> GetNcAccess () -> GetTimeDim (); return times [ times . size () -1 ]; } string GetDataSummary () const { return SingleNetCdfFileStore < T >:: GetDefaultDataSummary (); } vector < DataDimensionDescriptor > GetDataDimensionsDescription () const { return { DataDimensionDescriptor ( TIME_DIM_TYPE_DATA_DIMENSION ), DataDimensionDescriptor ( ENSEMBLE_DIM_TYPE_DATA_DIMENSION ), DataDimensionDescriptor ( TIME_DIM_TYPE_DATA_DIMENSION ) }; } using WritableTimeSeriesEnsembleTimeSeriesStore < T >:: GetEnsembleSize ; using SingleNetCdfFileStore < T >:: GetEnsembleSize ; void Allocate ( size_t length , PtrEnsemblePtrType value ) { vector < PtrEnsemblePtrType > v ( length ); v . assign ( length , value ); AllocateValues ( v ); } void AllocateValues ( const vector < PtrEnsemblePtrType >& values ) { if ( IsActive ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"This netCDF store is already initialised and active\" ); DimensionsDefinitions dimDef = DimensionsFromSeries < T > ( values ); string ncVarname ( this -> GetNcVarName ()); string longName = \"<NA>\" ; string units = \"\" ; double fillValue = DEFAULT_MISSING_DATA_VALUE ; int type = 9 ; string typeDescription = \"<NA>\" ; string datType = \"<NA>\" ; string datDescription = \"<NA>\" ; map < string , VariableDefinition > v ; v [ ncVarname ] = VariableDefinition ( ncVarname , DATATYPES_DOUBLE_PRECISION_ID , Dimensions (), longName , units , fillValue , type , typeDescription , datType , datDescription , \"Point\" ); GlobalAttributes globAtts = GlobalAttributes :: CreateDefault (); SingleNetCdfFileStore < T >:: Init ( this -> GetFileName (), dimDef , v , globAtts ); for ( size_t i = 0 ; i < values . size (); i ++ ) { SetItem ( ncVarname , i , values [ i ]); } } void SetSeries ( const string & dataId , PtrTSeriesEnsemblePtrType value ) { for ( size_t i = 0 ; i < value -> GetLength (); i ++ ) { SetItem ( this -> GetNcVarName (), i , value -> GetValue ( i )); } } void SetItem ( const string & dataId , size_t index , PtrEnsemblePtrType value ) { SetForecasts ( index , value ); } void SetItem ( const string & dataId , size_t index , const EnsemblePtrType & value ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); } //SetItem(const string& dataId, PtrEnsemblePtrType) = 0; //EnsemblePtrType Read(const string& ensembleIdentifier) = 0; void SetLength ( size_t length ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); } void SetStart ( ptime start ) { // TODO? can it be done after initial allocation? } //vector<string> GetItemIdentifiers() const = 0; void SetTimeStep ( const TimeStep & ) { // TODO? can it be done after initial allocation? } bool IsActive () { return ( this -> HasNcAccess ()); } private : std :: vector < ptime > * timeForIndex = nullptr ; std :: map < ptime , size_t > * indexForTime = nullptr ; }; template < typename T > class MultiFileTimeSeriesEnsembleTimeSeriesStore ; template < typename T > class MultiFileTsStorage : public StoragePolicy < T > { public : // Implicitely here, we are dealing only with time series of ensemble of time series typedef typename std :: remove_pointer < T >:: type :: ElementType ElementType ; private : MultiFileTsStorage ( const MultiFileTsStorage & src ) { store = src . store ; // We do not copy the data vector! ReserveVectorData ( store . GetLength ()); readOnly = src . readOnly ; } MultiFileTimeSeriesEnsembleTimeSeriesStore < ElementType > store ; void CheckIntervalBounds ( const size_t & from , size_t & to ) const { size_t tsLen = this -> GetLength (); datatypes :: exceptions :: RangeCheck < size_t >:: CheckTimeSeriesInterval ( from , to , tsLen ); } public : MultiFileTsStorage ( const MultiFileTimeSeriesEnsembleTimeSeriesStore < ElementType >& storage , const string & dataIdentifier , bool readOnly = true ) { store = storage ; size_t length = store . GetLength (); ReserveVectorData ( length ); this -> readOnly = readOnly ; } vector < T > data ; bool readOnly = true ; bool ReadOnly () override { return readOnly ; } size_t Size () const { return data . size (); } void ReserveVectorData ( size_t length ) { if ( ! data . empty ()) { for ( size_t i = 0 ; i < data . size (); i ++ ) { auto ptr = data [ i ]; if ( ptr != nullptr ) delete ptr ; } data . clear (); } if ( length > 0 ) { data . reserve ( length ); data . assign ( length , nullptr ); } } void Allocate ( size_t length , T value ) { if ( ReadOnly ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"MultiFileTsStorage::Allocate cannot be called if the storage is read-only\" ); else { ReserveVectorData ( length ); data . assign ( length , value ); } } void AllocateValues ( size_t length , const T * values ) { if ( ReadOnly ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"MultiFileTsStorage::AllocateValues cannot be called if the storage is read-only\" ); else { ReserveVectorData ( length ); data . assign ( values , values + length ); } } void AllocateValues ( const vector < T >& values ) { if ( ReadOnly ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"MultiFileTsStorage::AllocateValues cannot be called if the storage is read-only\" ); else { ReserveVectorData ( values . size ()); data . assign ( values . begin (), values . end ()); } } void CopyTo ( vector < T >& dest , size_t from = 0 , size_t to = -1 ) const { CheckIntervalBounds ( from , to ); size_t len = ( to - from ) + 1 ; if ( dest . size () != len ) { dest . clear (); dest . resize ( len ); }; for ( size_t i = 0 ; i < len ; i ++ ) { dest [ i ] = ( data [ i ] == nullptr ? store . ReadAt ( i ) : data [ i ]); } } private : void CheckDataItemRange ( const size_t i ) const { if ( data . empty ()) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidOperation ( \"No data item present in this MultiFileTsStorage\" ); datatypes :: exceptions :: ExceptionUtilities :: CheckInRange < size_t > ( i , 0 , data . size (), \"index\" ); } public : T & operator []( const size_t i ) { CheckDataItemRange ( i ); if ( data [ i ] == nullptr ) data [ i ] = store . ReadAt ( i ); return data [ i ]; } const T & operator []( const size_t i ) const { CheckDataItemRange ( i ); return data [ i ]; } StoragePolicy < T >* Clone () const { return new MultiFileTsStorage < T > ( * this ); } size_t GetLength () const { return store . GetLength (); } TimeStep GetTimeStep () const override { return store . GetTimeStep (); } ptime GetStart () const override { return store . GetStart (); } void SetTimeStep ( const TimeStep & tStep ) override { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); } void SetStart ( const ptime & start ) override { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); } }; template < typename T > class /*DATATYPES_DLL_LIB*/ MultiFileTimeSeriesEnsembleTimeSeriesStore : public TimeSeriesEnsembleTimeSeriesStore < T > { public : string DatePattern = \"YYYYMMDD\" ; string FileNamePattern = datatypes :: io :: IoHelper :: DefaultFilePattern ; MultiFileTimeSeriesEnsembleTimeSeriesStore () { } MultiFileTimeSeriesEnsembleTimeSeriesStore ( const string & forecastDataFiles , const string & varName , const string & varIdentifier , int index , const TimeStep & timeStep , const ptime & start , int length , int ensembleSize , int ensembleLength , const TimeStep & ensembleTimeStep ) { this -> forecastDataFiles = forecastDataFiles ; this -> varName = varName ; this -> varIdentifier = varIdentifier ; this -> index = index ; this -> timeStep = timeStep ; this -> start = start ; this -> length = length ; this -> ensembleSize = ensembleSize ; this -> ensembleLength = ensembleLength ; this -> ensembleTimeStep = ensembleTimeStep ; } virtual ~ MultiFileTimeSeriesEnsembleTimeSeriesStore () { /*TODO*/ }; using SeriesType = typename CommonTypes < T >:: SeriesType ; EnsembleForecastTimeSeries < SeriesType >* GetSeries ( const string & dataId ) { // Buckle up... // T is of double // if T is double, SeriesType is TTimeSeries<T> // if T is double, SeriesTypePtr is TTimeSeries<T>* // EnsembleForecastTimeSeries< SeriesType > is an EnsembleForecastTimeSeries<TTimeSeries<T>> // which is a PointerTypeTimeSeries < MultiTimeSeriesPtr<SeriesType> > // which is a PointerTypeTimeSeries < MultiTimeSeriesPtr<TTimeSeries<T> > // which is a TTimeSeries < MultiTimeSeriesPtr<TTimeSeries<T>* > // which is a TTimeSeries < MultiTimeSeries<TTimeSeries<T*>*> // so the type parameters of the storage policy must be a type MultiTimeSeries<TTimeSeries<T*>* // // That all said: // an EnsembleForecastTimeSeries is a template typename for a TTimeSeries, so a simpler way to specify the storage type is: using StorageType = typename EnsembleForecastTimeSeries < SeriesType >:: ElementType ; StoragePolicy < StorageType >* s = new MultiFileTsStorage < StorageType > ( * this , dataId ); return new EnsembleForecastTimeSeries < SeriesType > ( s ); } private : MultiTimeSeries < SeriesType *>* ReadByFileId ( const string & fileIdentifier ) const { using namespace boost :: filesystem ; using datatypes :: io :: IoHelper ; string fileName = IoHelper :: MakeFileName ( forecastDataFiles , fileIdentifier ); path p ( fileName ); if ( exists ( p ) && is_regular_file ( p )) return TimeSeriesIOHelper < T >:: ReadForecastTimeSeries ( fileName , varName , varIdentifier , index ); else return nullptr ; } string GetItemIdentifierForIndex ( size_t index ) const { ptime t = timeStep . AddSteps ( start , index ); return TimeStep :: ToString ( t , DatePattern ); } string GetFilenameForItem ( size_t index ) const { //\"blah/sample_data\\UnitTests\\netcdf\\testpet{0}.nc\" string fn = ShortFileNamePattern (); string s = GetItemIdentifierForIndex ( index ); boost :: algorithm :: replace_first ( fn , FileNamePattern , s ); return fn ; } public : MultiTimeSeries < SeriesType *>* Read ( const string & fileIdentifier ) override { return ReadByFileId ( fileIdentifier ); } MultiTimeSeries < SeriesType *>* ReadAt ( size_t index ) const { datatypes :: exceptions :: ExceptionUtilities :: CheckInRange < size_t > ( index , 0 , this -> length - 1 , \"index\" ); string id = GetItemIdentifierForIndex ( index ); return ReadByFileId ( id ); } size_t GetLength () const { return this -> length ; //return GetMatchingFiles().size(); } TimeStep GetTimeStep () const { return timeStep ; } ptime GetStart () const { return start ; } ptime GetEnd () const { if ( length < 0 ) return start ; size_t n = length ; return timeStep . AddSteps ( start , n ); } string ShortFileNamePattern () const { namespace fs = boost :: filesystem ; fs :: path filesPath ( forecastDataFiles ); auto someDir = filesPath . parent_path (); string fileNamePattern ( filesPath . filename (). string ()); return fileNamePattern ; } string GetDataSummary () const { auto start = GetStart (); auto end = GetEnd (); string result = string ( \"variable name: \" ) + varName + string ( \", identifier: \" ) + varIdentifier + string ( \", index: \" ) + std :: to_string ( index ) + string ( \", start: \" ) + to_iso_extended_string ( start ) + string ( \", end: \" ) + to_iso_extended_string ( end ) + string ( \", time length: \" ) + std :: to_string ( GetLength ()) + string ( \", time step: <not yet supported>\" ); return result ; } vector < DataDimensionDescriptor > GetDataDimensionsDescription () const { return { DataDimensionDescriptor ( TIME_DIM_TYPE_DATA_DIMENSION ), DataDimensionDescriptor ( ENSEMBLE_DIM_TYPE_DATA_DIMENSION ), DataDimensionDescriptor ( TIME_DIM_TYPE_DATA_DIMENSION ) }; } private : string forecastDataFiles ; //string ncVarName; string varName ; //string identifier; string varIdentifier ; int index ; TimeStep timeStep ; ptime start ; int length = -1 ; int ensembleSize = -1 ; int ensembleLength = -1 ; TimeStep ensembleTimeStep ; vector < string > Split ( const string & s , const string & separators ) const { vector < string > tokens ; boost :: split ( tokens , s , boost :: is_any_of ( separators )); return tokens ; } vector < string > GetMatchingFiles () const { namespace fs = boost :: filesystem ; boost :: filesystem :: path filesPath ( forecastDataFiles ); auto someDir = filesPath . parent_path (); string fileNamePattern ( filesPath . filename (). string ()); boost :: algorithm :: replace_first ( fileNamePattern , FileNamePattern , \".*\" ); #ifdef __GNUC__ // https ://jira.csiro.au/browse/WIRADA-350 GNU gcc regex bug; use boost instead #if (__GNUC__ <= 4 && __GNUC_MINOR__ < 9) using boost :: regex ; using boost :: regex_constants :: icase ; using boost :: regex_search ; #else using std :: regex ; using std :: regex_constants :: icase ; using std :: regex_search ; #endif #else using std :: regex ; using std :: regex_constants :: icase ; using std :: regex_search ; #endif // __GNUC__ regex rex ( fileNamePattern , icase ); vector < string > files ; if ( fs :: exists ( someDir ) && fs :: is_directory ( someDir )) { fs :: directory_iterator end ; for ( fs :: directory_iterator dirIter ( someDir ); dirIter != end ; ++ dirIter ) { auto f = dirIter -> path (). filename (); if ( regex_search ( f . string (), rex ) && fs :: is_regular_file ( dirIter -> status ())) { files . push_back ( f . string ()); } } } return files ; } }; class DATATYPES_DLL_LIB TimeSeriesLibraryFactory { private : static void CreateLibrary ( const TimeSeriesLibraryDescription & description , TimeSeriesLibrary & result ); public : using PtrSeriesType = TTimeSeries < double >* ; using SeriesType = TTimeSeries < double > ; static TimeSeriesLibrary CreateLibrary ( const TimeSeriesLibraryDescription & description ); static TimeSeriesLibrary * CreateLibraryPtr ( const TimeSeriesLibraryDescription & description ); static TimeSeriesLibrary LoadTimeSeriesLibrary ( const string & filepath , const string & dataPath = \"\" ); static TimeSeriesLibrary * LoadTimeSeriesLibraryPtr ( const string & filepath , const string & dataPath = \"\" ); static TimeSeriesLibrary * CreateTimeSeriesLibraryPtr ( const string & type ); static SingleTimeSeriesStore < double >* CreateTsSource ( const string & ncFilename , const string & ncVarName , const string & ncIdentifier ); static EnsembleTimeSeriesStore < double >* CreateEnsTsSource ( const string & ncFilename , const string & ncVarName , const string & ncIdentifier ); static TimeSeriesEnsembleTimeSeriesStore < double >* CreateTsEnsTsSource ( const string & ncFilename , const string & ncVarName , const string & ncIdentifier ); static EnsembleForecastTimeSeries < SeriesType >* LoadTsEnsTs ( const string & ncFilename , const string & ncVarName , const string & ncIdentifier , const string & dataId ); static TimeSeriesSourceInfo CreateNetcdfSourceInfo ( const string & dataId , const string & storageType , const string & ncFilename , const string & ncVarName , const string & ncIdentifier ); static TimeSeriesSourceInfo CreateNetcdfSourceInfo ( const string & dataId , const string & storageType , const string & ncFilename , const string & ncVarName , const string & ncIdentifier , int index , const string & timeStep , const string & start , int length , int ensembleSize ); static TimeSeriesSourceInfo CreateNetcdfSourceInfo ( const string & dataId , const string & storageType , const string & ncFilename , const string & ncVarName , const string & ncIdentifier , int index , const string & timeStep , const string & start , int length , int ensembleSize , int ensembleLength , const string & ensembleTimeStep ); static const string kTestRecorderKey ; static const string kTimeSeriesEnsemblesKey ; static bool HasTimeSeriesSourceInfoBuilderRegistered (); static void RegisterTimeSeriesSourceInfoBuilder ( TimeSeriesSourceInfoBuilder * srcBuilder ); private : static TimeSeriesSourceInfoBuilder * GetBuilder (); static TimeSeriesSourceInfoBuilder * infoBuilder ; }; class DATATYPES_DLL_LIB SwiftNetcdfStoreFactory : public TimeSeriesStoreFactory { private : string dirPath ; DataGeometryProvider * geometryProvider ; boost :: filesystem :: path CreateNcFilename ( const string & dataId ) { return boost :: filesystem :: path ( dirPath ) / ( dataId + \".nc\" ); } public : SwiftNetcdfStoreFactory ( const string & path , DataGeometryProvider * dgp ); ~ SwiftNetcdfStoreFactory (); TimeSeriesEnsembleTimeSeriesStore < double >* CreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ); bool CanCreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ); }; //using EFTS = CommonTypes<>::TSeriesEnsemblePtrType; //template<> //GlobalAttributes GetMetadataFrom<EFTS,GlobalAttributes>(const EFTS& ens) //{ //} } } Updated on 2022-08-20 at 19:28:22 +1000","title":"Source code"},{"location":"cpp/Files/time__series__store_8hpp/","text":"datatypes/time_series_store.hpp \u00b6 Namespaces \u00b6 Name datatypes datatypes::timeseries Classes \u00b6 Name class datatypes::timeseries::IdentifiersProvider An interface definition for objects that can provide hierarchical identification. class datatypes::timeseries::TimeSeriesProvider Library of time series, for high level access to sources of univariate, single instance time series that may have varying on-disk representations. class datatypes::timeseries::DataDimensionDescriptor class datatypes::timeseries::DataDescriptor class datatypes::timeseries::SingleTimeSeriesStore Interface definition for storages of single, univariate time series. class datatypes::timeseries::EnsembleTimeSeriesStore Interface definition for storages of ensembles of univariate time series. class datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore Interface definition for storages of time series of ensembles of time series. class datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore class datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy class datatypes::timeseries::TTimeSeriesLibrary class datatypes::timeseries::TimeSeriesSourceInfoImpl class datatypes::timeseries::TimeSeriesSourceInfo class datatypes::timeseries::NetCdfSourceInfo class datatypes::timeseries::TimeSeriesLibraryDescription class datatypes::timeseries::TimeSeriesSourceInfoBuilder An abstract class to allow callers to inject custom time series data sources into a time series library. class datatypes::timeseries::TimeSeriesStoreFactory class datatypes::timeseries::TimeSeriesLibrary Library of time series, for high level access to sources of time series that nmay have varying on-disk representations. Defines \u00b6 Name TIME_DIM_TYPE_DATA_DIMENSION COLLECTION_DIM_TYPE_DATA_DIMENSION ENSEMBLE_DIM_TYPE_DATA_DIMENSION Macros Documentation \u00b6 define TIME_DIM_TYPE_DATA_DIMENSION \u00b6 #define TIME_DIM_TYPE_DATA_DIMENSION \"time\" define COLLECTION_DIM_TYPE_DATA_DIMENSION \u00b6 #define COLLECTION_DIM_TYPE_DATA_DIMENSION \"collection\" define ENSEMBLE_DIM_TYPE_DATA_DIMENSION \u00b6 #define ENSEMBLE_DIM_TYPE_DATA_DIMENSION \"ensemble\" Source code \u00b6 #pragma once #include <stdexcept> #include <netcdf.h> #include <map> #ifdef __GNUC__ // https ://jira.csiro.au/browse/WIRADA-350 GNU gcc regex bug; use boost instead #if (__GNUC__ <= 4 && __GNUC_MINOR__ < 9) #include <boost/regex.hpp> #else #include <regex> #endif #else #include <regex> #endif // __GNUC__ #include <boost/function.hpp> #include <boost/filesystem.hpp> #include <boost/range/iterator_range.hpp> #include <boost/algorithm/string/predicate.hpp> #include <boost/algorithm/string/split.hpp> #include <boost/algorithm/string/classification.hpp> #include <boost/algorithm/string.hpp> #include \"datatypes/time_series.hpp\" #include \"datatypes/exception_utilities.h\" #include \"yaml-cpp/yaml.h\" namespace datatypes { namespace timeseries { class DATATYPES_DLL_LIB IdentifiersProvider { public : virtual ~ IdentifiersProvider () {} virtual vector < string > GetIdentifiers () const = 0 ; static vector < string > SplitHierarchicalIdentifier ( const string & longId ); static string GetTopmostIdentifier ( const string & longId ); static void CheckNotEmpty ( const string & longId ); }; template < typename T > class DATATYPES_DLL_LIB TimeSeriesProvider : public IdentifiersProvider { public : virtual ~ TimeSeriesProvider () {} virtual TTimeSeries < T >* GetSingle ( const string & dataId ) = 0 ; }; #define TIME_DIM_TYPE_DATA_DIMENSION \"time\" // Collection may not be a necessary distinction compared to ensemble. Reconsider. #define COLLECTION_DIM_TYPE_DATA_DIMENSION \"collection\" #define ENSEMBLE_DIM_TYPE_DATA_DIMENSION \"ensemble\" class DATATYPES_DLL_LIB DataDimensionDescriptor { public : DataDimensionDescriptor ( const string & type , const string & dimname = \"\" , size_t size = 0 ); DataDimensionDescriptor ( const DataDimensionDescriptor & src ); DataDimensionDescriptor ( DataDimensionDescriptor && src ); DataDimensionDescriptor & operator = ( const DataDimensionDescriptor & src ); DataDimensionDescriptor & operator = ( DataDimensionDescriptor && src ); string DimensionType ; // \"collection\", \"ensemble\", \"time\" string DimensionName ; size_t Size = 0 ; }; class DATATYPES_DLL_LIB DataDescriptor { public : virtual string GetDataSummary () const = 0 ; virtual vector < DataDimensionDescriptor > GetDataDimensionsDescription () const = 0 ; }; template < typename T > class DATATYPES_DLL_LIB SingleTimeSeriesStore : public IdentifiersProvider , public DataDescriptor { public : virtual ~ SingleTimeSeriesStore () {}; virtual TTimeSeries < T >* Read () = 0 ; virtual TTimeSeries < T >* Read ( const string & collectionIdentifier ) = 0 ; virtual MultiTimeSeries < TTimeSeries < T >*>* ReadAllCollection () = 0 ; //virtual string GetDataSummary() const = 0; //virtual vector<DataDimensionDescriptor> GetDataDimensionsDescription() const = 0; }; template < typename T > class DATATYPES_DLL_LIB EnsembleTimeSeriesStore : public IdentifiersProvider , public DataDescriptor { public : virtual ~ EnsembleTimeSeriesStore () {}; virtual MultiTimeSeries < TTimeSeries < T >*>* Read () = 0 ; //virtual string GetDataSummary() const = 0; virtual vector < string > GetIdentifiers () const { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); vector < string > x ; return x ; } }; template < typename T > class DATATYPES_DLL_LIB TimeSeriesEnsembleTimeSeriesStore : public IdentifiersProvider , public TimeSeriesInfoProvider , public DataDescriptor { public : using SeriesType = typename CommonTypes < T >:: SeriesType ; using PtrSeriesType = typename CommonTypes < T >:: PtrSeriesType ; using EnsemblePtrType = typename CommonTypes < T >:: EnsemblePtrType ; using PtrEnsemblePtrType = typename CommonTypes < T >:: PtrEnsemblePtrType ; using TSeriesEnsemblePtrType = typename CommonTypes < T >:: TSeriesEnsemblePtrType ; using PtrTSeriesEnsemblePtrType = typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType ; virtual ~ TimeSeriesEnsembleTimeSeriesStore () {}; virtual PtrTSeriesEnsemblePtrType GetSeries ( const string & dataId ) = 0 ; virtual PtrEnsemblePtrType GetItem ( const string & dataId , size_t fcastIndex ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); return nullptr ; } virtual PtrSeriesType GetItem ( const string & dataId , size_t fcastIndex , size_t ensIndex ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); return nullptr ; } virtual size_t GetEnsembleSize ( const string & dataId , size_t fcastIndex ) const { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); return 0 ; } //virtual string GetDataSummary() const = 0; // TODO: revise these. Now that the store has a GetSeries method, these should be hidden further. //protected: virtual PtrEnsemblePtrType Read ( const string & ensembleIdentifier ) = 0 ; virtual size_t GetLength () const = 0 ; virtual ptime GetStart () const = 0 ; virtual TimeStep GetTimeStep () const = 0 ; virtual vector < string > GetIdentifiers () const { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); vector < string > x ; return x ; } }; template < typename T > class DATATYPES_DLL_LIB WritableTimeSeriesEnsembleTimeSeriesStore : public TimeSeriesEnsembleTimeSeriesStore < T > { public : using SeriesType = typename CommonTypes < T >:: SeriesType ; using PtrSeriesType = typename CommonTypes < T >:: PtrSeriesType ; using EnsemblePtrType = typename CommonTypes < T >:: EnsemblePtrType ; using PtrEnsemblePtrType = typename CommonTypes < T >:: PtrEnsemblePtrType ; using TSeriesEnsemblePtrType = typename CommonTypes < T >:: TSeriesEnsemblePtrType ; using PtrTSeriesEnsemblePtrType = typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType ; virtual ~ WritableTimeSeriesEnsembleTimeSeriesStore () {}; virtual bool IsActive () = 0 ; virtual void Allocate ( size_t length , PtrEnsemblePtrType value ) = 0 ; void AllocateValues ( size_t length , const PtrEnsemblePtrType * values ) { vector < PtrEnsemblePtrType > v ( length ); v . assign ( values , values + length ); AllocateValues ( v ); } virtual void AllocateValues ( const vector < PtrEnsemblePtrType >& values ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); } virtual void SetSeries ( const string & dataId , PtrTSeriesEnsemblePtrType value ) = 0 ; virtual void SetItem ( const string & dataId , size_t index , PtrEnsemblePtrType value ) = 0 ; virtual void SetItem ( const string & dataId , size_t index , const EnsemblePtrType & value ) = 0 ; //virtual PtrEnsemblePtrType Read(const string& ensembleIdentifier) = 0; virtual void SetLength ( size_t ) = 0 ; virtual void SetStart ( ptime ) = 0 ; //virtual vector<string> GetItemIdentifiers() const = 0; virtual void SetTimeStep ( const TimeStep & ) = 0 ; //virtual vector<string> GetIdentifiers() const { datatypes::exceptions::ExceptionUtilities::ThrowNotImplemented(); vector<string> x; return x; } }; template < typename TsType > class TimeSeriesEnsembleTimeSeriesStoragePolicy : public EnsembleStoragePolicy < TsType > { public : // TODO T should be derived from StorageType, but this is // more work with datatypes' type traits than // I have time and know how, for now. using T = double ; typedef typename std :: remove_pointer < TsType >:: type Type ; typedef typename std :: add_pointer < Type >:: type PtrType ; typedef typename Type :: ElementType ElementType ; private : WritableTimeSeriesEnsembleTimeSeriesStore < T > * store = nullptr ; size_t index ; TimeSeriesEnsembleTimeSeriesStoragePolicy () { } public : TimeSeriesEnsembleTimeSeriesStoragePolicy ( WritableTimeSeriesEnsembleTimeSeriesStore < T > * store , size_t index ) : store ( store ), index ( index ) { if ( store == nullptr ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"store must not be nullptr for an TimeSeriesEnsembleTimeSeriesStoragePolicy\" ); } void Reset ( const vector < PtrType >& values , const ptime & startDate , const TimeStep & timeStep ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); } TimeSeriesEnsembleTimeSeriesStoragePolicy ( const TimeSeriesEnsembleTimeSeriesStoragePolicy < TsType >& src ) { DeepCopyFrom ( src ); } EnsembleStoragePolicy < TsType >* Clone () const { return new TimeSeriesEnsembleTimeSeriesStoragePolicy < TsType > ( * this ); } ~ TimeSeriesEnsembleTimeSeriesStoragePolicy () { Clear (); } TimeSeriesEnsembleTimeSeriesStoragePolicy & operator = ( TimeSeriesEnsembleTimeSeriesStoragePolicy && src ) { if ( & src == this ) { return * this ; } std :: swap ( store , src . store ); return * this ; } void ResetSeries ( const size_t & numSeries , const size_t & lengthSeries , const ptime & startDate , const TimeStep & timeStep ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); } PtrType GetReplicate ( size_t i ) { return store -> GetItem ( \"\" , index , i ); } TsType Get ( size_t i ) { return TsType ( GetReplicate ( i )); } ElementType Get ( size_t i , size_t tsIndex ) { return GetReplicate ( i ) -> GetValue ( tsIndex ); } void Set ( size_t i , size_t tsIndex , ElementType val ) { PtrType ts = GetReplicate ( i ); ( * ts )[ tsIndex ] = val ; } void Set ( size_t i , const Type & val ) { PtrType ts = GetReplicate ( i ); * ts = val ; // overloaded operator= should do this as expected - tbc } vector < ElementType *>* GetValues () const { vector < ElementType *>* result = new vector < ElementType *> (); datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); return nullptr ; //for (auto& d : series) //{ // result->push_back(d->GetValues()); //} //return result; } void CopyTo ( ElementType ** dest ) const { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); //size_t n = this->Size(); //for (size_t i = 0; i < n; i++) //{ // dest[i] = GetReplicate(i)->GetValues(); //} } size_t Size () const { return store -> GetEnsembleSize ( \"\" , index ); } size_t GetLength ( size_t i ) const { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); return 0 ; //return GetReplicate(i)->GetLength(); } void Clear () { //for (auto& d : series) //{ // if (d != nullptr) delete d; //} //series.clear(); } const vector < PtrType >& AsReadonlyVector () const { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); return dummy ; // required for compilation. } private : vector < PtrType > dummy ; void DeepCopyFrom ( const EnsembleStoragePolicy < TsType >& src ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); Clear (); auto v = src . AsReadonlyVector (); //for (size_t i = 0; i < v.size(); i++) //{ // Type* copy = new Type(*(v.at(i))); // this->series.push_back(copy); //} } protected : void OperatorEqualImpl ( const EnsembleStoragePolicy < TsType >& src ) { DeepCopyFrom ( src ); } }; using namespace datatypes :: exceptions ; template < typename T > class TTimeSeriesLibrary { public : typedef TTimeSeries < T > TS ; typedef MultiTimeSeries < TS *> MTS ; virtual ~ TTimeSeriesLibrary () {} virtual TS * GetSingle ( const string & dataId ) { ExceptionUtilities :: ThrowNotImplemented (); return nullptr ; } virtual TS * GetSingle ( const string & dataId , const string & collectionIdentifier ) { ExceptionUtilities :: ThrowNotImplemented (); return nullptr ; } virtual MTS * GetCollection ( const string & dataId ) { ExceptionUtilities :: ThrowNotImplemented (); return nullptr ; } virtual TimeSeriesProvider < T >* GetProvider ( const string & dataId ) { ExceptionUtilities :: ThrowNotImplemented (); return nullptr ; } virtual MultiTimeSeries < TS *>* GetEnsembleTimeSeries ( const string & dataId ) { ExceptionUtilities :: ThrowNotImplemented (); return nullptr ; } virtual MultiTimeSeries < TS *>* GetAllTimeSeries ( const string & dataId ) { ExceptionUtilities :: ThrowNotImplemented (); return nullptr ; } virtual EnsembleForecastTimeSeries < TS >* GetTimeSeriesEnsembleTimeSeries ( const string & dataId ) { ExceptionUtilities :: ThrowNotImplemented (); return nullptr ; } virtual vector < string > GetIdentifiers () const { ExceptionUtilities :: ThrowNotImplemented (); vector < string > res ; return res ; } }; class TimeSeriesLibrary ; class DATATYPES_DLL_LIB TimeSeriesSourceInfoImpl { protected : TimeSeriesSourceInfoImpl (); TimeSeriesSourceInfoImpl ( const TimeSeriesSourceInfoImpl & src ); public : virtual ~ TimeSeriesSourceInfoImpl (); virtual TimeSeriesSourceInfoImpl * Clone () const = 0 ; virtual bool ApplyRootDir ( const string & rootDir ); virtual SingleTimeSeriesStore < double >* CreateSingleTimeSeriesStore () const ; virtual EnsembleTimeSeriesStore < double >* CreateEnsembleTimeSeriesStore () const ; virtual TimeSeriesEnsembleTimeSeriesStore < double >* CreateTimeSeriesEnsembleTimeSeriesStore () const ; virtual std :: map < string , string > GetSerializableConfiguration () const ; static string OptionalApplyRootDir ( const std :: string & rootDir , const std :: string & filename , bool checkDirExists = true ); }; class DATATYPES_DLL_LIB TimeSeriesSourceInfo { private : TimeSeriesSourceInfoImpl * impl = nullptr ; public : TimeSeriesSourceInfo ( const TimeSeriesSourceInfoImpl & t ); TimeSeriesSourceInfo ( const TimeSeriesSourceInfo & src ); TimeSeriesSourceInfo (); virtual ~ TimeSeriesSourceInfo (); TimeSeriesSourceInfo ( TimeSeriesSourceInfo && src ); TimeSeriesSourceInfo & operator = ( const TimeSeriesSourceInfo & src ); TimeSeriesSourceInfo & operator = ( TimeSeriesSourceInfo && src ); SingleTimeSeriesStore < double >* CreateSingleTimeSeriesStore () const ; EnsembleTimeSeriesStore < double >* CreateEnsembleTimeSeriesStore () const ; TimeSeriesEnsembleTimeSeriesStore < double >* CreateTimeSeriesEnsembleTimeSeriesStore () const ; bool ApplyRootDir ( const string & rootDir ); std :: map < string , string > GetSerializableConfiguration () const ; static const string IdDataKey ; static const string SingleSeriesTypeId ; static const string EnsembleSeriesTypeId ; static const string TimeSeriesEnsemblesTypeId ; static const string SingleSeriesCollectionTypeId ; private : //string DataId() const; //string Identifier() const; //string StorageType() const; //int Index() const; //string TimeStep() const; //string Start() const; //int Length() const; //int EnsembleSize() const; //int EnsembleLength() const; //string EnsembleTimeStep() const; //string FileName() const; //string NcVarName() const; }; class DATATYPES_DLL_LIB NetCdfSourceInfo : public TimeSeriesSourceInfoImpl { private : bool IsFileNamePattern ( const string & s ) const ; public : NetCdfSourceInfo () {} NetCdfSourceInfo ( const string & dataId , const string & fileName , const string & ncVarName , const string & identifier = \"\" , int index = -1 , const string & storageType = \"\" , const string & timeStep = \"\" , const string & start = \"\" , int length = -1 , int ensembleSize = -1 , int ensembleLength = -1 , const string & ensembleTimeStep = \"\" , const string & containingDirectory = \"\" ); NetCdfSourceInfo ( const string & dataId , const string & fileName , const string & ncVarName , const string & identifier , int index , const string & storageType , const TimeStep & timeStep , const ptime & start , int length , int ensembleSize , int ensembleLength , const TimeStep & ensembleTimeStep /*, const string& collectionDimensionId*/ ); TimeSeriesSourceInfoImpl * Clone () const ; bool ApplyRootDir ( const string & rootDir ); SingleTimeSeriesStore < double >* CreateSingleTimeSeriesStore () const ; EnsembleTimeSeriesStore < double >* CreateEnsembleTimeSeriesStore () const ; TimeSeriesEnsembleTimeSeriesStore < double >* CreateTimeSeriesEnsembleTimeSeriesStore () const ; std :: map < string , string > GetSerializableConfiguration () const ; static const string FileKey ; static const string VarKey ; static const string IdentifierKey ; static const string IndexKey ; static const string TypeKey ; //static const string TimeStepKey; //static const string StartKey; //static const string LengthKey; //static const string EnsembleSizeKey; //static const string EnsembleLengthKey; //static const string EnsembleTimeStepKey; //static const string FilePatternKey; //static const string MappingKey; //static const string StorageKey; static const string StorageTypeSingleNetcdfFile ; static const string StorageTypeMultipleNetcdfFiles ; private : string dataId ; string fileName ; string ncVarName ; string identifier ; //string collectionDimensionId; string storageType ; int index = -1 ; TimeStep timeStep ; ptime start ; int length = -1 ; int ensembleSize = -1 ; int ensembleLength = -1 ; TimeStep ensembleTimeStep ; }; class DATATYPES_DLL_LIB TimeSeriesLibraryDescription { friend class TimeSeriesLibrary ; private : std :: map < string , TimeSeriesSourceInfo > tsEnsProviders ; std :: map < string , TimeSeriesSourceInfo > singleProviders ; std :: map < string , TimeSeriesSourceInfo > ensProviders ; TimeSeriesSourceInfo GetInfo ( const string & dataId , bool applyRootDir = false ) const ; boost :: filesystem :: path GetRootDirPath () const ; string filenameLoadedFrom ; string dataPath ; public : void AddSingle ( const string & dataId , const TimeSeriesSourceInfo & t ); void AddEnsembleTs ( const string & dataId , const TimeSeriesSourceInfo & t ); void AddTsEnsembleTs ( const string & dataId , const TimeSeriesSourceInfo & t ); boost :: filesystem :: path GetFullPath ( const string & relativePath ) const ; string GetRootDirectory () const ; vector < string > GetDataIdSingle () const ; vector < string > GetDataIdEnsembleTs () const ; vector < string > GetDataIdTsEnsembleTs () const ; std :: map < string , string > GetSerializableConfiguration ( const string & dataId , const vector < string >& mandatoryKeys = vector < string > ({}) ) const ; void SetLoadedFileName ( const string & fileName ); void SetDataPath ( const string & dataPath ); string GetDataPath () const ; SingleTimeSeriesStore < double >* CreateSingleTimeSeriesStore ( const string & dataId ) const ; EnsembleTimeSeriesStore < double >* CreateEnsembleTimeSeriesStore ( const string & dataId ) const ; TimeSeriesEnsembleTimeSeriesStore < double >* CreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ) const ; }; class DATATYPES_DLL_LIB TimeSeriesSourceInfoBuilder { public : virtual bool HandlesStorageType ( const string storageType ) const = 0 ; virtual void BuildTimeSeriesSource ( const string & storageType , const string & dataId , const YAML :: Node & storage , TimeSeriesLibraryDescription & targetContainer ) const = 0 ; }; class DATATYPES_DLL_LIB TimeSeriesStoreFactory { protected : TimeSeriesStoreFactory (); public : virtual ~ TimeSeriesStoreFactory (); virtual TimeSeriesEnsembleTimeSeriesStore < double >* CreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ) = 0 ; virtual bool CanCreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ) = 0 ; }; class DATATYPES_DLL_LIB TimeSeriesLibrary : public TimeSeriesProvider < double > , public TTimeSeriesLibrary < double > { public : TimeSeriesLibrary ( TimeSeriesStoreFactory * storeCreator = nullptr ); TimeSeriesLibrary ( const TimeSeriesLibraryDescription & description ); virtual ~ TimeSeriesLibrary (); void Close (); TimeSeriesLibrary & operator = ( TimeSeriesLibrary && src ); TimeSeriesLibrary ( TimeSeriesLibrary && src ); // Maybe the following,m but may introduce too much coupling with on disk representation with SwiftNetCDFAccess. // TTimeSeries<double>* GetSingle(const string& dataId, boost::function<TTimeSeries<double>*(SwiftNetCDFAccess * dataAccess)> tsTransform); TTimeSeries < double >* GetSingle ( const string & dataId , boost :: function < TTimeSeries < double >* ( TTimeSeries < double >* ) >& tsTransform ); vector < string > GetIdentifiers () const ; vector < string > GetIdentifiers ( const string & dataId ) const ; string GetDataSummary ( const string & dataId ); vector < DataDimensionDescriptor > GetDataDimensionsDescription ( const string & dataId ); TTimeSeries < double >* GetSingle ( const string & dataId ); MultiTimeSeries < TTimeSeries < double >*>* GetCollection ( const string & dataId ); // * \\brief Gets a provider, a facade to a collection of time series. // * // * \\param dataId Identifier for the data. // * // * \\return the time series provider. // */ //TimeSeriesProvider<double>* GetProvider(const string& dataId); TTimeSeries < double >* GetSingle ( const string & dataId , const string & collectionIdentifier ); MultiTimeSeries < TTimeSeries < double >*>* GetEnsemble ( const string & dataId , const string & dataItemIdentifier ); MultiTimeSeries < TTimeSeries < double >*>* GetEnsembleTimeSeries ( const string & dataId ); MultiTimeSeries < TTimeSeries < double >*>* GetAllTimeSeries ( const string & dataId ); EnsembleForecastTimeSeries < TTimeSeries < double >>* GetTimeSeriesEnsembleTimeSeries ( const string & dataId ); void AddSource ( const string & dataId , SingleTimeSeriesStore < double >* store ); void AddSource ( const string & dataId , EnsembleTimeSeriesStore < double >* store ); void AddSource ( const string & dataId , TimeSeriesEnsembleTimeSeriesStore < double >* dataAccess ); bool CanCreateTimeSeriesEnsembleSeriesStore ( const string & dataId ); void CreateTimeSeriesEnsembleSeriesStore ( const string & dataId ); private : template < typename U > static bool hasKey ( const std :: map < string , U >& m , const string & dataId ) { return m . find ( dataId ) != m . end (); } std :: map < string , TimeSeriesEnsembleTimeSeriesStore < double >* > tsEnsTimeSeriesProviders ; std :: map < string , EnsembleTimeSeriesStore < double >* > ensTimeSeriesProviders ; std :: map < string , SingleTimeSeriesStore < double >* > timeSeriesProviders ; SingleTimeSeriesStore < double > * GetSeriesInformation ( const string & dataId ); EnsembleTimeSeriesStore < double > * GetEnsembleSeriesInformation ( const string & dataId ); bool IsDataIdTsEnsemble ( const string & dataId ); bool IsDataIdEnsemble ( const string & dataId ); bool IsDataIdSingle ( const string & dataId ); TimeSeriesEnsembleTimeSeriesStore < double > * GetTimeSeriesEnsembleSeriesInformation ( const string & dataId ); SingleTimeSeriesStore < double >* CreateTsSource ( const TimeSeriesSourceInfo & desc ); EnsembleTimeSeriesStore < double >* CreateEnsTsSource ( const TimeSeriesSourceInfo & desc ); TimeSeriesEnsembleTimeSeriesStore < double >* CreateTsEnsTsSource ( const TimeSeriesSourceInfo & desc ); TimeSeriesStoreFactory * storeCreator = nullptr ; }; } } Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes/time_series_store.hpp"},{"location":"cpp/Files/time__series__store_8hpp/#datatypestime_series_storehpp","text":"","title":"datatypes/time_series_store.hpp"},{"location":"cpp/Files/time__series__store_8hpp/#namespaces","text":"Name datatypes datatypes::timeseries","title":"Namespaces"},{"location":"cpp/Files/time__series__store_8hpp/#classes","text":"Name class datatypes::timeseries::IdentifiersProvider An interface definition for objects that can provide hierarchical identification. class datatypes::timeseries::TimeSeriesProvider Library of time series, for high level access to sources of univariate, single instance time series that may have varying on-disk representations. class datatypes::timeseries::DataDimensionDescriptor class datatypes::timeseries::DataDescriptor class datatypes::timeseries::SingleTimeSeriesStore Interface definition for storages of single, univariate time series. class datatypes::timeseries::EnsembleTimeSeriesStore Interface definition for storages of ensembles of univariate time series. class datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore Interface definition for storages of time series of ensembles of time series. class datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore class datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy class datatypes::timeseries::TTimeSeriesLibrary class datatypes::timeseries::TimeSeriesSourceInfoImpl class datatypes::timeseries::TimeSeriesSourceInfo class datatypes::timeseries::NetCdfSourceInfo class datatypes::timeseries::TimeSeriesLibraryDescription class datatypes::timeseries::TimeSeriesSourceInfoBuilder An abstract class to allow callers to inject custom time series data sources into a time series library. class datatypes::timeseries::TimeSeriesStoreFactory class datatypes::timeseries::TimeSeriesLibrary Library of time series, for high level access to sources of time series that nmay have varying on-disk representations.","title":"Classes"},{"location":"cpp/Files/time__series__store_8hpp/#defines","text":"Name TIME_DIM_TYPE_DATA_DIMENSION COLLECTION_DIM_TYPE_DATA_DIMENSION ENSEMBLE_DIM_TYPE_DATA_DIMENSION","title":"Defines"},{"location":"cpp/Files/time__series__store_8hpp/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"cpp/Files/time__series__store_8hpp/#define-time_dim_type_data_dimension","text":"#define TIME_DIM_TYPE_DATA_DIMENSION \"time\"","title":"define TIME_DIM_TYPE_DATA_DIMENSION"},{"location":"cpp/Files/time__series__store_8hpp/#define-collection_dim_type_data_dimension","text":"#define COLLECTION_DIM_TYPE_DATA_DIMENSION \"collection\"","title":"define COLLECTION_DIM_TYPE_DATA_DIMENSION"},{"location":"cpp/Files/time__series__store_8hpp/#define-ensemble_dim_type_data_dimension","text":"#define ENSEMBLE_DIM_TYPE_DATA_DIMENSION \"ensemble\"","title":"define ENSEMBLE_DIM_TYPE_DATA_DIMENSION"},{"location":"cpp/Files/time__series__store_8hpp/#source-code","text":"#pragma once #include <stdexcept> #include <netcdf.h> #include <map> #ifdef __GNUC__ // https ://jira.csiro.au/browse/WIRADA-350 GNU gcc regex bug; use boost instead #if (__GNUC__ <= 4 && __GNUC_MINOR__ < 9) #include <boost/regex.hpp> #else #include <regex> #endif #else #include <regex> #endif // __GNUC__ #include <boost/function.hpp> #include <boost/filesystem.hpp> #include <boost/range/iterator_range.hpp> #include <boost/algorithm/string/predicate.hpp> #include <boost/algorithm/string/split.hpp> #include <boost/algorithm/string/classification.hpp> #include <boost/algorithm/string.hpp> #include \"datatypes/time_series.hpp\" #include \"datatypes/exception_utilities.h\" #include \"yaml-cpp/yaml.h\" namespace datatypes { namespace timeseries { class DATATYPES_DLL_LIB IdentifiersProvider { public : virtual ~ IdentifiersProvider () {} virtual vector < string > GetIdentifiers () const = 0 ; static vector < string > SplitHierarchicalIdentifier ( const string & longId ); static string GetTopmostIdentifier ( const string & longId ); static void CheckNotEmpty ( const string & longId ); }; template < typename T > class DATATYPES_DLL_LIB TimeSeriesProvider : public IdentifiersProvider { public : virtual ~ TimeSeriesProvider () {} virtual TTimeSeries < T >* GetSingle ( const string & dataId ) = 0 ; }; #define TIME_DIM_TYPE_DATA_DIMENSION \"time\" // Collection may not be a necessary distinction compared to ensemble. Reconsider. #define COLLECTION_DIM_TYPE_DATA_DIMENSION \"collection\" #define ENSEMBLE_DIM_TYPE_DATA_DIMENSION \"ensemble\" class DATATYPES_DLL_LIB DataDimensionDescriptor { public : DataDimensionDescriptor ( const string & type , const string & dimname = \"\" , size_t size = 0 ); DataDimensionDescriptor ( const DataDimensionDescriptor & src ); DataDimensionDescriptor ( DataDimensionDescriptor && src ); DataDimensionDescriptor & operator = ( const DataDimensionDescriptor & src ); DataDimensionDescriptor & operator = ( DataDimensionDescriptor && src ); string DimensionType ; // \"collection\", \"ensemble\", \"time\" string DimensionName ; size_t Size = 0 ; }; class DATATYPES_DLL_LIB DataDescriptor { public : virtual string GetDataSummary () const = 0 ; virtual vector < DataDimensionDescriptor > GetDataDimensionsDescription () const = 0 ; }; template < typename T > class DATATYPES_DLL_LIB SingleTimeSeriesStore : public IdentifiersProvider , public DataDescriptor { public : virtual ~ SingleTimeSeriesStore () {}; virtual TTimeSeries < T >* Read () = 0 ; virtual TTimeSeries < T >* Read ( const string & collectionIdentifier ) = 0 ; virtual MultiTimeSeries < TTimeSeries < T >*>* ReadAllCollection () = 0 ; //virtual string GetDataSummary() const = 0; //virtual vector<DataDimensionDescriptor> GetDataDimensionsDescription() const = 0; }; template < typename T > class DATATYPES_DLL_LIB EnsembleTimeSeriesStore : public IdentifiersProvider , public DataDescriptor { public : virtual ~ EnsembleTimeSeriesStore () {}; virtual MultiTimeSeries < TTimeSeries < T >*>* Read () = 0 ; //virtual string GetDataSummary() const = 0; virtual vector < string > GetIdentifiers () const { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); vector < string > x ; return x ; } }; template < typename T > class DATATYPES_DLL_LIB TimeSeriesEnsembleTimeSeriesStore : public IdentifiersProvider , public TimeSeriesInfoProvider , public DataDescriptor { public : using SeriesType = typename CommonTypes < T >:: SeriesType ; using PtrSeriesType = typename CommonTypes < T >:: PtrSeriesType ; using EnsemblePtrType = typename CommonTypes < T >:: EnsemblePtrType ; using PtrEnsemblePtrType = typename CommonTypes < T >:: PtrEnsemblePtrType ; using TSeriesEnsemblePtrType = typename CommonTypes < T >:: TSeriesEnsemblePtrType ; using PtrTSeriesEnsemblePtrType = typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType ; virtual ~ TimeSeriesEnsembleTimeSeriesStore () {}; virtual PtrTSeriesEnsemblePtrType GetSeries ( const string & dataId ) = 0 ; virtual PtrEnsemblePtrType GetItem ( const string & dataId , size_t fcastIndex ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); return nullptr ; } virtual PtrSeriesType GetItem ( const string & dataId , size_t fcastIndex , size_t ensIndex ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); return nullptr ; } virtual size_t GetEnsembleSize ( const string & dataId , size_t fcastIndex ) const { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); return 0 ; } //virtual string GetDataSummary() const = 0; // TODO: revise these. Now that the store has a GetSeries method, these should be hidden further. //protected: virtual PtrEnsemblePtrType Read ( const string & ensembleIdentifier ) = 0 ; virtual size_t GetLength () const = 0 ; virtual ptime GetStart () const = 0 ; virtual TimeStep GetTimeStep () const = 0 ; virtual vector < string > GetIdentifiers () const { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); vector < string > x ; return x ; } }; template < typename T > class DATATYPES_DLL_LIB WritableTimeSeriesEnsembleTimeSeriesStore : public TimeSeriesEnsembleTimeSeriesStore < T > { public : using SeriesType = typename CommonTypes < T >:: SeriesType ; using PtrSeriesType = typename CommonTypes < T >:: PtrSeriesType ; using EnsemblePtrType = typename CommonTypes < T >:: EnsemblePtrType ; using PtrEnsemblePtrType = typename CommonTypes < T >:: PtrEnsemblePtrType ; using TSeriesEnsemblePtrType = typename CommonTypes < T >:: TSeriesEnsemblePtrType ; using PtrTSeriesEnsemblePtrType = typename CommonTypes < T >:: PtrTSeriesEnsemblePtrType ; virtual ~ WritableTimeSeriesEnsembleTimeSeriesStore () {}; virtual bool IsActive () = 0 ; virtual void Allocate ( size_t length , PtrEnsemblePtrType value ) = 0 ; void AllocateValues ( size_t length , const PtrEnsemblePtrType * values ) { vector < PtrEnsemblePtrType > v ( length ); v . assign ( values , values + length ); AllocateValues ( v ); } virtual void AllocateValues ( const vector < PtrEnsemblePtrType >& values ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); } virtual void SetSeries ( const string & dataId , PtrTSeriesEnsemblePtrType value ) = 0 ; virtual void SetItem ( const string & dataId , size_t index , PtrEnsemblePtrType value ) = 0 ; virtual void SetItem ( const string & dataId , size_t index , const EnsemblePtrType & value ) = 0 ; //virtual PtrEnsemblePtrType Read(const string& ensembleIdentifier) = 0; virtual void SetLength ( size_t ) = 0 ; virtual void SetStart ( ptime ) = 0 ; //virtual vector<string> GetItemIdentifiers() const = 0; virtual void SetTimeStep ( const TimeStep & ) = 0 ; //virtual vector<string> GetIdentifiers() const { datatypes::exceptions::ExceptionUtilities::ThrowNotImplemented(); vector<string> x; return x; } }; template < typename TsType > class TimeSeriesEnsembleTimeSeriesStoragePolicy : public EnsembleStoragePolicy < TsType > { public : // TODO T should be derived from StorageType, but this is // more work with datatypes' type traits than // I have time and know how, for now. using T = double ; typedef typename std :: remove_pointer < TsType >:: type Type ; typedef typename std :: add_pointer < Type >:: type PtrType ; typedef typename Type :: ElementType ElementType ; private : WritableTimeSeriesEnsembleTimeSeriesStore < T > * store = nullptr ; size_t index ; TimeSeriesEnsembleTimeSeriesStoragePolicy () { } public : TimeSeriesEnsembleTimeSeriesStoragePolicy ( WritableTimeSeriesEnsembleTimeSeriesStore < T > * store , size_t index ) : store ( store ), index ( index ) { if ( store == nullptr ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"store must not be nullptr for an TimeSeriesEnsembleTimeSeriesStoragePolicy\" ); } void Reset ( const vector < PtrType >& values , const ptime & startDate , const TimeStep & timeStep ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); } TimeSeriesEnsembleTimeSeriesStoragePolicy ( const TimeSeriesEnsembleTimeSeriesStoragePolicy < TsType >& src ) { DeepCopyFrom ( src ); } EnsembleStoragePolicy < TsType >* Clone () const { return new TimeSeriesEnsembleTimeSeriesStoragePolicy < TsType > ( * this ); } ~ TimeSeriesEnsembleTimeSeriesStoragePolicy () { Clear (); } TimeSeriesEnsembleTimeSeriesStoragePolicy & operator = ( TimeSeriesEnsembleTimeSeriesStoragePolicy && src ) { if ( & src == this ) { return * this ; } std :: swap ( store , src . store ); return * this ; } void ResetSeries ( const size_t & numSeries , const size_t & lengthSeries , const ptime & startDate , const TimeStep & timeStep ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); } PtrType GetReplicate ( size_t i ) { return store -> GetItem ( \"\" , index , i ); } TsType Get ( size_t i ) { return TsType ( GetReplicate ( i )); } ElementType Get ( size_t i , size_t tsIndex ) { return GetReplicate ( i ) -> GetValue ( tsIndex ); } void Set ( size_t i , size_t tsIndex , ElementType val ) { PtrType ts = GetReplicate ( i ); ( * ts )[ tsIndex ] = val ; } void Set ( size_t i , const Type & val ) { PtrType ts = GetReplicate ( i ); * ts = val ; // overloaded operator= should do this as expected - tbc } vector < ElementType *>* GetValues () const { vector < ElementType *>* result = new vector < ElementType *> (); datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); return nullptr ; //for (auto& d : series) //{ // result->push_back(d->GetValues()); //} //return result; } void CopyTo ( ElementType ** dest ) const { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); //size_t n = this->Size(); //for (size_t i = 0; i < n; i++) //{ // dest[i] = GetReplicate(i)->GetValues(); //} } size_t Size () const { return store -> GetEnsembleSize ( \"\" , index ); } size_t GetLength ( size_t i ) const { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); return 0 ; //return GetReplicate(i)->GetLength(); } void Clear () { //for (auto& d : series) //{ // if (d != nullptr) delete d; //} //series.clear(); } const vector < PtrType >& AsReadonlyVector () const { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); return dummy ; // required for compilation. } private : vector < PtrType > dummy ; void DeepCopyFrom ( const EnsembleStoragePolicy < TsType >& src ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotImplemented (); Clear (); auto v = src . AsReadonlyVector (); //for (size_t i = 0; i < v.size(); i++) //{ // Type* copy = new Type(*(v.at(i))); // this->series.push_back(copy); //} } protected : void OperatorEqualImpl ( const EnsembleStoragePolicy < TsType >& src ) { DeepCopyFrom ( src ); } }; using namespace datatypes :: exceptions ; template < typename T > class TTimeSeriesLibrary { public : typedef TTimeSeries < T > TS ; typedef MultiTimeSeries < TS *> MTS ; virtual ~ TTimeSeriesLibrary () {} virtual TS * GetSingle ( const string & dataId ) { ExceptionUtilities :: ThrowNotImplemented (); return nullptr ; } virtual TS * GetSingle ( const string & dataId , const string & collectionIdentifier ) { ExceptionUtilities :: ThrowNotImplemented (); return nullptr ; } virtual MTS * GetCollection ( const string & dataId ) { ExceptionUtilities :: ThrowNotImplemented (); return nullptr ; } virtual TimeSeriesProvider < T >* GetProvider ( const string & dataId ) { ExceptionUtilities :: ThrowNotImplemented (); return nullptr ; } virtual MultiTimeSeries < TS *>* GetEnsembleTimeSeries ( const string & dataId ) { ExceptionUtilities :: ThrowNotImplemented (); return nullptr ; } virtual MultiTimeSeries < TS *>* GetAllTimeSeries ( const string & dataId ) { ExceptionUtilities :: ThrowNotImplemented (); return nullptr ; } virtual EnsembleForecastTimeSeries < TS >* GetTimeSeriesEnsembleTimeSeries ( const string & dataId ) { ExceptionUtilities :: ThrowNotImplemented (); return nullptr ; } virtual vector < string > GetIdentifiers () const { ExceptionUtilities :: ThrowNotImplemented (); vector < string > res ; return res ; } }; class TimeSeriesLibrary ; class DATATYPES_DLL_LIB TimeSeriesSourceInfoImpl { protected : TimeSeriesSourceInfoImpl (); TimeSeriesSourceInfoImpl ( const TimeSeriesSourceInfoImpl & src ); public : virtual ~ TimeSeriesSourceInfoImpl (); virtual TimeSeriesSourceInfoImpl * Clone () const = 0 ; virtual bool ApplyRootDir ( const string & rootDir ); virtual SingleTimeSeriesStore < double >* CreateSingleTimeSeriesStore () const ; virtual EnsembleTimeSeriesStore < double >* CreateEnsembleTimeSeriesStore () const ; virtual TimeSeriesEnsembleTimeSeriesStore < double >* CreateTimeSeriesEnsembleTimeSeriesStore () const ; virtual std :: map < string , string > GetSerializableConfiguration () const ; static string OptionalApplyRootDir ( const std :: string & rootDir , const std :: string & filename , bool checkDirExists = true ); }; class DATATYPES_DLL_LIB TimeSeriesSourceInfo { private : TimeSeriesSourceInfoImpl * impl = nullptr ; public : TimeSeriesSourceInfo ( const TimeSeriesSourceInfoImpl & t ); TimeSeriesSourceInfo ( const TimeSeriesSourceInfo & src ); TimeSeriesSourceInfo (); virtual ~ TimeSeriesSourceInfo (); TimeSeriesSourceInfo ( TimeSeriesSourceInfo && src ); TimeSeriesSourceInfo & operator = ( const TimeSeriesSourceInfo & src ); TimeSeriesSourceInfo & operator = ( TimeSeriesSourceInfo && src ); SingleTimeSeriesStore < double >* CreateSingleTimeSeriesStore () const ; EnsembleTimeSeriesStore < double >* CreateEnsembleTimeSeriesStore () const ; TimeSeriesEnsembleTimeSeriesStore < double >* CreateTimeSeriesEnsembleTimeSeriesStore () const ; bool ApplyRootDir ( const string & rootDir ); std :: map < string , string > GetSerializableConfiguration () const ; static const string IdDataKey ; static const string SingleSeriesTypeId ; static const string EnsembleSeriesTypeId ; static const string TimeSeriesEnsemblesTypeId ; static const string SingleSeriesCollectionTypeId ; private : //string DataId() const; //string Identifier() const; //string StorageType() const; //int Index() const; //string TimeStep() const; //string Start() const; //int Length() const; //int EnsembleSize() const; //int EnsembleLength() const; //string EnsembleTimeStep() const; //string FileName() const; //string NcVarName() const; }; class DATATYPES_DLL_LIB NetCdfSourceInfo : public TimeSeriesSourceInfoImpl { private : bool IsFileNamePattern ( const string & s ) const ; public : NetCdfSourceInfo () {} NetCdfSourceInfo ( const string & dataId , const string & fileName , const string & ncVarName , const string & identifier = \"\" , int index = -1 , const string & storageType = \"\" , const string & timeStep = \"\" , const string & start = \"\" , int length = -1 , int ensembleSize = -1 , int ensembleLength = -1 , const string & ensembleTimeStep = \"\" , const string & containingDirectory = \"\" ); NetCdfSourceInfo ( const string & dataId , const string & fileName , const string & ncVarName , const string & identifier , int index , const string & storageType , const TimeStep & timeStep , const ptime & start , int length , int ensembleSize , int ensembleLength , const TimeStep & ensembleTimeStep /*, const string& collectionDimensionId*/ ); TimeSeriesSourceInfoImpl * Clone () const ; bool ApplyRootDir ( const string & rootDir ); SingleTimeSeriesStore < double >* CreateSingleTimeSeriesStore () const ; EnsembleTimeSeriesStore < double >* CreateEnsembleTimeSeriesStore () const ; TimeSeriesEnsembleTimeSeriesStore < double >* CreateTimeSeriesEnsembleTimeSeriesStore () const ; std :: map < string , string > GetSerializableConfiguration () const ; static const string FileKey ; static const string VarKey ; static const string IdentifierKey ; static const string IndexKey ; static const string TypeKey ; //static const string TimeStepKey; //static const string StartKey; //static const string LengthKey; //static const string EnsembleSizeKey; //static const string EnsembleLengthKey; //static const string EnsembleTimeStepKey; //static const string FilePatternKey; //static const string MappingKey; //static const string StorageKey; static const string StorageTypeSingleNetcdfFile ; static const string StorageTypeMultipleNetcdfFiles ; private : string dataId ; string fileName ; string ncVarName ; string identifier ; //string collectionDimensionId; string storageType ; int index = -1 ; TimeStep timeStep ; ptime start ; int length = -1 ; int ensembleSize = -1 ; int ensembleLength = -1 ; TimeStep ensembleTimeStep ; }; class DATATYPES_DLL_LIB TimeSeriesLibraryDescription { friend class TimeSeriesLibrary ; private : std :: map < string , TimeSeriesSourceInfo > tsEnsProviders ; std :: map < string , TimeSeriesSourceInfo > singleProviders ; std :: map < string , TimeSeriesSourceInfo > ensProviders ; TimeSeriesSourceInfo GetInfo ( const string & dataId , bool applyRootDir = false ) const ; boost :: filesystem :: path GetRootDirPath () const ; string filenameLoadedFrom ; string dataPath ; public : void AddSingle ( const string & dataId , const TimeSeriesSourceInfo & t ); void AddEnsembleTs ( const string & dataId , const TimeSeriesSourceInfo & t ); void AddTsEnsembleTs ( const string & dataId , const TimeSeriesSourceInfo & t ); boost :: filesystem :: path GetFullPath ( const string & relativePath ) const ; string GetRootDirectory () const ; vector < string > GetDataIdSingle () const ; vector < string > GetDataIdEnsembleTs () const ; vector < string > GetDataIdTsEnsembleTs () const ; std :: map < string , string > GetSerializableConfiguration ( const string & dataId , const vector < string >& mandatoryKeys = vector < string > ({}) ) const ; void SetLoadedFileName ( const string & fileName ); void SetDataPath ( const string & dataPath ); string GetDataPath () const ; SingleTimeSeriesStore < double >* CreateSingleTimeSeriesStore ( const string & dataId ) const ; EnsembleTimeSeriesStore < double >* CreateEnsembleTimeSeriesStore ( const string & dataId ) const ; TimeSeriesEnsembleTimeSeriesStore < double >* CreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ) const ; }; class DATATYPES_DLL_LIB TimeSeriesSourceInfoBuilder { public : virtual bool HandlesStorageType ( const string storageType ) const = 0 ; virtual void BuildTimeSeriesSource ( const string & storageType , const string & dataId , const YAML :: Node & storage , TimeSeriesLibraryDescription & targetContainer ) const = 0 ; }; class DATATYPES_DLL_LIB TimeSeriesStoreFactory { protected : TimeSeriesStoreFactory (); public : virtual ~ TimeSeriesStoreFactory (); virtual TimeSeriesEnsembleTimeSeriesStore < double >* CreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ) = 0 ; virtual bool CanCreateTimeSeriesEnsembleTimeSeriesStore ( const string & dataId ) = 0 ; }; class DATATYPES_DLL_LIB TimeSeriesLibrary : public TimeSeriesProvider < double > , public TTimeSeriesLibrary < double > { public : TimeSeriesLibrary ( TimeSeriesStoreFactory * storeCreator = nullptr ); TimeSeriesLibrary ( const TimeSeriesLibraryDescription & description ); virtual ~ TimeSeriesLibrary (); void Close (); TimeSeriesLibrary & operator = ( TimeSeriesLibrary && src ); TimeSeriesLibrary ( TimeSeriesLibrary && src ); // Maybe the following,m but may introduce too much coupling with on disk representation with SwiftNetCDFAccess. // TTimeSeries<double>* GetSingle(const string& dataId, boost::function<TTimeSeries<double>*(SwiftNetCDFAccess * dataAccess)> tsTransform); TTimeSeries < double >* GetSingle ( const string & dataId , boost :: function < TTimeSeries < double >* ( TTimeSeries < double >* ) >& tsTransform ); vector < string > GetIdentifiers () const ; vector < string > GetIdentifiers ( const string & dataId ) const ; string GetDataSummary ( const string & dataId ); vector < DataDimensionDescriptor > GetDataDimensionsDescription ( const string & dataId ); TTimeSeries < double >* GetSingle ( const string & dataId ); MultiTimeSeries < TTimeSeries < double >*>* GetCollection ( const string & dataId ); // * \\brief Gets a provider, a facade to a collection of time series. // * // * \\param dataId Identifier for the data. // * // * \\return the time series provider. // */ //TimeSeriesProvider<double>* GetProvider(const string& dataId); TTimeSeries < double >* GetSingle ( const string & dataId , const string & collectionIdentifier ); MultiTimeSeries < TTimeSeries < double >*>* GetEnsemble ( const string & dataId , const string & dataItemIdentifier ); MultiTimeSeries < TTimeSeries < double >*>* GetEnsembleTimeSeries ( const string & dataId ); MultiTimeSeries < TTimeSeries < double >*>* GetAllTimeSeries ( const string & dataId ); EnsembleForecastTimeSeries < TTimeSeries < double >>* GetTimeSeriesEnsembleTimeSeries ( const string & dataId ); void AddSource ( const string & dataId , SingleTimeSeriesStore < double >* store ); void AddSource ( const string & dataId , EnsembleTimeSeriesStore < double >* store ); void AddSource ( const string & dataId , TimeSeriesEnsembleTimeSeriesStore < double >* dataAccess ); bool CanCreateTimeSeriesEnsembleSeriesStore ( const string & dataId ); void CreateTimeSeriesEnsembleSeriesStore ( const string & dataId ); private : template < typename U > static bool hasKey ( const std :: map < string , U >& m , const string & dataId ) { return m . find ( dataId ) != m . end (); } std :: map < string , TimeSeriesEnsembleTimeSeriesStore < double >* > tsEnsTimeSeriesProviders ; std :: map < string , EnsembleTimeSeriesStore < double >* > ensTimeSeriesProviders ; std :: map < string , SingleTimeSeriesStore < double >* > timeSeriesProviders ; SingleTimeSeriesStore < double > * GetSeriesInformation ( const string & dataId ); EnsembleTimeSeriesStore < double > * GetEnsembleSeriesInformation ( const string & dataId ); bool IsDataIdTsEnsemble ( const string & dataId ); bool IsDataIdEnsemble ( const string & dataId ); bool IsDataIdSingle ( const string & dataId ); TimeSeriesEnsembleTimeSeriesStore < double > * GetTimeSeriesEnsembleSeriesInformation ( const string & dataId ); SingleTimeSeriesStore < double >* CreateTsSource ( const TimeSeriesSourceInfo & desc ); EnsembleTimeSeriesStore < double >* CreateEnsTsSource ( const TimeSeriesSourceInfo & desc ); TimeSeriesEnsembleTimeSeriesStore < double >* CreateTsEnsTsSource ( const TimeSeriesSourceInfo & desc ); TimeSeriesStoreFactory * storeCreator = nullptr ; }; } } Updated on 2022-08-20 at 19:28:22 +1000","title":"Source code"},{"location":"cpp/Files/time__series__strategies_8hpp/","text":"datatypes/time_series_strategies.hpp \u00b6 Namespaces \u00b6 Name datatypes datatypes::timeseries Classes \u00b6 Name class datatypes::timeseries::StoragePolicy An interface for classes that can handle the storage of data for time series. class datatypes::timeseries::MissingValuePolicy An interface for classes that define missing values in time series. class datatypes::timeseries::DefaultMissingFloatingPointPolicy class datatypes::timeseries::NullPointerIsMissingPolicy class datatypes::timeseries::NegativeIsMissingFloadingPointPolicy class datatypes::timeseries::StlVectorStorage class datatypes::timeseries::SharedVectorStorage A storage strategy for time serie such that data is a shared state amongst several time series. class datatypes::timeseries::MemoryCachingStorageWriter class datatypes::timeseries::EnsembleStoragePolicy class datatypes::timeseries::StdVectorEnsembleStoragePolicy Source code \u00b6 #pragma once //#include \"boost/date_time/posix_time/posix_time.hpp\" #include <boost/function.hpp> #include \"datatypes/common.h\" #include \"datatypes/exception_utilities.h\" #include <iterator> namespace datatypes { namespace timeseries { template < typename T > class StoragePolicy : public TimeSeriesInfoProvider { protected : StoragePolicy ( const StoragePolicy & src ) { } StoragePolicy () {} public : virtual ~ StoragePolicy () {} virtual void CopyTo ( vector < T >& dest , size_t from = 0 , size_t to = -1 ) const = 0 ; virtual size_t Size () const = 0 ; virtual void Allocate ( size_t length , T value ) = 0 ; virtual void AllocateValues ( size_t length , const T * values ) = 0 ; virtual void AllocateValues ( const vector < T >& values ) = 0 ; virtual const T & operator []( const size_t i ) const = 0 ; virtual T & operator []( const size_t i ) = 0 ; virtual StoragePolicy * Clone () const = 0 ; virtual void CopyTo ( StoragePolicy < T >& dest ) { vector < T > x ; this -> CopyTo ( x ); dest . SetStart ( this -> GetStart ()); dest . SetTimeStep ( this -> GetTimeStep ()); dest . AllocateValues ( x ); } virtual bool ReadOnly () { return false ; } virtual TimeStep GetTimeStep () const = 0 ; virtual ptime GetStart () const = 0 ; virtual void SetTimeStep ( const TimeStep & tStep ) = 0 ; virtual void SetStart ( const ptime & start ) = 0 ; }; template < typename T > class MissingValuePolicy { public : virtual ~ MissingValuePolicy () {} virtual bool IsMissingValue ( const T & a ) const = 0 ; virtual T GetMissingValue () const = 0 ; virtual MissingValuePolicy * Clone () const = 0 ; }; template < typename T = double > class DefaultMissingFloatingPointPolicy : public MissingValuePolicy < T > { private : const T missingValue = ( T )( DEFAULT_MISSING_DATA_VALUE ); public : inline bool IsMissingValue ( const T & a ) const { return ( a == missingValue ); }; inline T GetMissingValue () const { return missingValue ; }; MissingValuePolicy < T >* Clone () const { return new DefaultMissingFloatingPointPolicy < T > (); }; }; template < typename T > class NullPointerIsMissingPolicy : public MissingValuePolicy < T > { public : inline bool IsMissingValue ( const T & a ) const { return ( a == nullptr ); }; inline T GetMissingValue () const { return nullptr ; }; MissingValuePolicy < T >* Clone () const { return new NullPointerIsMissingPolicy < T > (); }; }; template < typename T = double > class NegativeIsMissingFloadingPointPolicy : public MissingValuePolicy < T > { private : const T missingValue = ( T )( DEFAULT_MISSING_DATA_VALUE ); public : inline bool IsMissingValue ( const T & a ) const { return ( a < T ()); }; inline T GetMissingValue () const { return missingValue ; }; MissingValuePolicy < T >* Clone () const { return new NegativeIsMissingFloadingPointPolicy < T > (); }; }; template < typename T = double > class StlVectorStorage : public StoragePolicy < T > { private : StlVectorStorage ( const StlVectorStorage & src ) : StoragePolicy < T > ( src ) { data = src . data ; startDate = src . startDate ; timeStep = src . timeStep ; } vector < T > data ; void CheckIntervalBounds ( const size_t & from , size_t & to ) const { size_t tsLen = this -> Size (); datatypes :: exceptions :: RangeCheck < size_t >:: CheckTimeSeriesInterval ( from , to , tsLen ); } private : // the temporal information for the time series must be stored here // to support time series with shared storages. Conceptually not quite satisfying, // but preferable to shared values with different time series with different temporal // characteristics, for now. ptime startDate ; TimeStep timeStep ; public : StlVectorStorage () { } size_t Size () const { return data . size (); } size_t GetLength () const { return Size (); } void Allocate ( size_t length , T value ) { data . clear (); data . reserve ( length ); data . assign ( length , value ); } void AllocateValues ( size_t length , const T * values ) { data . clear (); data . reserve ( length ); data . assign ( values , values + length ); } void AllocateValues ( const vector < T >& values ) { data . clear (); data . reserve ( values . size ()); data . assign ( values . begin (), values . end ()); } void CopyTo ( vector < T >& dest , size_t from = 0 , size_t to = -1 ) const { CheckIntervalBounds ( from , to ); size_t len = ( to - from ) + 1 ; if ( dest . size () != len ) { dest . clear (); dest . resize ( len ); }; std :: copy ( data . begin () + from , data . begin () + to + 1 , dest . begin ()); } T & operator []( const size_t i ) { // Add a check on index bounds. // If performance requires it, we might restrict this check based on whether T is a class or a numeric type // in a manner similar to DefaultMissingValuePolicyTypeFactory. But prefer safety. datatypes :: exceptions :: RangeCheck < size_t >:: CheckTimeSeriesIndex ( i , data . size (), \"i\" ); T & vRef = data [ i ]; return vRef ; } const T & operator []( const size_t i ) const { datatypes :: exceptions :: RangeCheck < size_t >:: CheckTimeSeriesIndex ( i , data . size (), \"i\" ); return data [ i ]; } StoragePolicy < T >* Clone () const { return new StlVectorStorage < T > ( * this ); } TimeStep GetTimeStep () const override { return timeStep ; } ptime GetStart () const override { return startDate ; } void SetTimeStep ( const TimeStep & tStep ) override { timeStep = tStep ; } void SetStart ( const ptime & start ) override { startDate = start ; } }; template < typename T = double > class SharedVectorStorage : public StoragePolicy < T > { private : SharedVectorStorage ( const SharedVectorStorage & src ) { d = src . d ; } class SharedData { public : vector < T > data ; ptime startDate ; TimeStep timeStep ; }; using SD = typename SharedVectorStorage < T >:: SharedData ; std :: shared_ptr < SD > d ; void CheckIntervalBounds ( const size_t & from , size_t & to ) const { size_t tsLen = this -> Size (); datatypes :: exceptions :: RangeCheck < size_t >:: CheckTimeSeriesInterval ( from , to , tsLen ); } public : SharedVectorStorage () { d = std :: shared_ptr < SD > ( new SD ()); } size_t Size () const { return d -> data . size (); } void Allocate ( size_t length , T value ) { d -> data . clear (); d -> data . reserve ( length ); d -> data . assign ( length , value ); } void AllocateValues ( size_t length , const T * values ) { d -> data . clear (); d -> data . reserve ( length ); d -> data . assign ( values , values + length ); } void AllocateValues ( const vector < T >& values ) { d -> data . clear (); d -> data . reserve ( values . size ()); d -> data . assign ( values . begin (), values . end ()); } void CopyTo ( vector < T >& dest , size_t from = 0 , size_t to = -1 ) const { size_t tsLen = this -> Size (); if ( tsLen == 0 ) return ; CheckIntervalBounds ( from , to ); size_t len = ( to - from ) + 1 ; if ( dest . size () != len ) { dest . clear (); dest . resize ( len ); }; std :: copy ( d -> data . begin () + from , d -> data . begin () + to + 1 , dest . begin ()); } T & operator []( const size_t i ) { datatypes :: exceptions :: RangeCheck < size_t >:: CheckTimeSeriesIndex ( i , ( d -> data ). size (), \"i\" ); T & vRef = ( d -> data )[ i ]; return vRef ; } const T & operator []( const size_t i ) const { datatypes :: exceptions :: RangeCheck < size_t >:: CheckTimeSeriesIndex ( i , ( d -> data ). size (), \"i\" ); return ( d -> data )[ i ]; } StoragePolicy < T >* Clone () const { return new SharedVectorStorage < T > ( * this ); } size_t GetLength () const { return Size (); } TimeStep GetTimeStep () const override { return d -> timeStep ; } ptime GetStart () const override { return d -> startDate ; } void SetTimeStep ( const TimeStep & tStep ) override { d -> timeStep = tStep ; } void SetStart ( const ptime & start ) override { d -> startDate = start ; } }; template < typename T = double > class MemoryCachingStorageWriter : public StoragePolicy < T > { protected : MemoryCachingStorageWriter ( const MemoryCachingStorageWriter & src ) : StoragePolicy < T > ( src ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotSupported ( \"MemoryCachingStorageWriter\" , \"copy ctor\" ); } private : vector < T > buffer ; size_t bufferSize ; size_t bufferPosition ; void CheckIntervalBounds ( const size_t & from , size_t & to ) const { size_t tsLen = this -> Size (); datatypes :: exceptions :: RangeCheck < size_t >:: CheckTimeSeriesInterval ( from , to , tsLen ); } StoragePolicy < T >* wrappedStorage ; public : MemoryCachingStorageWriter ( size_t bufferSize , StoragePolicy < T >* wrappedStorage ) : StoragePolicy < T > (), bufferSize ( bufferSize ) { if ( wrappedStorage == nullptr ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"wrappedStorage must not be a nullptr\" ); buffer = vector < T > ( bufferSize ); bufferPosition = 0 ; this -> wrappedStorage = wrappedStorage ; } T & GetWindowItem ( size_t i ) { return buffer [ i ]; } T & GetBackendItem ( size_t i ) { return ( * wrappedStorage ). operator []( i ); } size_t Size () const { return wrappedStorage -> Size (); } size_t GetLength () const { return Size (); } TimeStep GetTimeStep () const override { return wrappedStorage -> GetTimeStep (); } ptime GetStart () const override { return wrappedStorage -> GetStart (); } void SetTimeStep ( const TimeStep & tStep ) override { wrappedStorage -> SetTimeStep ( tStep ); } void SetStart ( const ptime & start ) override { wrappedStorage -> SetStart ( start ); } void ResetBuffer () { using U = typename datatypes :: utils :: DisposeVectorTypeFactory < T >:: type ; U :: Dispose ( buffer ); } void Allocate ( size_t length , T value ) { ResetBuffer (); buffer = vector < T > ( bufferSize ); bufferPosition = 0 ; wrappedStorage -> Allocate ( length , value ); } void AllocateValues ( size_t length , const T * values ) { //datatypes::exceptions::ExceptionUtilities::ThrowNotSupported(\"MemoryCachingStorageWriter\", \"AllocateValues(size_t length, const T* values)\"); ResetBuffer (); buffer = vector < T > ( bufferSize ); bufferPosition = 0 ; wrappedStorage -> AllocateValues ( length , values ); } void AllocateValues ( const vector < T >& values ) { ResetBuffer (); buffer = vector < T > ( bufferSize ); bufferPosition = 0 ; wrappedStorage -> AllocateValues ( values ); } void CopyTo ( vector < T >& dest , size_t from = 0 , size_t to = -1 ) const { wrappedStorage -> CopyTo ( dest , from , to ); } private : void shiftWindow ( size_t i ) { size_t n = std :: min ( bufferSize , wrappedStorage -> Size () - bufferPosition ); for ( size_t j = 0 ; j < bufferSize ; j ++ ) { ( * wrappedStorage ). operator []( bufferPosition + j ) = buffer [ j ]; } //std::copy(buffer.begin(), buffer.begin() + n, data.begin() + bufferPosition); buffer = vector < T > ( bufferSize ); bufferPosition = i / bufferSize ; } public : T & operator []( const size_t i ) { // Add a check on index bounds. // If performance requires it, we might restrict this check based on whether T is a class or a numeric type // in a manner similar to DefaultMissingValuePolicyTypeFactory. But prefer safety. datatypes :: exceptions :: RangeCheck < size_t >:: CheckTimeSeriesIndex ( i , wrappedStorage -> Size (), \"i\" ); if ( i > ( this -> bufferPosition + this -> bufferSize - 1 )) shiftWindow ( i ); T & vRef = buffer [ i % bufferSize ]; return vRef ; } const T & operator []( const size_t i ) const { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotSupported ( \"MemoryCachingStorageWriter\" , \"AllocateValues(size_t length, const T* values)\" ); //datatypes::exceptions::RangeCheck<size_t>::CheckTimeSeriesIndex(i, wrappedStorage->Size(), \"i\"); //return data[i]; return buffer [ -1 ]; } StoragePolicy < T >* Clone () const { return new MemoryCachingStorageWriter < T > ( * this ); } }; template < typename TsType > class EnsembleStoragePolicy { public : typedef typename std :: remove_pointer < TsType >:: type Type ; typedef typename std :: add_pointer < Type >:: type PtrType ; typedef typename Type :: ElementType ElementType ; EnsembleStoragePolicy () {} virtual ~ EnsembleStoragePolicy () {} virtual void Reset ( const vector < PtrType >& values , const ptime & startDate , const TimeStep & timeStep ) = 0 ; EnsembleStoragePolicy & operator = ( const EnsembleStoragePolicy & src ) { if ( & src == this ) { return * this ; } OperatorEqualImpl ( src ); return * this ; } // ?? virtual EnsembleStoragePolicy& operator=(EnsembleStoragePolicy&& src) = 0; virtual void ResetSeries ( const size_t & numSeries , const size_t & lengthSeries , const ptime & startDate , const TimeStep & timeStep ) = 0 ; virtual TsType Get ( size_t i ) = 0 ; virtual ElementType Get ( size_t i , size_t tsIndex ) = 0 ; virtual void Set ( size_t i , size_t tsIndex , ElementType val ) = 0 ; virtual void Set ( size_t i , const Type & val ) = 0 ; virtual vector < ElementType *>* GetValues () const = 0 ; virtual void CopyTo ( ElementType ** dest ) const = 0 ; virtual size_t Size () const = 0 ; virtual size_t GetLength ( size_t i ) const = 0 ; //virtual ptime GetStartDate() const = 0; //virtual TimeStep GetTimeStep() const = 0; virtual void Clear () = 0 ; virtual const vector < PtrType >& AsReadonlyVector () const = 0 ; virtual EnsembleStoragePolicy < TsType >* Clone () const = 0 ; protected : virtual void OperatorEqualImpl ( const EnsembleStoragePolicy < TsType >& src ) = 0 ; }; template < typename TsType > class StdVectorEnsembleStoragePolicy : public EnsembleStoragePolicy < TsType > { public : typedef typename std :: remove_pointer < TsType >:: type Type ; typedef typename std :: add_pointer < Type >:: type PtrType ; typedef typename Type :: ElementType ElementType ; private : vector < PtrType > series ; public : void Reset ( const vector < PtrType >& values , const ptime & startDate , const TimeStep & timeStep ) { Clear (); for ( const PtrType d : values ) { series . push_back ( new Type ( * d )); } } StdVectorEnsembleStoragePolicy ( const StdVectorEnsembleStoragePolicy < TsType >& src ) { DeepCopyFrom ( src ); } StdVectorEnsembleStoragePolicy () { } ~ StdVectorEnsembleStoragePolicy () { Clear (); } StdVectorEnsembleStoragePolicy & operator = ( StdVectorEnsembleStoragePolicy && src ) { if ( & src == this ) { return * this ; } std :: swap ( series , src . series ); return * this ; } void ResetSeries ( const size_t & numSeries , const size_t & lengthSeries , const ptime & startDate , const TimeStep & timeStep ) { Clear (); for ( size_t i = 0 ; i < numSeries ; i ++ ) { series . push_back ( new Type ( lengthSeries , startDate , timeStep )); } } TsType Get ( size_t i ) { return TsType ( series . at ( i )); } Type Get ( size_t i ) const { return Type ( series . at ( i )); } ElementType Get ( size_t i , size_t tsIndex ) { return ( * series [ i ])[ tsIndex ]; } void Set ( size_t i , size_t tsIndex , ElementType val ) { PtrType a = series . at ( i ); ( * a )[ tsIndex ] = val ; } void Set ( size_t i , const Type & val ) { PtrType ts = series [ i ]; * ts = val ; // overloaded operator= should do this as expected - tbc } vector < ElementType *>* GetValues () const { vector < ElementType *>* result = new vector < ElementType *> (); for ( auto & d : series ) { result -> push_back ( d -> GetValues ()); } return result ; } void CopyTo ( ElementType ** dest ) const { for ( size_t i = 0 ; i < series . size (); i ++ ) { dest [ i ] = series [ i ] -> GetValues (); } } size_t Size () const { return this -> series . size (); } size_t GetLength ( size_t i ) const { return this -> series [ i ] -> GetLength (); } void Clear () { for ( auto & d : series ) { if ( d != nullptr ) delete d ; } series . clear (); } const vector < PtrType >& AsReadonlyVector () const { return series ; } EnsembleStoragePolicy < TsType >* Clone () const { return new StdVectorEnsembleStoragePolicy < TsType > ( * this ); } private : void DeepCopyFrom ( const EnsembleStoragePolicy < TsType >& src ) { Clear (); auto v = src . AsReadonlyVector (); for ( size_t i = 0 ; i < v . size (); i ++ ) { Type * copy = new Type ( * ( v . at ( i ))); this -> series . push_back ( copy ); } } protected : void OperatorEqualImpl ( const EnsembleStoragePolicy < TsType >& src ) { DeepCopyFrom ( src ); } }; } } Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes/time_series_strategies.hpp"},{"location":"cpp/Files/time__series__strategies_8hpp/#datatypestime_series_strategieshpp","text":"","title":"datatypes/time_series_strategies.hpp"},{"location":"cpp/Files/time__series__strategies_8hpp/#namespaces","text":"Name datatypes datatypes::timeseries","title":"Namespaces"},{"location":"cpp/Files/time__series__strategies_8hpp/#classes","text":"Name class datatypes::timeseries::StoragePolicy An interface for classes that can handle the storage of data for time series. class datatypes::timeseries::MissingValuePolicy An interface for classes that define missing values in time series. class datatypes::timeseries::DefaultMissingFloatingPointPolicy class datatypes::timeseries::NullPointerIsMissingPolicy class datatypes::timeseries::NegativeIsMissingFloadingPointPolicy class datatypes::timeseries::StlVectorStorage class datatypes::timeseries::SharedVectorStorage A storage strategy for time serie such that data is a shared state amongst several time series. class datatypes::timeseries::MemoryCachingStorageWriter class datatypes::timeseries::EnsembleStoragePolicy class datatypes::timeseries::StdVectorEnsembleStoragePolicy","title":"Classes"},{"location":"cpp/Files/time__series__strategies_8hpp/#source-code","text":"#pragma once //#include \"boost/date_time/posix_time/posix_time.hpp\" #include <boost/function.hpp> #include \"datatypes/common.h\" #include \"datatypes/exception_utilities.h\" #include <iterator> namespace datatypes { namespace timeseries { template < typename T > class StoragePolicy : public TimeSeriesInfoProvider { protected : StoragePolicy ( const StoragePolicy & src ) { } StoragePolicy () {} public : virtual ~ StoragePolicy () {} virtual void CopyTo ( vector < T >& dest , size_t from = 0 , size_t to = -1 ) const = 0 ; virtual size_t Size () const = 0 ; virtual void Allocate ( size_t length , T value ) = 0 ; virtual void AllocateValues ( size_t length , const T * values ) = 0 ; virtual void AllocateValues ( const vector < T >& values ) = 0 ; virtual const T & operator []( const size_t i ) const = 0 ; virtual T & operator []( const size_t i ) = 0 ; virtual StoragePolicy * Clone () const = 0 ; virtual void CopyTo ( StoragePolicy < T >& dest ) { vector < T > x ; this -> CopyTo ( x ); dest . SetStart ( this -> GetStart ()); dest . SetTimeStep ( this -> GetTimeStep ()); dest . AllocateValues ( x ); } virtual bool ReadOnly () { return false ; } virtual TimeStep GetTimeStep () const = 0 ; virtual ptime GetStart () const = 0 ; virtual void SetTimeStep ( const TimeStep & tStep ) = 0 ; virtual void SetStart ( const ptime & start ) = 0 ; }; template < typename T > class MissingValuePolicy { public : virtual ~ MissingValuePolicy () {} virtual bool IsMissingValue ( const T & a ) const = 0 ; virtual T GetMissingValue () const = 0 ; virtual MissingValuePolicy * Clone () const = 0 ; }; template < typename T = double > class DefaultMissingFloatingPointPolicy : public MissingValuePolicy < T > { private : const T missingValue = ( T )( DEFAULT_MISSING_DATA_VALUE ); public : inline bool IsMissingValue ( const T & a ) const { return ( a == missingValue ); }; inline T GetMissingValue () const { return missingValue ; }; MissingValuePolicy < T >* Clone () const { return new DefaultMissingFloatingPointPolicy < T > (); }; }; template < typename T > class NullPointerIsMissingPolicy : public MissingValuePolicy < T > { public : inline bool IsMissingValue ( const T & a ) const { return ( a == nullptr ); }; inline T GetMissingValue () const { return nullptr ; }; MissingValuePolicy < T >* Clone () const { return new NullPointerIsMissingPolicy < T > (); }; }; template < typename T = double > class NegativeIsMissingFloadingPointPolicy : public MissingValuePolicy < T > { private : const T missingValue = ( T )( DEFAULT_MISSING_DATA_VALUE ); public : inline bool IsMissingValue ( const T & a ) const { return ( a < T ()); }; inline T GetMissingValue () const { return missingValue ; }; MissingValuePolicy < T >* Clone () const { return new NegativeIsMissingFloadingPointPolicy < T > (); }; }; template < typename T = double > class StlVectorStorage : public StoragePolicy < T > { private : StlVectorStorage ( const StlVectorStorage & src ) : StoragePolicy < T > ( src ) { data = src . data ; startDate = src . startDate ; timeStep = src . timeStep ; } vector < T > data ; void CheckIntervalBounds ( const size_t & from , size_t & to ) const { size_t tsLen = this -> Size (); datatypes :: exceptions :: RangeCheck < size_t >:: CheckTimeSeriesInterval ( from , to , tsLen ); } private : // the temporal information for the time series must be stored here // to support time series with shared storages. Conceptually not quite satisfying, // but preferable to shared values with different time series with different temporal // characteristics, for now. ptime startDate ; TimeStep timeStep ; public : StlVectorStorage () { } size_t Size () const { return data . size (); } size_t GetLength () const { return Size (); } void Allocate ( size_t length , T value ) { data . clear (); data . reserve ( length ); data . assign ( length , value ); } void AllocateValues ( size_t length , const T * values ) { data . clear (); data . reserve ( length ); data . assign ( values , values + length ); } void AllocateValues ( const vector < T >& values ) { data . clear (); data . reserve ( values . size ()); data . assign ( values . begin (), values . end ()); } void CopyTo ( vector < T >& dest , size_t from = 0 , size_t to = -1 ) const { CheckIntervalBounds ( from , to ); size_t len = ( to - from ) + 1 ; if ( dest . size () != len ) { dest . clear (); dest . resize ( len ); }; std :: copy ( data . begin () + from , data . begin () + to + 1 , dest . begin ()); } T & operator []( const size_t i ) { // Add a check on index bounds. // If performance requires it, we might restrict this check based on whether T is a class or a numeric type // in a manner similar to DefaultMissingValuePolicyTypeFactory. But prefer safety. datatypes :: exceptions :: RangeCheck < size_t >:: CheckTimeSeriesIndex ( i , data . size (), \"i\" ); T & vRef = data [ i ]; return vRef ; } const T & operator []( const size_t i ) const { datatypes :: exceptions :: RangeCheck < size_t >:: CheckTimeSeriesIndex ( i , data . size (), \"i\" ); return data [ i ]; } StoragePolicy < T >* Clone () const { return new StlVectorStorage < T > ( * this ); } TimeStep GetTimeStep () const override { return timeStep ; } ptime GetStart () const override { return startDate ; } void SetTimeStep ( const TimeStep & tStep ) override { timeStep = tStep ; } void SetStart ( const ptime & start ) override { startDate = start ; } }; template < typename T = double > class SharedVectorStorage : public StoragePolicy < T > { private : SharedVectorStorage ( const SharedVectorStorage & src ) { d = src . d ; } class SharedData { public : vector < T > data ; ptime startDate ; TimeStep timeStep ; }; using SD = typename SharedVectorStorage < T >:: SharedData ; std :: shared_ptr < SD > d ; void CheckIntervalBounds ( const size_t & from , size_t & to ) const { size_t tsLen = this -> Size (); datatypes :: exceptions :: RangeCheck < size_t >:: CheckTimeSeriesInterval ( from , to , tsLen ); } public : SharedVectorStorage () { d = std :: shared_ptr < SD > ( new SD ()); } size_t Size () const { return d -> data . size (); } void Allocate ( size_t length , T value ) { d -> data . clear (); d -> data . reserve ( length ); d -> data . assign ( length , value ); } void AllocateValues ( size_t length , const T * values ) { d -> data . clear (); d -> data . reserve ( length ); d -> data . assign ( values , values + length ); } void AllocateValues ( const vector < T >& values ) { d -> data . clear (); d -> data . reserve ( values . size ()); d -> data . assign ( values . begin (), values . end ()); } void CopyTo ( vector < T >& dest , size_t from = 0 , size_t to = -1 ) const { size_t tsLen = this -> Size (); if ( tsLen == 0 ) return ; CheckIntervalBounds ( from , to ); size_t len = ( to - from ) + 1 ; if ( dest . size () != len ) { dest . clear (); dest . resize ( len ); }; std :: copy ( d -> data . begin () + from , d -> data . begin () + to + 1 , dest . begin ()); } T & operator []( const size_t i ) { datatypes :: exceptions :: RangeCheck < size_t >:: CheckTimeSeriesIndex ( i , ( d -> data ). size (), \"i\" ); T & vRef = ( d -> data )[ i ]; return vRef ; } const T & operator []( const size_t i ) const { datatypes :: exceptions :: RangeCheck < size_t >:: CheckTimeSeriesIndex ( i , ( d -> data ). size (), \"i\" ); return ( d -> data )[ i ]; } StoragePolicy < T >* Clone () const { return new SharedVectorStorage < T > ( * this ); } size_t GetLength () const { return Size (); } TimeStep GetTimeStep () const override { return d -> timeStep ; } ptime GetStart () const override { return d -> startDate ; } void SetTimeStep ( const TimeStep & tStep ) override { d -> timeStep = tStep ; } void SetStart ( const ptime & start ) override { d -> startDate = start ; } }; template < typename T = double > class MemoryCachingStorageWriter : public StoragePolicy < T > { protected : MemoryCachingStorageWriter ( const MemoryCachingStorageWriter & src ) : StoragePolicy < T > ( src ) { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotSupported ( \"MemoryCachingStorageWriter\" , \"copy ctor\" ); } private : vector < T > buffer ; size_t bufferSize ; size_t bufferPosition ; void CheckIntervalBounds ( const size_t & from , size_t & to ) const { size_t tsLen = this -> Size (); datatypes :: exceptions :: RangeCheck < size_t >:: CheckTimeSeriesInterval ( from , to , tsLen ); } StoragePolicy < T >* wrappedStorage ; public : MemoryCachingStorageWriter ( size_t bufferSize , StoragePolicy < T >* wrappedStorage ) : StoragePolicy < T > (), bufferSize ( bufferSize ) { if ( wrappedStorage == nullptr ) datatypes :: exceptions :: ExceptionUtilities :: ThrowInvalidArgument ( \"wrappedStorage must not be a nullptr\" ); buffer = vector < T > ( bufferSize ); bufferPosition = 0 ; this -> wrappedStorage = wrappedStorage ; } T & GetWindowItem ( size_t i ) { return buffer [ i ]; } T & GetBackendItem ( size_t i ) { return ( * wrappedStorage ). operator []( i ); } size_t Size () const { return wrappedStorage -> Size (); } size_t GetLength () const { return Size (); } TimeStep GetTimeStep () const override { return wrappedStorage -> GetTimeStep (); } ptime GetStart () const override { return wrappedStorage -> GetStart (); } void SetTimeStep ( const TimeStep & tStep ) override { wrappedStorage -> SetTimeStep ( tStep ); } void SetStart ( const ptime & start ) override { wrappedStorage -> SetStart ( start ); } void ResetBuffer () { using U = typename datatypes :: utils :: DisposeVectorTypeFactory < T >:: type ; U :: Dispose ( buffer ); } void Allocate ( size_t length , T value ) { ResetBuffer (); buffer = vector < T > ( bufferSize ); bufferPosition = 0 ; wrappedStorage -> Allocate ( length , value ); } void AllocateValues ( size_t length , const T * values ) { //datatypes::exceptions::ExceptionUtilities::ThrowNotSupported(\"MemoryCachingStorageWriter\", \"AllocateValues(size_t length, const T* values)\"); ResetBuffer (); buffer = vector < T > ( bufferSize ); bufferPosition = 0 ; wrappedStorage -> AllocateValues ( length , values ); } void AllocateValues ( const vector < T >& values ) { ResetBuffer (); buffer = vector < T > ( bufferSize ); bufferPosition = 0 ; wrappedStorage -> AllocateValues ( values ); } void CopyTo ( vector < T >& dest , size_t from = 0 , size_t to = -1 ) const { wrappedStorage -> CopyTo ( dest , from , to ); } private : void shiftWindow ( size_t i ) { size_t n = std :: min ( bufferSize , wrappedStorage -> Size () - bufferPosition ); for ( size_t j = 0 ; j < bufferSize ; j ++ ) { ( * wrappedStorage ). operator []( bufferPosition + j ) = buffer [ j ]; } //std::copy(buffer.begin(), buffer.begin() + n, data.begin() + bufferPosition); buffer = vector < T > ( bufferSize ); bufferPosition = i / bufferSize ; } public : T & operator []( const size_t i ) { // Add a check on index bounds. // If performance requires it, we might restrict this check based on whether T is a class or a numeric type // in a manner similar to DefaultMissingValuePolicyTypeFactory. But prefer safety. datatypes :: exceptions :: RangeCheck < size_t >:: CheckTimeSeriesIndex ( i , wrappedStorage -> Size (), \"i\" ); if ( i > ( this -> bufferPosition + this -> bufferSize - 1 )) shiftWindow ( i ); T & vRef = buffer [ i % bufferSize ]; return vRef ; } const T & operator []( const size_t i ) const { datatypes :: exceptions :: ExceptionUtilities :: ThrowNotSupported ( \"MemoryCachingStorageWriter\" , \"AllocateValues(size_t length, const T* values)\" ); //datatypes::exceptions::RangeCheck<size_t>::CheckTimeSeriesIndex(i, wrappedStorage->Size(), \"i\"); //return data[i]; return buffer [ -1 ]; } StoragePolicy < T >* Clone () const { return new MemoryCachingStorageWriter < T > ( * this ); } }; template < typename TsType > class EnsembleStoragePolicy { public : typedef typename std :: remove_pointer < TsType >:: type Type ; typedef typename std :: add_pointer < Type >:: type PtrType ; typedef typename Type :: ElementType ElementType ; EnsembleStoragePolicy () {} virtual ~ EnsembleStoragePolicy () {} virtual void Reset ( const vector < PtrType >& values , const ptime & startDate , const TimeStep & timeStep ) = 0 ; EnsembleStoragePolicy & operator = ( const EnsembleStoragePolicy & src ) { if ( & src == this ) { return * this ; } OperatorEqualImpl ( src ); return * this ; } // ?? virtual EnsembleStoragePolicy& operator=(EnsembleStoragePolicy&& src) = 0; virtual void ResetSeries ( const size_t & numSeries , const size_t & lengthSeries , const ptime & startDate , const TimeStep & timeStep ) = 0 ; virtual TsType Get ( size_t i ) = 0 ; virtual ElementType Get ( size_t i , size_t tsIndex ) = 0 ; virtual void Set ( size_t i , size_t tsIndex , ElementType val ) = 0 ; virtual void Set ( size_t i , const Type & val ) = 0 ; virtual vector < ElementType *>* GetValues () const = 0 ; virtual void CopyTo ( ElementType ** dest ) const = 0 ; virtual size_t Size () const = 0 ; virtual size_t GetLength ( size_t i ) const = 0 ; //virtual ptime GetStartDate() const = 0; //virtual TimeStep GetTimeStep() const = 0; virtual void Clear () = 0 ; virtual const vector < PtrType >& AsReadonlyVector () const = 0 ; virtual EnsembleStoragePolicy < TsType >* Clone () const = 0 ; protected : virtual void OperatorEqualImpl ( const EnsembleStoragePolicy < TsType >& src ) = 0 ; }; template < typename TsType > class StdVectorEnsembleStoragePolicy : public EnsembleStoragePolicy < TsType > { public : typedef typename std :: remove_pointer < TsType >:: type Type ; typedef typename std :: add_pointer < Type >:: type PtrType ; typedef typename Type :: ElementType ElementType ; private : vector < PtrType > series ; public : void Reset ( const vector < PtrType >& values , const ptime & startDate , const TimeStep & timeStep ) { Clear (); for ( const PtrType d : values ) { series . push_back ( new Type ( * d )); } } StdVectorEnsembleStoragePolicy ( const StdVectorEnsembleStoragePolicy < TsType >& src ) { DeepCopyFrom ( src ); } StdVectorEnsembleStoragePolicy () { } ~ StdVectorEnsembleStoragePolicy () { Clear (); } StdVectorEnsembleStoragePolicy & operator = ( StdVectorEnsembleStoragePolicy && src ) { if ( & src == this ) { return * this ; } std :: swap ( series , src . series ); return * this ; } void ResetSeries ( const size_t & numSeries , const size_t & lengthSeries , const ptime & startDate , const TimeStep & timeStep ) { Clear (); for ( size_t i = 0 ; i < numSeries ; i ++ ) { series . push_back ( new Type ( lengthSeries , startDate , timeStep )); } } TsType Get ( size_t i ) { return TsType ( series . at ( i )); } Type Get ( size_t i ) const { return Type ( series . at ( i )); } ElementType Get ( size_t i , size_t tsIndex ) { return ( * series [ i ])[ tsIndex ]; } void Set ( size_t i , size_t tsIndex , ElementType val ) { PtrType a = series . at ( i ); ( * a )[ tsIndex ] = val ; } void Set ( size_t i , const Type & val ) { PtrType ts = series [ i ]; * ts = val ; // overloaded operator= should do this as expected - tbc } vector < ElementType *>* GetValues () const { vector < ElementType *>* result = new vector < ElementType *> (); for ( auto & d : series ) { result -> push_back ( d -> GetValues ()); } return result ; } void CopyTo ( ElementType ** dest ) const { for ( size_t i = 0 ; i < series . size (); i ++ ) { dest [ i ] = series [ i ] -> GetValues (); } } size_t Size () const { return this -> series . size (); } size_t GetLength ( size_t i ) const { return this -> series [ i ] -> GetLength (); } void Clear () { for ( auto & d : series ) { if ( d != nullptr ) delete d ; } series . clear (); } const vector < PtrType >& AsReadonlyVector () const { return series ; } EnsembleStoragePolicy < TsType >* Clone () const { return new StdVectorEnsembleStoragePolicy < TsType > ( * this ); } private : void DeepCopyFrom ( const EnsembleStoragePolicy < TsType >& src ) { Clear (); auto v = src . AsReadonlyVector (); for ( size_t i = 0 ; i < v . size (); i ++ ) { Type * copy = new Type ( * ( v . at ( i ))); this -> series . push_back ( copy ); } } protected : void OperatorEqualImpl ( const EnsembleStoragePolicy < TsType >& src ) { DeepCopyFrom ( src ); } }; } } Updated on 2022-08-20 at 19:28:22 +1000","title":"Source code"},{"location":"cpp/Files/time__step_8h/","text":"datatypes/time_step.h \u00b6 Namespaces \u00b6 Name datatypes datatypes::timeseries Classes \u00b6 Name class datatypes::timeseries::TimeStep Time step handling for time series. class datatypes::timeseries::TimeSeriesInfoProvider An interface definition for classes that can provide essential time series temporal characteristics. Types \u00b6 Name using boost::posix_time::time_duration::sec_type sec_type Types Documentation \u00b6 using sec_type \u00b6 using sec_type = boost :: posix_time :: time_duration :: sec_type ; Source code \u00b6 #pragma once #include \"boost/date_time/posix_time/posix_time.hpp\" #include \"datatypes/common.h\" #include \"datatypes/exception_utilities.h\" #include \"datatypes/time_step_implementation.h\" using namespace boost :: posix_time ; using sec_type = boost :: posix_time :: time_duration :: sec_type ; namespace datatypes { namespace timeseries { class DATATYPES_DLL_LIB TimeStep { public : TimeStep ( const time_duration & stepDuration ); TimeStep ( TimeStepImplementation * tsi ); TimeStep ( const TimeStep & src ); TimeStep (); ~ TimeStep (); TimeStep & operator = ( const TimeStep & rhs ); TimeStep & operator = ( const time_duration & stepDuration ); TimeStep & operator = ( const string & stepDuration ); bool operator == ( const TimeStep & rhs ) const ; bool operator != ( const TimeStep & rhs ) const ; TimeStep operator * ( int mult ) const ; TimeStep operator * ( double mult ) const ; int operator / ( const TimeStep & divisor ) const ; TimeStep operator / ( int divisor ) const ; time_duration operator % ( const TimeStep & other ) const ; bool IsRegular () const ; time_duration GetRegularStepDuration () const ; //const ptime AddSteps(const ptime& startTimeStep, sec_type n) const; const ptime AddSteps ( const ptime & startTimeStep , size_t n ) const ; const ptime AddSteps ( const ptime & startTimeStep , int n ) const ; const ptime AddSteps ( const ptime & startTimeStep , double mult ) const ; vector < ptime > AddSteps ( const ptime & startTimeStep , const vector < double > timeSteps ) const ; vector < ptime > AddSteps ( const vector < ptime >& times , double mult ) const ; const time_duration GetTimeStepDuration ( const ptime & startTimeStep ) const ; const ptrdiff_t GetUpperNumSteps ( const ptime & start , const ptime & end ) const ; const ptrdiff_t GetNumSteps ( const ptime & start , const ptime & end ) const ; const ptrdiff_t GetOffset ( const ptime & start , const ptime & end ) const ; const void Increment ( ptime * t ) const ; static TimeStep Parse ( const string & name ); static TimeStep FromSeconds ( unsigned int seconds ); static TimeStep GetDaily (); static TimeStep GetHourly (); static TimeStep GetMonthlyQpp (); static TimeStep GetUnknown (); bool IsUnknown () const ; static ptime CreatePtime ( int year , int month , int day , int hour = 0 , int minute = 0 , int second = 0 ); static ptime PtimeFromIsoString ( const string & t ); static string ToString ( const ptime & dt , const string & format = \"YYYYMMDDThhmmss\" ); string GetName () const ; private : TimeStepImplementation * tsImpl = nullptr ; void CopyTimeStepImplementation ( const TimeStep & src ); void CheckIsRegular ( const string & op ) const ; static const time_duration hourlyTd ; static const time_duration dailyTd ; static bool FromGeneralStringPeriod ( const string & name , TimeStep & tstep ); }; class DATATYPES_DLL_LIB TimeSeriesInfoProvider { public : virtual ~ TimeSeriesInfoProvider (); virtual size_t GetLength () const = 0 ; virtual TimeStep GetTimeStep () const = 0 ; virtual ptime GetStart () const = 0 ; }; } } Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes/time_step.h"},{"location":"cpp/Files/time__step_8h/#datatypestime_steph","text":"","title":"datatypes/time_step.h"},{"location":"cpp/Files/time__step_8h/#namespaces","text":"Name datatypes datatypes::timeseries","title":"Namespaces"},{"location":"cpp/Files/time__step_8h/#classes","text":"Name class datatypes::timeseries::TimeStep Time step handling for time series. class datatypes::timeseries::TimeSeriesInfoProvider An interface definition for classes that can provide essential time series temporal characteristics.","title":"Classes"},{"location":"cpp/Files/time__step_8h/#types","text":"Name using boost::posix_time::time_duration::sec_type sec_type","title":"Types"},{"location":"cpp/Files/time__step_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"cpp/Files/time__step_8h/#using-sec_type","text":"using sec_type = boost :: posix_time :: time_duration :: sec_type ;","title":"using sec_type"},{"location":"cpp/Files/time__step_8h/#source-code","text":"#pragma once #include \"boost/date_time/posix_time/posix_time.hpp\" #include \"datatypes/common.h\" #include \"datatypes/exception_utilities.h\" #include \"datatypes/time_step_implementation.h\" using namespace boost :: posix_time ; using sec_type = boost :: posix_time :: time_duration :: sec_type ; namespace datatypes { namespace timeseries { class DATATYPES_DLL_LIB TimeStep { public : TimeStep ( const time_duration & stepDuration ); TimeStep ( TimeStepImplementation * tsi ); TimeStep ( const TimeStep & src ); TimeStep (); ~ TimeStep (); TimeStep & operator = ( const TimeStep & rhs ); TimeStep & operator = ( const time_duration & stepDuration ); TimeStep & operator = ( const string & stepDuration ); bool operator == ( const TimeStep & rhs ) const ; bool operator != ( const TimeStep & rhs ) const ; TimeStep operator * ( int mult ) const ; TimeStep operator * ( double mult ) const ; int operator / ( const TimeStep & divisor ) const ; TimeStep operator / ( int divisor ) const ; time_duration operator % ( const TimeStep & other ) const ; bool IsRegular () const ; time_duration GetRegularStepDuration () const ; //const ptime AddSteps(const ptime& startTimeStep, sec_type n) const; const ptime AddSteps ( const ptime & startTimeStep , size_t n ) const ; const ptime AddSteps ( const ptime & startTimeStep , int n ) const ; const ptime AddSteps ( const ptime & startTimeStep , double mult ) const ; vector < ptime > AddSteps ( const ptime & startTimeStep , const vector < double > timeSteps ) const ; vector < ptime > AddSteps ( const vector < ptime >& times , double mult ) const ; const time_duration GetTimeStepDuration ( const ptime & startTimeStep ) const ; const ptrdiff_t GetUpperNumSteps ( const ptime & start , const ptime & end ) const ; const ptrdiff_t GetNumSteps ( const ptime & start , const ptime & end ) const ; const ptrdiff_t GetOffset ( const ptime & start , const ptime & end ) const ; const void Increment ( ptime * t ) const ; static TimeStep Parse ( const string & name ); static TimeStep FromSeconds ( unsigned int seconds ); static TimeStep GetDaily (); static TimeStep GetHourly (); static TimeStep GetMonthlyQpp (); static TimeStep GetUnknown (); bool IsUnknown () const ; static ptime CreatePtime ( int year , int month , int day , int hour = 0 , int minute = 0 , int second = 0 ); static ptime PtimeFromIsoString ( const string & t ); static string ToString ( const ptime & dt , const string & format = \"YYYYMMDDThhmmss\" ); string GetName () const ; private : TimeStepImplementation * tsImpl = nullptr ; void CopyTimeStepImplementation ( const TimeStep & src ); void CheckIsRegular ( const string & op ) const ; static const time_duration hourlyTd ; static const time_duration dailyTd ; static bool FromGeneralStringPeriod ( const string & name , TimeStep & tstep ); }; class DATATYPES_DLL_LIB TimeSeriesInfoProvider { public : virtual ~ TimeSeriesInfoProvider (); virtual size_t GetLength () const = 0 ; virtual TimeStep GetTimeStep () const = 0 ; virtual ptime GetStart () const = 0 ; }; } } Updated on 2022-08-20 at 19:28:22 +1000","title":"Source code"},{"location":"cpp/Files/time__step__implementation_8h/","text":"datatypes/time_step_implementation.h \u00b6 Namespaces \u00b6 Name datatypes datatypes::timeseries Classes \u00b6 Name class datatypes::timeseries::TimeStepImplementation class datatypes::timeseries::RegularTimeStepImplementation class datatypes::timeseries::IrregularTimeStepImplementation class datatypes::timeseries::MonthlyQppTimeStepImplementation Source code \u00b6 #pragma once #include <string> #include <boost/date_time/gregorian/gregorian.hpp> #include <boost/date_time/posix_time/posix_time.hpp> #include <boost/format.hpp> #include <datatypes/exception_utilities.h> using namespace boost :: posix_time ; using namespace boost :: gregorian ; namespace datatypes { namespace timeseries { // NOTE: added DATATYPES_DLL_LIB to try to resolve https://jira.csiro.au/browse/WIRADA-415 class DATATYPES_DLL_LIB TimeStepImplementation { public : virtual ~ TimeStepImplementation (); static void CheckIsDateTime ( const ptime & instant ); virtual TimeStepImplementation * Clone () = 0 ; virtual TimeStepImplementation * Multiply ( int mult ) const = 0 ; virtual TimeStepImplementation * Divide ( int divisor ) const = 0 ; virtual TimeStepImplementation * Multiply ( double mult ) const = 0 ; virtual bool Equals ( TimeStepImplementation * tsImpl ) const = 0 ; virtual const ptime AddIntSteps ( const ptime & startTimeStep , int n ) const = 0 ; virtual const ptime AddSteps ( const ptime & startTimeStep , double mult ) const = 0 ; virtual const time_duration GetTimeStepDuration ( const ptime & startTimeStep ) const = 0 ; virtual const void Increment ( ptime * t ) const = 0 ; virtual const ptrdiff_t GetUpperNumSteps ( const ptime & start , const ptime & end ) const ; virtual const ptrdiff_t GetNumSteps ( const ptime & start , const ptime & end ) const ; virtual const ptrdiff_t GetOffset ( const ptime & start , const ptime & end ) const ; virtual bool IsRegular () const = 0 ; virtual time_duration GetRegularStepDuration () const = 0 ; virtual std :: string GetName () const = 0 ; protected : virtual const double GetLinearIndexing ( const ptime & start , const ptime & end ) const = 0 ; }; class DATATYPES_DLL_LIB RegularTimeStepImplementation : public TimeStepImplementation { public : static RegularTimeStepImplementation * GetHourly (); static RegularTimeStepImplementation * GetDaily (); RegularTimeStepImplementation ( const time_duration & stepDuration ); virtual ~ RegularTimeStepImplementation (); TimeStepImplementation * Clone (); bool Equals ( TimeStepImplementation * tsImpl ) const ; TimeStepImplementation * Multiply ( int mult ) const ; TimeStepImplementation * Multiply ( double mult ) const ; TimeStepImplementation * Divide ( int divisor ) const ; const ptime AddIntSteps ( const ptime & startTimeStep , int n ) const ; const ptime AddSteps ( const ptime & startTimeStep , double mult ) const ; const time_duration GetTimeStepDuration ( const ptime & startTimeStep ) const ; const void Increment ( ptime * t ) const ; bool IsRegular () const ; time_duration GetRegularStepDuration () const ; std :: string GetName () const ; protected : const double GetLinearIndexing ( const ptime & start , const ptime & end ) const ; private : static const time_duration hourlyTd ; static const time_duration dailyTd ; time_duration multiply ( double mult ) const ; time_duration * regularStep = nullptr ; // void CopyRegularImplementation(const RegularTimeStepImplementation& src); // const ptrdiff_t GetUpperNumInstants(const ptime& start, const ptime& end) const; // const ptrdiff_t GetNumInstants(const ptime& start, const ptime& end) const; }; class DATATYPES_DLL_LIB IrregularTimeStepImplementation : public TimeStepImplementation { public : virtual ~ IrregularTimeStepImplementation () {} virtual TimeStepImplementation * Clone () = 0 ; virtual bool Equals ( TimeStepImplementation * tsImpl ) const = 0 ; TimeStepImplementation * Multiply ( int mult ) const ; TimeStepImplementation * Multiply ( double mult ) const ; TimeStepImplementation * Divide ( int divisor ) const ; virtual const ptime AddIntSteps ( const ptime & startTimeStep , int n ) const = 0 ; virtual const ptime AddSteps ( const ptime & startTimeStep , double mult ) const = 0 ; virtual const time_duration GetTimeStepDuration ( const ptime & startTimeStep ) const ; virtual const void Increment ( ptime * t ) const = 0 ; bool IsRegular () const ; time_duration GetRegularStepDuration () const ; virtual std :: string GetName () const = 0 ; protected : virtual const double GetLinearIndexing ( const ptime & start , const ptime & end ) const = 0 ; }; class DATATYPES_DLL_LIB MonthlyQppTimeStepImplementation : public IrregularTimeStepImplementation { public : virtual ~ MonthlyQppTimeStepImplementation () {} TimeStepImplementation * Clone (); bool Equals ( TimeStepImplementation * tsImpl ) const ; const ptime AddIntSteps ( const ptime & startTimeStep , int n ) const ; const ptime AddSteps ( const ptime & startTimeStep , double mult ) const ; const time_duration GetTimeStepDuration ( const ptime & startTimeStep ) const override ; const void Increment ( ptime * t ) const ; std :: string GetName () const ; protected : const double GetLinearIndexing ( const ptime & start , const ptime & end ) const ; }; } } Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes/time_step_implementation.h"},{"location":"cpp/Files/time__step__implementation_8h/#datatypestime_step_implementationh","text":"","title":"datatypes/time_step_implementation.h"},{"location":"cpp/Files/time__step__implementation_8h/#namespaces","text":"Name datatypes datatypes::timeseries","title":"Namespaces"},{"location":"cpp/Files/time__step__implementation_8h/#classes","text":"Name class datatypes::timeseries::TimeStepImplementation class datatypes::timeseries::RegularTimeStepImplementation class datatypes::timeseries::IrregularTimeStepImplementation class datatypes::timeseries::MonthlyQppTimeStepImplementation","title":"Classes"},{"location":"cpp/Files/time__step__implementation_8h/#source-code","text":"#pragma once #include <string> #include <boost/date_time/gregorian/gregorian.hpp> #include <boost/date_time/posix_time/posix_time.hpp> #include <boost/format.hpp> #include <datatypes/exception_utilities.h> using namespace boost :: posix_time ; using namespace boost :: gregorian ; namespace datatypes { namespace timeseries { // NOTE: added DATATYPES_DLL_LIB to try to resolve https://jira.csiro.au/browse/WIRADA-415 class DATATYPES_DLL_LIB TimeStepImplementation { public : virtual ~ TimeStepImplementation (); static void CheckIsDateTime ( const ptime & instant ); virtual TimeStepImplementation * Clone () = 0 ; virtual TimeStepImplementation * Multiply ( int mult ) const = 0 ; virtual TimeStepImplementation * Divide ( int divisor ) const = 0 ; virtual TimeStepImplementation * Multiply ( double mult ) const = 0 ; virtual bool Equals ( TimeStepImplementation * tsImpl ) const = 0 ; virtual const ptime AddIntSteps ( const ptime & startTimeStep , int n ) const = 0 ; virtual const ptime AddSteps ( const ptime & startTimeStep , double mult ) const = 0 ; virtual const time_duration GetTimeStepDuration ( const ptime & startTimeStep ) const = 0 ; virtual const void Increment ( ptime * t ) const = 0 ; virtual const ptrdiff_t GetUpperNumSteps ( const ptime & start , const ptime & end ) const ; virtual const ptrdiff_t GetNumSteps ( const ptime & start , const ptime & end ) const ; virtual const ptrdiff_t GetOffset ( const ptime & start , const ptime & end ) const ; virtual bool IsRegular () const = 0 ; virtual time_duration GetRegularStepDuration () const = 0 ; virtual std :: string GetName () const = 0 ; protected : virtual const double GetLinearIndexing ( const ptime & start , const ptime & end ) const = 0 ; }; class DATATYPES_DLL_LIB RegularTimeStepImplementation : public TimeStepImplementation { public : static RegularTimeStepImplementation * GetHourly (); static RegularTimeStepImplementation * GetDaily (); RegularTimeStepImplementation ( const time_duration & stepDuration ); virtual ~ RegularTimeStepImplementation (); TimeStepImplementation * Clone (); bool Equals ( TimeStepImplementation * tsImpl ) const ; TimeStepImplementation * Multiply ( int mult ) const ; TimeStepImplementation * Multiply ( double mult ) const ; TimeStepImplementation * Divide ( int divisor ) const ; const ptime AddIntSteps ( const ptime & startTimeStep , int n ) const ; const ptime AddSteps ( const ptime & startTimeStep , double mult ) const ; const time_duration GetTimeStepDuration ( const ptime & startTimeStep ) const ; const void Increment ( ptime * t ) const ; bool IsRegular () const ; time_duration GetRegularStepDuration () const ; std :: string GetName () const ; protected : const double GetLinearIndexing ( const ptime & start , const ptime & end ) const ; private : static const time_duration hourlyTd ; static const time_duration dailyTd ; time_duration multiply ( double mult ) const ; time_duration * regularStep = nullptr ; // void CopyRegularImplementation(const RegularTimeStepImplementation& src); // const ptrdiff_t GetUpperNumInstants(const ptime& start, const ptime& end) const; // const ptrdiff_t GetNumInstants(const ptime& start, const ptime& end) const; }; class DATATYPES_DLL_LIB IrregularTimeStepImplementation : public TimeStepImplementation { public : virtual ~ IrregularTimeStepImplementation () {} virtual TimeStepImplementation * Clone () = 0 ; virtual bool Equals ( TimeStepImplementation * tsImpl ) const = 0 ; TimeStepImplementation * Multiply ( int mult ) const ; TimeStepImplementation * Multiply ( double mult ) const ; TimeStepImplementation * Divide ( int divisor ) const ; virtual const ptime AddIntSteps ( const ptime & startTimeStep , int n ) const = 0 ; virtual const ptime AddSteps ( const ptime & startTimeStep , double mult ) const = 0 ; virtual const time_duration GetTimeStepDuration ( const ptime & startTimeStep ) const ; virtual const void Increment ( ptime * t ) const = 0 ; bool IsRegular () const ; time_duration GetRegularStepDuration () const ; virtual std :: string GetName () const = 0 ; protected : virtual const double GetLinearIndexing ( const ptime & start , const ptime & end ) const = 0 ; }; class DATATYPES_DLL_LIB MonthlyQppTimeStepImplementation : public IrregularTimeStepImplementation { public : virtual ~ MonthlyQppTimeStepImplementation () {} TimeStepImplementation * Clone (); bool Equals ( TimeStepImplementation * tsImpl ) const ; const ptime AddIntSteps ( const ptime & startTimeStep , int n ) const ; const ptime AddSteps ( const ptime & startTimeStep , double mult ) const ; const time_duration GetTimeStepDuration ( const ptime & startTimeStep ) const override ; const void Increment ( ptime * t ) const ; std :: string GetName () const ; protected : const double GetLinearIndexing ( const ptime & start , const ptime & end ) const ; }; } } Updated on 2022-08-20 at 19:28:22 +1000","title":"Source code"},{"location":"cpp/Modules/","text":"Modules \u00b6 Updated on 2022-08-20 at 19:28:22 +1000","title":"Modules"},{"location":"cpp/Modules/#modules","text":"Updated on 2022-08-20 at 19:28:22 +1000","title":"Modules"},{"location":"cpp/Namespaces/","text":"Namespaces \u00b6 namespace boost::gregorian namespace boost::posix_time namespace cinterop namespace statistics namespace timeseries namespace cinterop::utils namespace datatypes namespace exceptions namespace interop namespace io namespace tests namespace timeseries namespace io namespace utils namespace moirai namespace std Updated on 2022-08-20 at 19:28:22 +1000","title":"Namespaces"},{"location":"cpp/Namespaces/#namespaces","text":"namespace boost::gregorian namespace boost::posix_time namespace cinterop namespace statistics namespace timeseries namespace cinterop::utils namespace datatypes namespace exceptions namespace interop namespace io namespace tests namespace timeseries namespace io namespace utils namespace moirai namespace std Updated on 2022-08-20 at 19:28:22 +1000","title":"Namespaces"},{"location":"cpp/Namespaces/namespaceboost_1_1gregorian/","text":"boost::gregorian \u00b6 Updated on 2022-08-20 at 19:28:22 +1000","title":"boost::gregorian"},{"location":"cpp/Namespaces/namespaceboost_1_1gregorian/#boostgregorian","text":"Updated on 2022-08-20 at 19:28:22 +1000","title":"boost::gregorian"},{"location":"cpp/Namespaces/namespaceboost_1_1posix__time/","text":"boost::posix_time \u00b6 Updated on 2022-08-20 at 19:28:22 +1000","title":"boost::posix_time"},{"location":"cpp/Namespaces/namespaceboost_1_1posix__time/#boostposix_time","text":"Updated on 2022-08-20 at 19:28:22 +1000","title":"boost::posix_time"},{"location":"cpp/Namespaces/namespacecinterop/","text":"cinterop \u00b6 Namespaces \u00b6 Name cinterop::statistics cinterop::timeseries Updated on 2022-08-20 at 19:28:22 +1000","title":"cinterop"},{"location":"cpp/Namespaces/namespacecinterop/#cinterop","text":"","title":"cinterop"},{"location":"cpp/Namespaces/namespacecinterop/#namespaces","text":"Name cinterop::statistics cinterop::timeseries Updated on 2022-08-20 at 19:28:22 +1000","title":"Namespaces"},{"location":"cpp/Namespaces/namespacecinterop_1_1statistics/","text":"cinterop::statistics \u00b6 Functions \u00b6 Name statistic_definition * to_statistic_definition_ptr< TimeSeries > (const std::string & model_variable_id, const std::string & statistic_identifier, const std::string & objective_identifier, const std::string & objective_name, const date_time_to_second & start, const date_time_to_second & end, const TimeSeries & time_series_data) Functions Documentation \u00b6 function to_statistic_definition_ptr< TimeSeries > \u00b6 inline statistic_definition * to_statistic_definition_ptr < TimeSeries > ( const std :: string & model_variable_id , const std :: string & statistic_identifier , const std :: string & objective_identifier , const std :: string & objective_name , const date_time_to_second & start , const date_time_to_second & end , const TimeSeries & time_series_data ) Updated on 2022-08-20 at 19:28:22 +1000","title":"cinterop::statistics"},{"location":"cpp/Namespaces/namespacecinterop_1_1statistics/#cinteropstatistics","text":"","title":"cinterop::statistics"},{"location":"cpp/Namespaces/namespacecinterop_1_1statistics/#functions","text":"Name statistic_definition * to_statistic_definition_ptr< TimeSeries > (const std::string & model_variable_id, const std::string & statistic_identifier, const std::string & objective_identifier, const std::string & objective_name, const date_time_to_second & start, const date_time_to_second & end, const TimeSeries & time_series_data)","title":"Functions"},{"location":"cpp/Namespaces/namespacecinterop_1_1statistics/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"cpp/Namespaces/namespacecinterop_1_1statistics/#function-to_statistic_definition_ptr-timeseries","text":"inline statistic_definition * to_statistic_definition_ptr < TimeSeries > ( const std :: string & model_variable_id , const std :: string & statistic_identifier , const std :: string & objective_identifier , const std :: string & objective_name , const date_time_to_second & start , const date_time_to_second & end , const TimeSeries & time_series_data ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function to_statistic_definition_ptr&lt; TimeSeries &gt;"},{"location":"cpp/Namespaces/namespacecinterop_1_1timeseries/","text":"cinterop::timeseries \u00b6 Functions \u00b6 Name multi_regular_time_series_data * to_multi_regular_time_series_data_ptr< TimeSeries > (const TimeSeries & ts) Functions Documentation \u00b6 function to_multi_regular_time_series_data_ptr< TimeSeries > \u00b6 inline multi_regular_time_series_data * to_multi_regular_time_series_data_ptr < TimeSeries > ( const TimeSeries & ts ) Updated on 2022-08-20 at 19:28:22 +1000","title":"cinterop::timeseries"},{"location":"cpp/Namespaces/namespacecinterop_1_1timeseries/#cinteroptimeseries","text":"","title":"cinterop::timeseries"},{"location":"cpp/Namespaces/namespacecinterop_1_1timeseries/#functions","text":"Name multi_regular_time_series_data * to_multi_regular_time_series_data_ptr< TimeSeries > (const TimeSeries & ts)","title":"Functions"},{"location":"cpp/Namespaces/namespacecinterop_1_1timeseries/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"cpp/Namespaces/namespacecinterop_1_1timeseries/#function-to_multi_regular_time_series_data_ptr-timeseries","text":"inline multi_regular_time_series_data * to_multi_regular_time_series_data_ptr < TimeSeries > ( const TimeSeries & ts ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function to_multi_regular_time_series_data_ptr&lt; TimeSeries &gt;"},{"location":"cpp/Namespaces/namespacecinterop_1_1utils/","text":"cinterop::utils \u00b6 Updated on 2022-08-20 at 19:28:22 +1000","title":"cinterop::utils"},{"location":"cpp/Namespaces/namespacecinterop_1_1utils/#cinteroputils","text":"Updated on 2022-08-20 at 19:28:22 +1000","title":"cinterop::utils"},{"location":"cpp/Namespaces/namespacedatatypes/","text":"datatypes \u00b6 Namespaces \u00b6 Name datatypes::exceptions datatypes::interop datatypes::io datatypes::tests datatypes::timeseries datatypes::utils Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes"},{"location":"cpp/Namespaces/namespacedatatypes/#datatypes","text":"","title":"datatypes"},{"location":"cpp/Namespaces/namespacedatatypes/#namespaces","text":"Name datatypes::exceptions datatypes::interop datatypes::io datatypes::tests datatypes::timeseries datatypes::utils Updated on 2022-08-20 at 19:28:22 +1000","title":"Namespaces"},{"location":"cpp/Namespaces/namespacedatatypes_1_1exceptions/","text":"datatypes::exceptions \u00b6 Classes \u00b6 Name struct datatypes::exceptions::RangeCheck struct datatypes::exceptions::RangeCheck< size_t > class datatypes::exceptions::ExceptionUtilities class datatypes::exceptions::TimeSeriesChecks Functions \u00b6 Name template <typename T > void ThrowNotInRange (T value, T bound, const string & variableName, const string & condition, const string & boundType) Functions Documentation \u00b6 function ThrowNotInRange \u00b6 template < typename T > static void ThrowNotInRange ( T value , T bound , const string & variableName , const string & condition , const string & boundType ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::exceptions"},{"location":"cpp/Namespaces/namespacedatatypes_1_1exceptions/#datatypesexceptions","text":"","title":"datatypes::exceptions"},{"location":"cpp/Namespaces/namespacedatatypes_1_1exceptions/#classes","text":"Name struct datatypes::exceptions::RangeCheck struct datatypes::exceptions::RangeCheck< size_t > class datatypes::exceptions::ExceptionUtilities class datatypes::exceptions::TimeSeriesChecks","title":"Classes"},{"location":"cpp/Namespaces/namespacedatatypes_1_1exceptions/#functions","text":"Name template <typename T > void ThrowNotInRange (T value, T bound, const string & variableName, const string & condition, const string & boundType)","title":"Functions"},{"location":"cpp/Namespaces/namespacedatatypes_1_1exceptions/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"cpp/Namespaces/namespacedatatypes_1_1exceptions/#function-thrownotinrange","text":"template < typename T > static void ThrowNotInRange ( T value , T bound , const string & variableName , const string & condition , const string & boundType ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function ThrowNotInRange"},{"location":"cpp/Namespaces/namespacedatatypes_1_1interop/","text":"datatypes::interop \u00b6 Classes \u00b6 Name class datatypes::interop::MissingValueHandling Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::interop"},{"location":"cpp/Namespaces/namespacedatatypes_1_1interop/#datatypesinterop","text":"","title":"datatypes::interop"},{"location":"cpp/Namespaces/namespacedatatypes_1_1interop/#classes","text":"Name class datatypes::interop::MissingValueHandling Updated on 2022-08-20 at 19:28:22 +1000","title":"Classes"},{"location":"cpp/Namespaces/namespacedatatypes_1_1io/","text":"datatypes::io \u00b6 Classes \u00b6 Name class datatypes::io::IoHelper Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::io"},{"location":"cpp/Namespaces/namespacedatatypes_1_1io/#datatypesio","text":"","title":"datatypes::io"},{"location":"cpp/Namespaces/namespacedatatypes_1_1io/#classes","text":"Name class datatypes::io::IoHelper Updated on 2022-08-20 at 19:28:22 +1000","title":"Classes"},{"location":"cpp/Namespaces/namespacedatatypes_1_1tests/","text":"datatypes::tests \u00b6 Classes \u00b6 Name class datatypes::tests::FileSystemHelper class datatypes::tests::TempFileCleaner class datatypes::tests::TestDataLocationHelper class datatypes::tests::TestSingleTimeSeriesStore class datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore A time series store for unit tests. class datatypes::tests::TestEnsembleTimeSeriesStore class datatypes::tests::TestTimeSeriesStoreFactory class datatypes::tests::DataTestHelper Functions \u00b6 Name template <typename T > bool AreEqual (const vector< T > & a, const vector< T > & b, bool strict =false, double tolerance =1e-12) template <typename T > bool AllEqual (const vector< T > & values, T testValue) template <typename T > bool VectorEqual (const vector< T > & a, const vector< T > & b) Functions Documentation \u00b6 function AreEqual \u00b6 template < typename T > bool AreEqual ( const vector < T > & a , const vector < T > & b , bool strict = false , double tolerance = 1e-12 ) function AllEqual \u00b6 template < typename T > bool AllEqual ( const vector < T > & values , T testValue ) function VectorEqual \u00b6 template < typename T > bool VectorEqual ( const vector < T > & a , const vector < T > & b ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::tests"},{"location":"cpp/Namespaces/namespacedatatypes_1_1tests/#datatypestests","text":"","title":"datatypes::tests"},{"location":"cpp/Namespaces/namespacedatatypes_1_1tests/#classes","text":"Name class datatypes::tests::FileSystemHelper class datatypes::tests::TempFileCleaner class datatypes::tests::TestDataLocationHelper class datatypes::tests::TestSingleTimeSeriesStore class datatypes::tests::TestTimeSeriesEnsembleTimeSeriesStore A time series store for unit tests. class datatypes::tests::TestEnsembleTimeSeriesStore class datatypes::tests::TestTimeSeriesStoreFactory class datatypes::tests::DataTestHelper","title":"Classes"},{"location":"cpp/Namespaces/namespacedatatypes_1_1tests/#functions","text":"Name template <typename T > bool AreEqual (const vector< T > & a, const vector< T > & b, bool strict =false, double tolerance =1e-12) template <typename T > bool AllEqual (const vector< T > & values, T testValue) template <typename T > bool VectorEqual (const vector< T > & a, const vector< T > & b)","title":"Functions"},{"location":"cpp/Namespaces/namespacedatatypes_1_1tests/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"cpp/Namespaces/namespacedatatypes_1_1tests/#function-areequal","text":"template < typename T > bool AreEqual ( const vector < T > & a , const vector < T > & b , bool strict = false , double tolerance = 1e-12 )","title":"function AreEqual"},{"location":"cpp/Namespaces/namespacedatatypes_1_1tests/#function-allequal","text":"template < typename T > bool AllEqual ( const vector < T > & values , T testValue )","title":"function AllEqual"},{"location":"cpp/Namespaces/namespacedatatypes_1_1tests/#function-vectorequal","text":"template < typename T > bool VectorEqual ( const vector < T > & a , const vector < T > & b ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function VectorEqual"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries/","text":"datatypes::timeseries \u00b6 Namespaces \u00b6 Name datatypes::timeseries::io Classes \u00b6 Name struct datatypes::timeseries::DefaultMissingValuePolicyTypeFactory class datatypes::timeseries::TTimeSeries A template for univariate, single realisasion time series. class datatypes::timeseries::MultiTimeSeries Template for time series with multiple values at time point; e.g. to hold multiple realizations of time series in an ensemble. struct datatypes::timeseries::time_series_of struct datatypes::timeseries::ensemble_of struct datatypes::timeseries::item_type_of struct datatypes::timeseries::CommonTypes Typical ensemble and time series data types derived from a fundamental data type for each data item. class datatypes::timeseries::TimeSeriesOperations class datatypes::timeseries::TimeWindow An object that represents a time window, defining subset/trim operations on time series. class datatypes::timeseries::GlobalAttributes A class to hold the global attributes of a file stored in the SWIFT netCDF format. class datatypes::timeseries::VariableAttributes A class to hold the attributes of a netCDF variable stored in the SWIFT netCDF format. class datatypes::timeseries::VariableDefinition class datatypes::timeseries::DimensionsDefinitions class datatypes::timeseries::DataGeometryProvider class datatypes::timeseries::TimeSeriesIOHelper Representation of an univariate, ensemble time series with a SWIFT netCDF back end. class datatypes::timeseries::SingleNetCdfFileStore class datatypes::timeseries::NetCdfSingleSeriesStore class datatypes::timeseries::NetCdfEnsembleTimeSeriesStore class datatypes::timeseries::EagerWriter class datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore class datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore An implementation of TimeSeriesEnsembleTimeSeriesStore such that the content of a time series is spread amongst several files. class datatypes::timeseries::MultiFileTsStorage An implementation of StoragePolicy such that the content of a time series is spread amongst several files. class datatypes::timeseries::TimeSeriesLibraryFactory class datatypes::timeseries::SwiftNetcdfStoreFactory class datatypes::timeseries::IdentifiersProvider An interface definition for objects that can provide hierarchical identification. class datatypes::timeseries::TimeSeriesProvider Library of time series, for high level access to sources of univariate, single instance time series that may have varying on-disk representations. class datatypes::timeseries::DataDimensionDescriptor class datatypes::timeseries::DataDescriptor class datatypes::timeseries::SingleTimeSeriesStore Interface definition for storages of single, univariate time series. class datatypes::timeseries::EnsembleTimeSeriesStore Interface definition for storages of ensembles of univariate time series. class datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore Interface definition for storages of time series of ensembles of time series. class datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore class datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy class datatypes::timeseries::TTimeSeriesLibrary class datatypes::timeseries::TimeSeriesSourceInfoImpl class datatypes::timeseries::TimeSeriesSourceInfo class datatypes::timeseries::NetCdfSourceInfo class datatypes::timeseries::TimeSeriesLibraryDescription class datatypes::timeseries::TimeSeriesSourceInfoBuilder An abstract class to allow callers to inject custom time series data sources into a time series library. class datatypes::timeseries::TimeSeriesStoreFactory class datatypes::timeseries::TimeSeriesLibrary Library of time series, for high level access to sources of time series that nmay have varying on-disk representations. class datatypes::timeseries::StoragePolicy An interface for classes that can handle the storage of data for time series. class datatypes::timeseries::MissingValuePolicy An interface for classes that define missing values in time series. class datatypes::timeseries::DefaultMissingFloatingPointPolicy class datatypes::timeseries::NullPointerIsMissingPolicy class datatypes::timeseries::NegativeIsMissingFloadingPointPolicy class datatypes::timeseries::StlVectorStorage class datatypes::timeseries::SharedVectorStorage A storage strategy for time serie such that data is a shared state amongst several time series. class datatypes::timeseries::MemoryCachingStorageWriter class datatypes::timeseries::EnsembleStoragePolicy class datatypes::timeseries::StdVectorEnsembleStoragePolicy class datatypes::timeseries::TimeStep Time step handling for time series. class datatypes::timeseries::TimeSeriesInfoProvider An interface definition for classes that can provide essential time series temporal characteristics. class datatypes::timeseries::TimeStepImplementation class datatypes::timeseries::RegularTimeStepImplementation class datatypes::timeseries::IrregularTimeStepImplementation class datatypes::timeseries::MonthlyQppTimeStepImplementation Types \u00b6 Name typedef TTimeSeries < double > TimeSeries template <typename ItemType > using TTimeSeries < ItemType * > PointerTypeTimeSeries template <typename Tts =TimeSeries> using MultiTimeSeries < Tts * > MultiTimeSeriesPtr template <typename Tts =TimeSeries> using PointerTypeTimeSeries < Tts > ForecastTimeSeries template <typename Tts =TimeSeries> using MultiTimeSeriesPtr < Tts > TimeSeriesEnsemble template <typename Tts =TimeSeries> using PointerTypeTimeSeries < MultiTimeSeriesPtr < Tts > > EnsembleForecastTimeSeries Functions \u00b6 Name template <typename T > MissingValuePolicy < T > * DefaultMissingValuePolicy () Default missing value policy. template <typename T > StoragePolicy < T > * DefaultStoragePolicy () Default strategy for storing time series data. template <typename T > TTimeSeries < T > operator<< (const TTimeSeries < T > & a, const TTimeSeries < T > & b) template <typename From ,typename To > To GetMetadataFrom (const From & ens) template <typename ElementType > DimensionsDefinitions DimensionsFromSeries (const TTimeSeries < ElementType > & ts, const size_t ensembleSize =1, const size_t leadTimeSize =1, const vector< string > & stationIds = DEFAULT_STATION_IDENTIFIER ) template <typename ElementType > DimensionsDefinitions DimensionsFromSeries ( EnsembleForecastTimeSeries <> & tsEns, const vector< string > & stationIds = DEFAULT_STATION_IDENTIFIER ) template <typename ElementType > DimensionsDefinitions DimensionsFromSeries (const vector< EnsembleForecastTimeSeries <>::ElementType > & values, const TimeStep & tsEnsTstep = TimeStep::GetUnknown (), const ptime & tsEnsStart =not_a_date_time, const vector< string > & stationIds = DEFAULT_STATION_IDENTIFIER , int fcastOffset =1) template <typename TElement > DimensionsDefinitions DimensionsFromPointTimeSeries (const TTimeSeries < TElement > & ts) Types Documentation \u00b6 typedef TimeSeries \u00b6 typedef TTimeSeries < double > datatypes :: timeseries :: TimeSeries ; using PointerTypeTimeSeries \u00b6 template < typename ItemType > using datatypes :: timeseries :: PointerTypeTimeSeries = typedef TTimeSeries < ItemType * > ; using MultiTimeSeriesPtr \u00b6 template < typename Tts = TimeSeries > using datatypes :: timeseries :: MultiTimeSeriesPtr = typedef MultiTimeSeries < Tts * > ; using ForecastTimeSeries \u00b6 template < typename Tts = TimeSeries > using datatypes :: timeseries :: ForecastTimeSeries = typedef PointerTypeTimeSeries < Tts > ; using TimeSeriesEnsemble \u00b6 template < typename Tts = TimeSeries > using datatypes :: timeseries :: TimeSeriesEnsemble = typedef MultiTimeSeriesPtr < Tts > ; using EnsembleForecastTimeSeries \u00b6 template < typename Tts = TimeSeries > using datatypes :: timeseries :: EnsembleForecastTimeSeries = typedef PointerTypeTimeSeries < MultiTimeSeriesPtr < Tts > > ; Functions Documentation \u00b6 function DefaultMissingValuePolicy \u00b6 template < typename T > MissingValuePolicy < T > * DefaultMissingValuePolicy () Default missing value policy. Template Parameters : T Generic type parameter, the type of the elements of the time series Return : A new object inheriting from MissingValuePolicy *> A function that returnes a suitable default object to handle time series behaviors with respect to missing values function DefaultStoragePolicy \u00b6 template < typename T > StoragePolicy < T > * DefaultStoragePolicy () Default strategy for storing time series data. Template Parameters : T Generic type parameter, the type of the elements of the time series Return : A new object inheriting from StoragePolicy *> A function that returnes a suitable default object to handle the storage of time series data. The default is in memory vector. function operator<< \u00b6 template < typename T > TTimeSeries < T > operator << ( const TTimeSeries < T > & a , const TTimeSeries < T > & b ) function GetMetadataFrom \u00b6 template < typename From , typename To > To GetMetadataFrom ( const From & ens ) function DimensionsFromSeries \u00b6 template < typename ElementType > DimensionsDefinitions DimensionsFromSeries ( const TTimeSeries < ElementType > & ts , const size_t ensembleSize = 1 , const size_t leadTimeSize = 1 , const vector < string > & stationIds = DEFAULT_STATION_IDENTIFIER ) function DimensionsFromSeries \u00b6 template < typename ElementType > DimensionsDefinitions DimensionsFromSeries ( EnsembleForecastTimeSeries <> & tsEns , const vector < string > & stationIds = DEFAULT_STATION_IDENTIFIER ) function DimensionsFromSeries \u00b6 template < typename ElementType > DimensionsDefinitions DimensionsFromSeries ( const vector < EnsembleForecastTimeSeries <>:: ElementType > & values , const TimeStep & tsEnsTstep = TimeStep :: GetUnknown (), const ptime & tsEnsStart = not_a_date_time , const vector < string > & stationIds = DEFAULT_STATION_IDENTIFIER , int fcastOffset = 1 ) function DimensionsFromPointTimeSeries \u00b6 template < typename TElement > DimensionsDefinitions DimensionsFromPointTimeSeries ( const TTimeSeries < TElement > & ts ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries/#datatypestimeseries","text":"","title":"datatypes::timeseries"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries/#namespaces","text":"Name datatypes::timeseries::io","title":"Namespaces"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries/#classes","text":"Name struct datatypes::timeseries::DefaultMissingValuePolicyTypeFactory class datatypes::timeseries::TTimeSeries A template for univariate, single realisasion time series. class datatypes::timeseries::MultiTimeSeries Template for time series with multiple values at time point; e.g. to hold multiple realizations of time series in an ensemble. struct datatypes::timeseries::time_series_of struct datatypes::timeseries::ensemble_of struct datatypes::timeseries::item_type_of struct datatypes::timeseries::CommonTypes Typical ensemble and time series data types derived from a fundamental data type for each data item. class datatypes::timeseries::TimeSeriesOperations class datatypes::timeseries::TimeWindow An object that represents a time window, defining subset/trim operations on time series. class datatypes::timeseries::GlobalAttributes A class to hold the global attributes of a file stored in the SWIFT netCDF format. class datatypes::timeseries::VariableAttributes A class to hold the attributes of a netCDF variable stored in the SWIFT netCDF format. class datatypes::timeseries::VariableDefinition class datatypes::timeseries::DimensionsDefinitions class datatypes::timeseries::DataGeometryProvider class datatypes::timeseries::TimeSeriesIOHelper Representation of an univariate, ensemble time series with a SWIFT netCDF back end. class datatypes::timeseries::SingleNetCdfFileStore class datatypes::timeseries::NetCdfSingleSeriesStore class datatypes::timeseries::NetCdfEnsembleTimeSeriesStore class datatypes::timeseries::EagerWriter class datatypes::timeseries::NetCdfTimeSeriesEnsembleTimeSeriesStore class datatypes::timeseries::MultiFileTimeSeriesEnsembleTimeSeriesStore An implementation of TimeSeriesEnsembleTimeSeriesStore such that the content of a time series is spread amongst several files. class datatypes::timeseries::MultiFileTsStorage An implementation of StoragePolicy such that the content of a time series is spread amongst several files. class datatypes::timeseries::TimeSeriesLibraryFactory class datatypes::timeseries::SwiftNetcdfStoreFactory class datatypes::timeseries::IdentifiersProvider An interface definition for objects that can provide hierarchical identification. class datatypes::timeseries::TimeSeriesProvider Library of time series, for high level access to sources of univariate, single instance time series that may have varying on-disk representations. class datatypes::timeseries::DataDimensionDescriptor class datatypes::timeseries::DataDescriptor class datatypes::timeseries::SingleTimeSeriesStore Interface definition for storages of single, univariate time series. class datatypes::timeseries::EnsembleTimeSeriesStore Interface definition for storages of ensembles of univariate time series. class datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStore Interface definition for storages of time series of ensembles of time series. class datatypes::timeseries::WritableTimeSeriesEnsembleTimeSeriesStore class datatypes::timeseries::TimeSeriesEnsembleTimeSeriesStoragePolicy class datatypes::timeseries::TTimeSeriesLibrary class datatypes::timeseries::TimeSeriesSourceInfoImpl class datatypes::timeseries::TimeSeriesSourceInfo class datatypes::timeseries::NetCdfSourceInfo class datatypes::timeseries::TimeSeriesLibraryDescription class datatypes::timeseries::TimeSeriesSourceInfoBuilder An abstract class to allow callers to inject custom time series data sources into a time series library. class datatypes::timeseries::TimeSeriesStoreFactory class datatypes::timeseries::TimeSeriesLibrary Library of time series, for high level access to sources of time series that nmay have varying on-disk representations. class datatypes::timeseries::StoragePolicy An interface for classes that can handle the storage of data for time series. class datatypes::timeseries::MissingValuePolicy An interface for classes that define missing values in time series. class datatypes::timeseries::DefaultMissingFloatingPointPolicy class datatypes::timeseries::NullPointerIsMissingPolicy class datatypes::timeseries::NegativeIsMissingFloadingPointPolicy class datatypes::timeseries::StlVectorStorage class datatypes::timeseries::SharedVectorStorage A storage strategy for time serie such that data is a shared state amongst several time series. class datatypes::timeseries::MemoryCachingStorageWriter class datatypes::timeseries::EnsembleStoragePolicy class datatypes::timeseries::StdVectorEnsembleStoragePolicy class datatypes::timeseries::TimeStep Time step handling for time series. class datatypes::timeseries::TimeSeriesInfoProvider An interface definition for classes that can provide essential time series temporal characteristics. class datatypes::timeseries::TimeStepImplementation class datatypes::timeseries::RegularTimeStepImplementation class datatypes::timeseries::IrregularTimeStepImplementation class datatypes::timeseries::MonthlyQppTimeStepImplementation","title":"Classes"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries/#types","text":"Name typedef TTimeSeries < double > TimeSeries template <typename ItemType > using TTimeSeries < ItemType * > PointerTypeTimeSeries template <typename Tts =TimeSeries> using MultiTimeSeries < Tts * > MultiTimeSeriesPtr template <typename Tts =TimeSeries> using PointerTypeTimeSeries < Tts > ForecastTimeSeries template <typename Tts =TimeSeries> using MultiTimeSeriesPtr < Tts > TimeSeriesEnsemble template <typename Tts =TimeSeries> using PointerTypeTimeSeries < MultiTimeSeriesPtr < Tts > > EnsembleForecastTimeSeries","title":"Types"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries/#functions","text":"Name template <typename T > MissingValuePolicy < T > * DefaultMissingValuePolicy () Default missing value policy. template <typename T > StoragePolicy < T > * DefaultStoragePolicy () Default strategy for storing time series data. template <typename T > TTimeSeries < T > operator<< (const TTimeSeries < T > & a, const TTimeSeries < T > & b) template <typename From ,typename To > To GetMetadataFrom (const From & ens) template <typename ElementType > DimensionsDefinitions DimensionsFromSeries (const TTimeSeries < ElementType > & ts, const size_t ensembleSize =1, const size_t leadTimeSize =1, const vector< string > & stationIds = DEFAULT_STATION_IDENTIFIER ) template <typename ElementType > DimensionsDefinitions DimensionsFromSeries ( EnsembleForecastTimeSeries <> & tsEns, const vector< string > & stationIds = DEFAULT_STATION_IDENTIFIER ) template <typename ElementType > DimensionsDefinitions DimensionsFromSeries (const vector< EnsembleForecastTimeSeries <>::ElementType > & values, const TimeStep & tsEnsTstep = TimeStep::GetUnknown (), const ptime & tsEnsStart =not_a_date_time, const vector< string > & stationIds = DEFAULT_STATION_IDENTIFIER , int fcastOffset =1) template <typename TElement > DimensionsDefinitions DimensionsFromPointTimeSeries (const TTimeSeries < TElement > & ts)","title":"Functions"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries/#types-documentation","text":"","title":"Types Documentation"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries/#typedef-timeseries","text":"typedef TTimeSeries < double > datatypes :: timeseries :: TimeSeries ;","title":"typedef TimeSeries"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries/#using-pointertypetimeseries","text":"template < typename ItemType > using datatypes :: timeseries :: PointerTypeTimeSeries = typedef TTimeSeries < ItemType * > ;","title":"using PointerTypeTimeSeries"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries/#using-multitimeseriesptr","text":"template < typename Tts = TimeSeries > using datatypes :: timeseries :: MultiTimeSeriesPtr = typedef MultiTimeSeries < Tts * > ;","title":"using MultiTimeSeriesPtr"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries/#using-forecasttimeseries","text":"template < typename Tts = TimeSeries > using datatypes :: timeseries :: ForecastTimeSeries = typedef PointerTypeTimeSeries < Tts > ;","title":"using ForecastTimeSeries"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries/#using-timeseriesensemble","text":"template < typename Tts = TimeSeries > using datatypes :: timeseries :: TimeSeriesEnsemble = typedef MultiTimeSeriesPtr < Tts > ;","title":"using TimeSeriesEnsemble"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries/#using-ensembleforecasttimeseries","text":"template < typename Tts = TimeSeries > using datatypes :: timeseries :: EnsembleForecastTimeSeries = typedef PointerTypeTimeSeries < MultiTimeSeriesPtr < Tts > > ;","title":"using EnsembleForecastTimeSeries"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries/#function-defaultmissingvaluepolicy","text":"template < typename T > MissingValuePolicy < T > * DefaultMissingValuePolicy () Default missing value policy. Template Parameters : T Generic type parameter, the type of the elements of the time series Return : A new object inheriting from MissingValuePolicy *> A function that returnes a suitable default object to handle time series behaviors with respect to missing values","title":"function DefaultMissingValuePolicy"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries/#function-defaultstoragepolicy","text":"template < typename T > StoragePolicy < T > * DefaultStoragePolicy () Default strategy for storing time series data. Template Parameters : T Generic type parameter, the type of the elements of the time series Return : A new object inheriting from StoragePolicy *> A function that returnes a suitable default object to handle the storage of time series data. The default is in memory vector.","title":"function DefaultStoragePolicy"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries/#function-operator","text":"template < typename T > TTimeSeries < T > operator << ( const TTimeSeries < T > & a , const TTimeSeries < T > & b )","title":"function operator&lt;&lt;"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries/#function-getmetadatafrom","text":"template < typename From , typename To > To GetMetadataFrom ( const From & ens )","title":"function GetMetadataFrom"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries/#function-dimensionsfromseries","text":"template < typename ElementType > DimensionsDefinitions DimensionsFromSeries ( const TTimeSeries < ElementType > & ts , const size_t ensembleSize = 1 , const size_t leadTimeSize = 1 , const vector < string > & stationIds = DEFAULT_STATION_IDENTIFIER )","title":"function DimensionsFromSeries"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries/#function-dimensionsfromseries_1","text":"template < typename ElementType > DimensionsDefinitions DimensionsFromSeries ( EnsembleForecastTimeSeries <> & tsEns , const vector < string > & stationIds = DEFAULT_STATION_IDENTIFIER )","title":"function DimensionsFromSeries"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries/#function-dimensionsfromseries_2","text":"template < typename ElementType > DimensionsDefinitions DimensionsFromSeries ( const vector < EnsembleForecastTimeSeries <>:: ElementType > & values , const TimeStep & tsEnsTstep = TimeStep :: GetUnknown (), const ptime & tsEnsStart = not_a_date_time , const vector < string > & stationIds = DEFAULT_STATION_IDENTIFIER , int fcastOffset = 1 )","title":"function DimensionsFromSeries"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries/#function-dimensionsfrompointtimeseries","text":"template < typename TElement > DimensionsDefinitions DimensionsFromPointTimeSeries ( const TTimeSeries < TElement > & ts ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function DimensionsFromPointTimeSeries"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries_1_1io/","text":"datatypes::timeseries::io \u00b6 Classes \u00b6 Name class datatypes::timeseries::io::SwiftNetCDFVariablePersister class datatypes::timeseries::io::SwiftNetCDFVariablePersister< double > class datatypes::timeseries::io::SwiftNetCDFVariablePersister< float > class datatypes::timeseries::io::SwiftNetCDFVariablePersister< long > class datatypes::timeseries::io::SwiftNetCDFVariablePersister< int > class datatypes::timeseries::io::SwiftNetCDFAccess Class responsible for the low-level read/write operations from/to a SWIFT netCDF file. class datatypes::timeseries::io::ConfigFileHelper Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::timeseries::io"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries_1_1io/#datatypestimeseriesio","text":"","title":"datatypes::timeseries::io"},{"location":"cpp/Namespaces/namespacedatatypes_1_1timeseries_1_1io/#classes","text":"Name class datatypes::timeseries::io::SwiftNetCDFVariablePersister class datatypes::timeseries::io::SwiftNetCDFVariablePersister< double > class datatypes::timeseries::io::SwiftNetCDFVariablePersister< float > class datatypes::timeseries::io::SwiftNetCDFVariablePersister< long > class datatypes::timeseries::io::SwiftNetCDFVariablePersister< int > class datatypes::timeseries::io::SwiftNetCDFAccess Class responsible for the low-level read/write operations from/to a SWIFT netCDF file. class datatypes::timeseries::io::ConfigFileHelper Updated on 2022-08-20 at 19:28:22 +1000","title":"Classes"},{"location":"cpp/Namespaces/namespacedatatypes_1_1utils/","text":"datatypes::utils \u00b6 Classes \u00b6 Name class datatypes::utils::STLHelper class datatypes::utils::IfThenElse class datatypes::utils::IfThenElse< true, Ta, Tb > class datatypes::utils::IfThenElse< false, Ta, Tb > class datatypes::utils::ValueTypeVectorDispose class datatypes::utils::PointerTypeVectorDispose struct datatypes::utils::DisposeVectorTypeFactory class datatypes::utils::bad_lexical_cast A bad_lexical_cast that inherits from std::exception, unlike Boost's. Needed for graceful C API interop. class datatypes::utils::StringProcessing Functions \u00b6 Name void datatypes_delete_ansi_string_array (char ** values, int arrayLength) template <typename T =double> vector< T > SeqVec (T from, T by, size_t num) template <typename T > void DisposeVector (vector< T > & v) template <typename Target > Target Parse (const string & strId) Wraps boost::lexical_cast with a try/catch; rethrows an exception that inherits from std::exception and a more useful error message. template <typename Source > string ToString (const Source & value) template <class TTo > TTo * ConvertToArray (const vector< string > & src) template <class TFrom ,class TTo > TTo * ConvertToArray (const vector< TFrom > & src) template <class TFrom ,class TTo > vector< TTo > Convert (const vector< TFrom > & src) template <class TTo > vector< TTo > Convert (const vector< string > & src) template <typename T =boost::posix_time::ptime> T CreateTime (int year, int month, int day, int hour =0, int minute =0, int second =0) Functions Documentation \u00b6 function datatypes_delete_ansi_string_array \u00b6 void datatypes_delete_ansi_string_array ( char ** values , int arrayLength ) function SeqVec \u00b6 template < typename T = double > vector < T > SeqVec ( T from , T by , size_t num ) function DisposeVector \u00b6 template < typename T > void DisposeVector ( vector < T > & v ) function Parse \u00b6 template < typename Target > static Target Parse ( const string & strId ) Wraps boost::lexical_cast with a try/catch; rethrows an exception that inherits from std::exception and a more useful error message. function ToString \u00b6 template < typename Source > static string ToString ( const Source & value ) function ConvertToArray \u00b6 template < class TTo > static TTo * ConvertToArray ( const vector < string > & src ) function ConvertToArray \u00b6 template < class TFrom , class TTo > static TTo * ConvertToArray ( const vector < TFrom > & src ) function Convert \u00b6 template < class TFrom , class TTo > static vector < TTo > Convert ( const vector < TFrom > & src ) function Convert \u00b6 template < class TTo > vector < TTo > Convert ( const vector < string > & src ) function CreateTime \u00b6 template < typename T = boost :: posix_time :: ptime > T CreateTime ( int year , int month , int day , int hour = 0 , int minute = 0 , int second = 0 ) Updated on 2022-08-20 at 19:28:22 +1000","title":"datatypes::utils"},{"location":"cpp/Namespaces/namespacedatatypes_1_1utils/#datatypesutils","text":"","title":"datatypes::utils"},{"location":"cpp/Namespaces/namespacedatatypes_1_1utils/#classes","text":"Name class datatypes::utils::STLHelper class datatypes::utils::IfThenElse class datatypes::utils::IfThenElse< true, Ta, Tb > class datatypes::utils::IfThenElse< false, Ta, Tb > class datatypes::utils::ValueTypeVectorDispose class datatypes::utils::PointerTypeVectorDispose struct datatypes::utils::DisposeVectorTypeFactory class datatypes::utils::bad_lexical_cast A bad_lexical_cast that inherits from std::exception, unlike Boost's. Needed for graceful C API interop. class datatypes::utils::StringProcessing","title":"Classes"},{"location":"cpp/Namespaces/namespacedatatypes_1_1utils/#functions","text":"Name void datatypes_delete_ansi_string_array (char ** values, int arrayLength) template <typename T =double> vector< T > SeqVec (T from, T by, size_t num) template <typename T > void DisposeVector (vector< T > & v) template <typename Target > Target Parse (const string & strId) Wraps boost::lexical_cast with a try/catch; rethrows an exception that inherits from std::exception and a more useful error message. template <typename Source > string ToString (const Source & value) template <class TTo > TTo * ConvertToArray (const vector< string > & src) template <class TFrom ,class TTo > TTo * ConvertToArray (const vector< TFrom > & src) template <class TFrom ,class TTo > vector< TTo > Convert (const vector< TFrom > & src) template <class TTo > vector< TTo > Convert (const vector< string > & src) template <typename T =boost::posix_time::ptime> T CreateTime (int year, int month, int day, int hour =0, int minute =0, int second =0)","title":"Functions"},{"location":"cpp/Namespaces/namespacedatatypes_1_1utils/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"cpp/Namespaces/namespacedatatypes_1_1utils/#function-datatypes_delete_ansi_string_array","text":"void datatypes_delete_ansi_string_array ( char ** values , int arrayLength )","title":"function datatypes_delete_ansi_string_array"},{"location":"cpp/Namespaces/namespacedatatypes_1_1utils/#function-seqvec","text":"template < typename T = double > vector < T > SeqVec ( T from , T by , size_t num )","title":"function SeqVec"},{"location":"cpp/Namespaces/namespacedatatypes_1_1utils/#function-disposevector","text":"template < typename T > void DisposeVector ( vector < T > & v )","title":"function DisposeVector"},{"location":"cpp/Namespaces/namespacedatatypes_1_1utils/#function-parse","text":"template < typename Target > static Target Parse ( const string & strId ) Wraps boost::lexical_cast with a try/catch; rethrows an exception that inherits from std::exception and a more useful error message.","title":"function Parse"},{"location":"cpp/Namespaces/namespacedatatypes_1_1utils/#function-tostring","text":"template < typename Source > static string ToString ( const Source & value )","title":"function ToString"},{"location":"cpp/Namespaces/namespacedatatypes_1_1utils/#function-converttoarray","text":"template < class TTo > static TTo * ConvertToArray ( const vector < string > & src )","title":"function ConvertToArray"},{"location":"cpp/Namespaces/namespacedatatypes_1_1utils/#function-converttoarray_1","text":"template < class TFrom , class TTo > static TTo * ConvertToArray ( const vector < TFrom > & src )","title":"function ConvertToArray"},{"location":"cpp/Namespaces/namespacedatatypes_1_1utils/#function-convert","text":"template < class TFrom , class TTo > static vector < TTo > Convert ( const vector < TFrom > & src )","title":"function Convert"},{"location":"cpp/Namespaces/namespacedatatypes_1_1utils/#function-convert_1","text":"template < class TTo > vector < TTo > Convert ( const vector < string > & src )","title":"function Convert"},{"location":"cpp/Namespaces/namespacedatatypes_1_1utils/#function-createtime","text":"template < typename T = boost :: posix_time :: ptime > T CreateTime ( int year , int month , int day , int hour = 0 , int minute = 0 , int second = 0 ) Updated on 2022-08-20 at 19:28:22 +1000","title":"function CreateTime"},{"location":"cpp/Namespaces/namespacemoirai/","text":"moirai \u00b6 Classes \u00b6 Name struct moirai::known_conversions< TimeSeriesProvider< double > > Updated on 2022-08-20 at 19:28:22 +1000","title":"moirai"},{"location":"cpp/Namespaces/namespacemoirai/#moirai","text":"","title":"moirai"},{"location":"cpp/Namespaces/namespacemoirai/#classes","text":"Name struct moirai::known_conversions< TimeSeriesProvider< double > > Updated on 2022-08-20 at 19:28:22 +1000","title":"Classes"},{"location":"cpp/Namespaces/namespacestd/","text":"std \u00b6 Updated on 2022-08-20 at 19:28:22 +1000","title":"std"},{"location":"cpp/Namespaces/namespacestd/#std","text":"Updated on 2022-08-20 at 19:28:22 +1000","title":"std"},{"location":"cpp/Pages/","text":"Pages \u00b6 Updated on 2022-08-20 at 19:28:22 +1000","title":"Pages"},{"location":"cpp/Pages/#pages","text":"Updated on 2022-08-20 at 19:28:22 +1000","title":"Pages"}]}